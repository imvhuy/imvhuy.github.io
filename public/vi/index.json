[
{
	"uri": "//localhost:1313/vi/",
	"title": "Xây dựng Pipeline ETL Thời tiết Serverless",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Tổng quan Workshop Trong workshop này, em sẽ tạo một pipeline dữ liệu thời tiết đơn giản nhưng hoàn chỉnh, minh họa các khái niệm ETL cốt lõi sử dụng công nghệ serverless của AWS.\nWorkshop này trình bày cách xây dựng một pipeline ETL đơn giản sử dụng công nghệ serverless của AWS:\nThu thập dữ liệu thời tiết từ OpenWeatherMap API sử dụng AWS Lambda Xử lý và chuyển đổi dữ liệu thô thành định dạng phân tích Lưu trữ dữ liệu trong Amazon S3 cho cả dữ liệu thô và đã xử lý Phân tích dữ liệu sử dụng Amazon Athena với truy vấn SQL Trực quan hóa insights thông qua Amazon QuickSight dashboard Dọn dẹp tài nguyên để tối ưu chi phí Công nghệ sử dụng: Workshop sử dụng AWS Lambda, S3, Athena, QuickSight kết hợp với OpenWeatherMap API để xây dựng pipeline ETL serverless thu thập và phân tích dữ liệu thời tiết. Các phần chính 1. Giới thiệu Tổng quan workshop và mục tiêu học tập Thiết kế kiến trúc và giới thiệu các dịch vụ AWS Yêu cầu tiên quyết và thiết lập 2. Thu thập Dữ liệu Thời tiết với OpenWeatherMap Thiết lập tài khoản OpenWeatherMap API Tạo Lambda function cho thu thập dữ liệu Cấu hình tự động lấy dữ liệu Kiểm tra và giám sát quá trình thu thập 3. Xử lý Dữ liệu Serverless với Lambda Xây dựng Lambda function chuyển đổi dữ liệu Chuyển đổi JSON thời tiết thô sang định dạng phân tích Triển khai xác thực và làm giàu dữ liệu Thiết lập triggers xử lý 4. Phân tích Dữ liệu với Amazon Athena Tạo cấu trúc data lake S3 Thiết lập bảng và schema Athena Viết truy vấn SQL cho phân tích thời tiết Khám phá các mẫu và thông tin chi tiết từ dữ liệu 5. Trực quan hóa Dữ liệu với QuickSight Thiết lập Amazon QuickSight Tạo dashboard thời tiết Xây dựng trực quan hóa tương tác Chia sẻ và xuất bản dashboard 6. Dọn dẹp Tài nguyên và Bước tiếp theo Danh sách kiểm tra dọn dẹp toàn diện Chiến lược tối ưu chi phí Đề xuất cải tiến và mở rộng Tài nguyên học tập bổ sung "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.1-openweathermap-setup/",
	"title": "Thiết lập OpenWeatherMap API",
	"tags": [],
	"description": "",
	"content": "Thiết lập OpenWeatherMap API Trong phần đơn giản hóa này, chúng ta sẽ nhanh chóng thiết lập tài khoản OpenWeatherMap API để thu thập dữ liệu thời tiết cho pipeline của chúng ta.\nBước 1: Đăng ký OpenWeatherMap Tạo tài khoản Truy cập https://openweathermap.org và nhấp vào \u0026ldquo;Sign Up\u0026rdquo; Hoàn thành đăng ký với email của bạn Xác minh email và đăng nhập Bước 2: Lấy API Key Truy cập API Keys Sau khi đăng nhập, đi đến phần \u0026ldquo;API keys\u0026rdquo; Ghi chú API key mặc định hoặc tạo key mới với tên \u0026ldquo;weather-data-collection\u0026rdquo; Gói miễn phí bao gồm 1,000 lệnh gọi API mỗi ngày và 60 lệnh gọi mỗi phút, từng này là đủ cho workshop của tôi.\nBước 3: Kiểm tra API Key Kiểm tra API key của bạn bằng một trong các phương pháp sau:\nPhương pháp trình duyệt:\nhttps://api.openweathermap.org/data/2.5/weather?lat=10.7769\u0026amp;lon=106.7009\u0026amp;appid=YOUR_API_KEY Phương pháp cURL:\ncurl \u0026#34;https://api.openweathermap.org/data/2.5/weather?lat=10.7769\u0026amp;lon=106.7009\u0026amp;appid=YOUR_API_KEY\u0026#34; Bạn sẽ thấy phản hồi JSON với dữ liệu thời tiết hiện tại của Thành phố Hồ Chí Minh.\nCác API Endpoints chính sẽ sử dụng # Thời tiết hiện tại\rhttps://api.openweathermap.org/data/2.5/weather?q={city}\u0026amp;appid={API key}\r# Dự báo 5 ngày (khoảng thời gian 3 giờ)\rhttps://api.openweathermap.org/data/2.5/forecast?q={city}\u0026amp;appid={API key} Các bước tiếp theo Vậy là xong! Bạn đã có API key OpenWeatherMap hoạt động được lưu trữ an toàn trong Parameter Store. Trong phần tiếp theo, chúng ta sẽ tạo một Lambda function để thu thập dữ liệu thời tiết.\nĐã hoàn thành:\nTạo tài khoản OpenWeatherMap Lấy API key Lưu trữ API key trong AWS Parameter Store "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.2-lambda-weather-collector/",
	"title": "Xây dựng Lambda Weather Collector",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo các hàm AWS Lambda để tự động thu thập dữ liệu thời tiết từ OpenWeatherMap API và lưu trữ vào S3. Những hàm này sẽ là lõi của hệ thống thu thập dữ liệu thời tiết.\nTại sao cần IAM Role? IAM Role giống như một \u0026ldquo;thẻ căn cước\u0026rdquo; cho Lambda function, cho phép nó truy cập các dịch vụ AWS khác. Không có IAM Role, Lambda function sẽ:\nKHÔNG THỂ lưu file vào S3\nKHÔNG THỂ đọc API key từ Parameter Store\nKHÔNG THỂ ghi logs vào CloudWatch\nKHÔNG THỂ gửi metrics cho monitoring\nVới IAM Role phù hợp:\nLambda có thể lưu dữ liệu thời tiết vào S3\nLambda có thể đọc API key an toàn\nLambda có thể ghi logs để debug\nLambda có thể gửi metrics để monitoring\nBước 1: Tạo IAM Role cho Lambda 1.1 Tạo Lambda Execution Role Điều hướng đến IAM Console\nAWS Console → IAM → Roles Click \u0026ldquo;Create role\u0026rdquo; Chọn Trusted Entity\nService: Lambda Click \u0026ldquo;Next\u0026rdquo; Cấu hình Role\nRole Name: WeatherCollectorLambdaRole Description: Execution role for weather data collection Lambda functions 1.2 Gắn AWS Managed Policies AWS Managed Policy là gì?\nAWS đã tạo sẵn nhiều policies phổ biến mà chúng ta có thể \u0026ldquo;gắn\u0026rdquo; (attach) vào Role thay vì tự viết từ đầu. Điều này tiết kiệm thời gian và đảm bảo bảo mật.\nCách gắn các policies trong AWS Console:\nKhi tạo Role WeatherCollectorLambdaRole, ở bước \u0026ldquo;Add permissions\u0026rdquo; Tab \u0026ldquo;Permissions\u0026rdquo; → Click \u0026ldquo;Attach policies directly\u0026rdquo; Tìm kiếm và chọn từng policy sau: ✅ Gõ AWSLambdaBasicExecutionRole → tick chọn ✅ Gõ AmazonS3FullAccess → tick chọn ✅ Gõ AmazonSSMReadOnlyAccess → tick chọn ✅ Gõ CloudWatchAgentServerPolicy → tick chọn Click \u0026ldquo;Add Permissions\u0026rdquo; và hoàn thành tạo role Kết quả: Role WeatherCollectorLambdaRole sẽ có 4 managed policies\nPolicy này cho phép Lambda:\nTạo CloudWatch Log Group để ghi logs Ghi logs vào CloudWatch khi function chạy Basic networking để Lambda hoạt động Bước 2: Tạo S3 Bucket cho Dữ liệu Thời tiết 2.1 Tạo Weather Data Bucket Điều hướng đến S3 Console\nAWS Console → S3 → Create bucket Cấu hình Bucket\nBucket Name: weather-data-{your-account-id} (thay thế bằng AWS account ID của bạn) Region: us-east-1 (hoặc region ưa thích của bạn) Block Public Access: Giữ tất cả cài đặt được bật (khuyến nghị) Cấu trúc Bucket weather-data-123456789012/\r├── raw/\r│ ├── current-weather/\r│ │ └── year=2025/month=01/day=03/hour=10/\r│ └── forecast/\r│ └── year=2025/month=01/day=03/\r└── processed/\r├── current-weather/\r└── forecast/ Bước 3: Lambda Function cho Current Weather 3.1 Tạo Current Weather Function Điều hướng đến Lambda Console\nAWS Console → Lambda → Create function Cấu hình Function\nFunction Name: weather-current-collector Runtime: Python 3.11 Architecture: x86_64 Execution Role: Use existing role → WeatherCollectorLambdaRole 3.2 Thêm Function Code Quan trọng: Trước khi copy code, bạn cần thay đổi API key. Ở dòng OPENWEATHER_API_KEY = 'API Key\n→ Thay bằng API key của bạn từ OpenWeatherMap\nTrong Lambda Console → Scroll xuống Code source Xóa toàn bộ code mặc định trong file lambda_function.py Copy và paste code sau: File: lambda_function.py\nimport json import boto3 import urllib.request import urllib.parse import urllib.error import os from datetime import datetime, timezone from typing import Dict, List, Optional import logging # Logging configuration logger = logging.getLogger() logger.setLevel(logging.INFO) # AWS clients with retry configuration s3_client = boto3.client(\u0026#39;s3\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) # Configuration BUCKET_NAME = os.environ.get(\u0026#39;WEATHER_BUCKET_NAME\u0026#39;) OPENWEATHER_API_KEY = \u0026#39;your_api_key\u0026#39; # Replace with your actual API key # Target cities for weather data collection CITIES = [ {\u0026#34;name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;lat\u0026#34;: 10.7769, \u0026#34;lon\u0026#34;: 106.7009}, {\u0026#34;name\u0026#34;: \u0026#34;Hanoi\u0026#34;, \u0026#34;lat\u0026#34;: 21.0285, \u0026#34;lon\u0026#34;: 105.8542}, {\u0026#34;name\u0026#34;: \u0026#34;Danang\u0026#34;, \u0026#34;lat\u0026#34;: 16.0471, \u0026#34;lon\u0026#34;: 108.2068}, {\u0026#34;name\u0026#34;: \u0026#34;GiaLai\u0026#34;, \u0026#34;lat\u0026#34;: 13.9833, \u0026#34;lon\u0026#34;: 108.0000}, {\u0026#34;name\u0026#34;: \u0026#34;CanTho\u0026#34;, \u0026#34;lat\u0026#34;: 10.0452, \u0026#34;lon\u0026#34;: 105.7469}, {\u0026#34;name\u0026#34;: \u0026#34;Hue\u0026#34;, \u0026#34;lat\u0026#34;: 16.4637, \u0026#34;lon\u0026#34;: 107.5909} ] def fetch_current_weather(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Fetch current weather data for a city.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/weather\u0026#34; params = { \u0026#39;lat\u0026#39;: str(city[\u0026#39;lat\u0026#39;]), \u0026#39;lon\u0026#39;: str(city[\u0026#39;lon\u0026#39;]), \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39;, \u0026#39;lang\u0026#39;: \u0026#39;en\u0026#39; } try: # Build URL with parameters query_string = urllib.parse.urlencode(params) full_url = f\u0026#34;{base_url}?{query_string}\u0026#34; # Make HTTP request with urllib.request.urlopen(full_url, timeout=30) as response: if response.status != 200: logger.error(f\u0026#34;HTTP error {response.status} for {city[\u0026#39;name\u0026#39;]}\u0026#34;) return None response_data = response.read().decode(\u0026#39;utf-8\u0026#39;) data = json.loads(response_data) # Add metadata data[\u0026#39;collection_timestamp\u0026#39;] = datetime.now(timezone.utc).isoformat() data[\u0026#39;city_metadata\u0026#39;] = city return data except urllib.error.URLError as e: logger.error(f\u0026#34;URL error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except urllib.error.HTTPError as e: logger.error(f\u0026#34;HTTP error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except json.JSONDecodeError as e: logger.error(f\u0026#34;JSON decode error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except Exception as e: logger.error(f\u0026#34;Unexpected error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None def save_to_s3(data: Dict, city_name: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Save weather data to S3.\u0026#34;\u0026#34;\u0026#34; try: if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable not set\u0026#34;) return False now = datetime.now(timezone.utc) # Create S3 key with time partitioning (Hive format for analytics) city_safe = city_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;) key = f\u0026#34;raw/current-weather/year={now.year}/month={now.month:02d}/day={now.day:02d}/hour={now.hour:02d}/{city_safe}_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; # Prepare body data with UTF-8 encoding json_data = json.dumps(data, ensure_ascii=False, indent=2) body_bytes = json_data.encode(\u0026#39;utf-8\u0026#39;) # Upload file with optimized S3 parameters s3_client.put_object( Bucket=BUCKET_NAME, Key=key, Body=body_bytes, ContentType=\u0026#39;application/json; charset=utf-8\u0026#39;, ContentEncoding=\u0026#39;utf-8\u0026#39;, Metadata={ \u0026#39;city\u0026#39;: city_name, \u0026#39;collection-time\u0026#39;: now.isoformat(), \u0026#39;data-type\u0026#39;: \u0026#39;current-weather\u0026#39;, \u0026#39;source\u0026#39;: \u0026#39;openweathermap\u0026#39; }, ServerSideEncryption=\u0026#39;AES256\u0026#39;, # Server-side encryption StorageClass=\u0026#39;STANDARD_IA\u0026#39; # Save 40% storage cost compared to STANDARD ) logger.info(f\u0026#34;Saved data for {city_name} at s3://{BUCKET_NAME}/{key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;S3 save error for {city_name}: {e}\u0026#34;) return False def send_metrics(metric_name: str, value: float, unit: str = \u0026#39;Count\u0026#39;): \u0026#34;\u0026#34;\u0026#34;Send custom metrics to CloudWatch.\u0026#34;\u0026#34;\u0026#34; try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: value, \u0026#39;Unit\u0026#39;: unit, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Metric send error {metric_name}: {e}\u0026#34;) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Main handler for Lambda function.\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Starting weather data collection: {json.dumps(event)}\u0026#34;) # Basic validation if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable is required\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;WEATHER_BUCKET_NAME environment variable not set\u0026#39; }) } successful_collections = 0 failed_collections = 0 results = [] try: # API key validation if not OPENWEATHER_API_KEY or OPENWEATHER_API_KEY == \u0026#39;your_api_key_here\u0026#39;: logger.error(\u0026#34;OpenWeatherMap API key is not configured\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;OpenWeatherMap API key not set\u0026#39; }) } # Collect data for each city for city in CITIES: logger.info(f\u0026#34;Collecting data for {city[\u0026#39;name\u0026#39;]}\u0026#34;) # Fetch weather data weather_data = fetch_current_weather(city, OPENWEATHER_API_KEY) if weather_data: # Save to S3 if save_to_s3(weather_data, city[\u0026#39;name\u0026#39;]): successful_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;temperature\u0026#39;: weather_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;temp\u0026#39;), \u0026#39;description\u0026#39;: weather_data.get(\u0026#39;weather\u0026#39;, [{}])[0].get(\u0026#39;description\u0026#39;) }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;S3 save failed\u0026#39; }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;API fetch failed\u0026#39; }) # Send metrics (batched to save cost) if successful_collections \u0026gt; 0 or failed_collections \u0026gt; 0: try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;SuccessfulCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;FailedCollections\u0026#39;, \u0026#39;Value\u0026#39;: failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;TotalCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections + failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Metrics send error: {e}\u0026#34;) # Log results logger.info(f\u0026#34;Collection completed - Success: {successful_collections}, Failed: {failed_collections}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Weather data collection completed\u0026#39;, \u0026#39;successful_collections\u0026#39;: successful_collections, \u0026#39;failed_collections\u0026#39;: failed_collections, \u0026#39;results\u0026#39;: results }) } except Exception as e: logger.error(f\u0026#34;Lambda handler error: {e}\u0026#34;) send_metrics(\u0026#39;LambdaErrors\u0026#39;, 1) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal error\u0026#39;, \u0026#39;message\u0026#39;: str(e) }) } Giải thích code\nImport libraries: Các thư viện cần thiết cho HTTP requests, AWS services, logging Cấu hình API key: Lưu OpenWeatherMap API key (nhớ thay bằng key của bạn!) Danh sách thành phố: 6 thành phố Việt Nam với tọa độ GPS chính xác fetch_current_weather(): Gọi API để lấy thời tiết hiện tại save_to_s3(): Lưu dữ liệu JSON vào S3 với cấu trúc partition thông minh send_metrics(): Gửi metrics tới CloudWatch để monitoring lambda_handler(): Hàm chính - xử lý từng thành phố và trả về kết quả Luồng hoạt động: Lambda được trigger → Kiểm tra cấu hình → Lặp qua 6 thành phố → Gọi API → Lưu vào S3 → Gửi metrics → Trả về kết quả\n3.3 Cấu hình Environment Variables Bước quan trọng: Lambda cần biết tên S3 bucket để lưu dữ liệu.\nTrong Lambda Console → Configuration tab → Environment variables Click \u0026ldquo;Edit\u0026rdquo; → Add environment variable: Key: WEATHER_BUCKET_NAME Value: weather-data-{your-account-id} (thay {your-account-id} bằng account ID thật) Account ID có thể tìm ở góc phải trên AWS Console (dãy số 12 chữ số)\n3.4 Test Lambda Function Bây giờ hãy test xem function hoạt động không!\nClick \u0026ldquo;Deploy\u0026rdquo; để lưu code và cấu hình Tạo test event: Test tab → Create new event Event name: manual-test Event JSON: {} (để trống vì không cần input) Click \u0026ldquo;Test\u0026rdquo; và đợi kết quả Kết quả mong đợi:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Weather data collection completed\u0026#34;, \u0026#34;successful_collections\u0026#34;: 6, \u0026#34;failed_collections\u0026#34;: 0, \u0026#34;results\u0026#34;: [ { \u0026#34;city\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;temperature\u0026#34;: 28.5, \u0026#34;description\u0026#34;: \u0026#34;broken clouds\u0026#34; } // ... 5 thành phố khác ] } } 4. Kiểm tra S3: Vào S3 bucket và xem có file JSON mới không\nNếu test thành công, bạn đã có:\nLambda function hoạt động Dữ liệu thời tiết được lưu vào S3 CloudWatch metrics được gửi Error handling hoạt động Lambda đã sẵn sàng để tự động chạy theo schedule\nNếu test thất bại, kiểm tra:\nCloudWatch Logs: Lambda → Monitoring → View logs → Xem lỗi cụ thể API Key: Đảm bảo key OpenWeatherMap đúng Environment variable: WEATHER_BUCKET_NAME đúng format IAM Role: Đảm bảo role có đủ permissions S3 Bucket: Bucket đã được tạo chưa Bước 4: Lambda Function cho Weather Forecast Tương tự như tạo Function cho Weather Current\n4.1 Tạo Forecast Function Tạo function mới Function Name: weather-forecast-collector Runtime: Python 3.11 Execution Role: WeatherCollectorLambdaRole 4.2 Forecast Function Code import json import boto3 import urllib.request import urllib.parse import urllib.error import os from datetime import datetime, timezone from typing import Dict, List, Optional import logging # Logging configuration logger = logging.getLogger() logger.setLevel(logging.INFO) # AWS clients with retry configuration s3_client = boto3.client(\u0026#39;s3\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) # Configuration BUCKET_NAME = os.environ.get(\u0026#39;WEATHER_BUCKET_NAME\u0026#39;) OPENWEATHER_API_KEY = \u0026#39;your_api_key_here\u0026#39; # Replace with your actual API key # Target cities for weather forecast collection CITIES = [ {\u0026#34;name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;lat\u0026#34;: 10.7769, \u0026#34;lon\u0026#34;: 106.7009}, {\u0026#34;name\u0026#34;: \u0026#34;Hanoi\u0026#34;, \u0026#34;lat\u0026#34;: 21.0285, \u0026#34;lon\u0026#34;: 105.8542}, {\u0026#34;name\u0026#34;: \u0026#34;Danang\u0026#34;, \u0026#34;lat\u0026#34;: 16.0471, \u0026#34;lon\u0026#34;: 108.2068}, {\u0026#34;name\u0026#34;: \u0026#34;GiaLai\u0026#34;, \u0026#34;lat\u0026#34;: 13.9833, \u0026#34;lon\u0026#34;: 108.0000}, {\u0026#34;name\u0026#34;: \u0026#34;CanTho\u0026#34;, \u0026#34;lat\u0026#34;: 10.0452, \u0026#34;lon\u0026#34;: 105.7469}, {\u0026#34;name\u0026#34;: \u0026#34;Hue\u0026#34;, \u0026#34;lat\u0026#34;: 16.4637, \u0026#34;lon\u0026#34;: 107.5909} ] def fetch_weather_forecast(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Fetch 5-day weather forecast data for a city.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/forecast\u0026#34; params = { \u0026#39;lat\u0026#39;: str(city[\u0026#39;lat\u0026#39;]), \u0026#39;lon\u0026#39;: str(city[\u0026#39;lon\u0026#39;]), \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39;, \u0026#39;lang\u0026#39;: \u0026#39;en\u0026#39;, \u0026#39;cnt\u0026#39;: 40 # 5 days x 8 forecasts (every 3 hours) } try: # Build URL with parameters query_string = urllib.parse.urlencode(params) full_url = f\u0026#34;{base_url}?{query_string}\u0026#34; # Make HTTP request with urllib.request.urlopen(full_url, timeout=30) as response: if response.status != 200: logger.error(f\u0026#34;HTTP error {response.status} for forecast {city[\u0026#39;name\u0026#39;]}\u0026#34;) return None response_data = response.read().decode(\u0026#39;utf-8\u0026#39;) data = json.loads(response_data) # Add metadata data[\u0026#39;collection_timestamp\u0026#39;] = datetime.now(timezone.utc).isoformat() data[\u0026#39;city_metadata\u0026#39;] = city return data except urllib.error.URLError as e: logger.error(f\u0026#34;URL error for forecast {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except urllib.error.HTTPError as e: logger.error(f\u0026#34;HTTP error for forecast {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except json.JSONDecodeError as e: logger.error(f\u0026#34;JSON decode error for forecast {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except Exception as e: logger.error(f\u0026#34;Unexpected error for forecast {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None def save_forecast_to_s3(data: Dict, city_name: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Save weather forecast data to S3.\u0026#34;\u0026#34;\u0026#34; try: if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable not set\u0026#34;) return False now = datetime.now(timezone.utc) # Create S3 key with time partitioning (Hive format for analytics) city_safe = city_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;) key = f\u0026#34;raw/forecast/year={now.year}/month={now.month:02d}/day={now.day:02d}/hour={now.hour:02d}/{city_safe}_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; # Prepare body data with UTF-8 encoding json_data = json.dumps(data, ensure_ascii=False, indent=2) body_bytes = json_data.encode(\u0026#39;utf-8\u0026#39;) # Upload file with optimized S3 parameters s3_client.put_object( Bucket=BUCKET_NAME, Key=key, Body=body_bytes, ContentType=\u0026#39;application/json; charset=utf-8\u0026#39;, ContentEncoding=\u0026#39;utf-8\u0026#39;, Metadata={ \u0026#39;city\u0026#39;: city_name, \u0026#39;collection-time\u0026#39;: now.isoformat(), \u0026#39;data-type\u0026#39;: \u0026#39;forecast\u0026#39;, \u0026#39;forecast-count\u0026#39;: str(len(data.get(\u0026#39;list\u0026#39;, []))), \u0026#39;source\u0026#39;: \u0026#39;openweathermap\u0026#39; }, ServerSideEncryption=\u0026#39;AES256\u0026#39;, # Server-side encryption StorageClass=\u0026#39;STANDARD_IA\u0026#39; # Save 40% storage cost compared to STANDARD ) logger.info(f\u0026#34;Saved forecast data for {city_name} at s3://{BUCKET_NAME}/{key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;S3 save error for forecast {city_name}: {e}\u0026#34;) return False def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Main handler for forecast Lambda function.\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Starting weather forecast collection: {json.dumps(event)}\u0026#34;) # Basic validation if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable is required\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;WEATHER_BUCKET_NAME environment variable not set\u0026#39; }) } successful_collections = 0 failed_collections = 0 results = [] try: # API key validation if not OPENWEATHER_API_KEY or OPENWEATHER_API_KEY == \u0026#39;your_api_key_here\u0026#39;: logger.error(\u0026#34;OpenWeatherMap API key is not configured\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;OpenWeatherMap API key not set\u0026#39; }) } # Collect forecast data for each city for city in CITIES: logger.info(f\u0026#34;Collecting forecast data for {city[\u0026#39;name\u0026#39;]}\u0026#34;) forecast_data = fetch_weather_forecast(city, OPENWEATHER_API_KEY) if forecast_data: # Save to S3 if save_forecast_to_s3(forecast_data, city[\u0026#39;name\u0026#39;]): successful_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;forecast_points\u0026#39;: len(forecast_data.get(\u0026#39;list\u0026#39;, [])) }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;S3 save failed\u0026#39; }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;API fetch failed\u0026#39; }) # Send metrics (batched to save cost) if successful_collections \u0026gt; 0 or failed_collections \u0026gt; 0: try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;SuccessfulForecastCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;FailedForecastCollections\u0026#39;, \u0026#39;Value\u0026#39;: failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;TotalForecastCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections + failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Metrics send error: {e}\u0026#34;) # Log results logger.info(f\u0026#34;Forecast collection completed - Success: {successful_collections}, Failed: {failed_collections}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Weather forecast collection completed\u0026#39;, \u0026#39;successful_collections\u0026#39;: successful_collections, \u0026#39;failed_collections\u0026#39;: failed_collections, \u0026#39;results\u0026#39;: results }) } except Exception as e: logger.error(f\u0026#34;Lambda handler error: {e}\u0026#34;) # Send error metric try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;ForecastLambdaErrors\u0026#39;, \u0026#39;Value\u0026#39;: 1, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as metric_error: logger.error(f\u0026#34;Failed to send error metric: {metric_error}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal error\u0026#39;, \u0026#39;message\u0026#39;: str(e) }) } 4.3 Test Lambda Function Bây giờ hãy test xem function hoạt động không!\nClick \u0026ldquo;Deploy\u0026rdquo; để lưu code và cấu hình Tạo test event: Test tab → Create new event Event name: manual-test Event JSON: {} (để trống vì không cần input) Click \u0026ldquo;Test\u0026rdquo; và đợi kết quả Kết quả mong đợi:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Weather data collection completed\u0026#34;, \u0026#34;successful_collections\u0026#34;: 6, \u0026#34;failed_collections\u0026#34;: 0, \u0026#34;results\u0026#34;: [ { \u0026#34;city\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;temperature\u0026#34;: 28.5, \u0026#34;description\u0026#34;: \u0026#34;broken clouds\u0026#34; } // ... 5 thành phố khác ] } } 4. Kiểm tra S3: Vào S3 bucket và xem có file JSON mới không\nTóm tắt Trong phần này, chúng ta đã:\nTạo IAM roles và policies cho Lambda functions Thiết lập S3 bucket với cấu trúc partition Xây dựng Lambda function thu thập thời tiết hiện tại Xây dựng Lambda function thu thập dự báo thời tiết Cấu hình error handling và CloudWatch metrics Test các functions thành công Tiếp theo: Trong module 2.3, chúng ta sẽ thiết lập automated scheduling với CloudWatch Events để chạy các functions này theo lịch trình.\n"
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.3-automated-scheduling/",
	"title": "Lập lịch Tự động với EventBridge",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ thiết lập lập lịch tự động cho việc thu thập dữ liệu thời tiết bằng Amazon EventBridge (trước đây gọi là CloudWatch Events). Điều này giúp các Lambda functions chạy theo lịch trình đều đặn mà không cần can thiệp thủ công.\nEventBridge giống như \u0026ldquo;đồng hồ báo thức thông minh\u0026rdquo; của AWS:\nChạy đúng giờ: Trigger Lambda functions theo lịch trình cụ thể Chính xác: Chạy đúng thời gian đã định (ví dụ: mỗi giờ, mỗi ngày) Tự động: Không cần can thiệp thủ công Tiết kiệm: Chỉ chạy khi cần, không tốn tài nguyên khi không hoạt động Tại sao cần Scheduling?\nThu thập dữ liệu đều đặn 24/7 Dữ liệu luôn fresh và cập nhật Tự động hóa hoàn toàn Không phụ thuộc vào người vận hành Lịch trình đề xuất:\nCurrent Weather: Mỗi giờ (24 lần/ngày) - Để theo dõi thời tiết real-time Forecast: Mỗi 6 giờ (4 lần/ngày) - Dự báo không thay đổi nhiều Bước 1: Thiết lập EventBridge Rule cho Current Weather Bước này sẽ tạo lịch trình chạy Lambda mỗi giờ để thu thập thời tiết hiện tại.\nVí dụ: Function sẽ chạy lúc 00:00, 01:00, 02:00\u0026hellip; 23:00 hàng ngày\n1.1 Truy cập EventBridge Console Vào AWS Console → Tìm \u0026ldquo;EventBridge\u0026rdquo; (hoặc \u0026ldquo;CloudWatch\u0026rdquo; → \u0026ldquo;Events\u0026rdquo;) Click \u0026ldquo;EventBridge\u0026rdquo; → \u0026ldquo;Rules\u0026rdquo; ở menu bên trái Chọn Region phù hợp (ví dụ: us-east-1) 1.2 Tạo Rule cho Current Weather Click \u0026ldquo;Create rule\u0026rdquo; Bước 1 - Define rule detail: Name: weather-current-hourly Description: Thu thập dữ liệu thời tiết hiện tại mỗi giờ cho 6 thành phố Việt Nam Event bus: default Rule type: Schedule Click \u0026ldquo;Continue to create rule\u0026rdquo; 1.3 Cấu hình Schedule Pattern Schedule pattern: Chọn \u0026ldquo;A schedule that runs at a regular rate, such as every 10 minutes\u0026rdquo;\nRate expression: Chọn \u0026ldquo;rate\u0026rdquo; và nhập:\n1 hour Các lựa chọn Schedule Pattern:\nRate expression:\nrate(1 hour) = mỗi giờ rate(30 minutes) = mỗi 30 phút rate(1 day) = mỗi ngày Cron expression (nâng cao):\ncron(0 * * * ? *) = mỗi giờ đúng phút 0 cron(0 8,12,16,20 * * ? *) = 4 lần/ngày (8h, 12h, 16h, 20h) cron(0 0 * * ? *) = mỗi ngày lúc 00:00 Click \u0026ldquo;Next\u0026rdquo; 1.4 Select Target (Lambda Function) Target types: Chọn \u0026ldquo;AWS service\u0026rdquo;\nSelect a service: Chọn \u0026ldquo;Lambda function\u0026rdquo;\nFunction: Chọn weather-current-collector (function đã tạo ở bước trước)\nAdditional settings: Configure target input: Chọn \u0026ldquo;Constant (JSON text)\u0026rdquo; JSON text: { \u0026#34;source\u0026#34;: \u0026#34;eventbridge-schedule\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Scheduled Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;collection_type\u0026#34;: \u0026#34;current_weather\u0026#34;, \u0026#34;scheduled_time\u0026#34;: \u0026#34;hourly\u0026#34;, \u0026#34;trigger_source\u0026#34;: \u0026#34;eventbridge\u0026#34; } } JSON input này sẽ:\nCho Lambda biết đây là scheduled event (không phải manual test) Giúp phân biệt current weather vs forecast collection Cung cấp metadata để logging và monitoring Click \u0026ldquo;Next\u0026rdquo; 1.5 Configure tags và Review Tags (Optional):\nKey: Project → Value: WeatherETL Key: Environment → Value: Production Review tất cả cài đặt:\n✅ Name: weather-current-hourly ✅ Schedule: rate(1 hour) ✅ Target: weather-current-collector ✅ State: Enabled Click \u0026ldquo;Create rule\u0026rdquo;\nRule cho current weather đã được tạo thành công.\nRule sẽ trigger Lambda function weather-current-collector mỗi giờ để thu thập dữ liệu thời tiết hiện tại.\nBước 2: Thiết lập EventBridge Rule cho Weather Forecast Bước này sẽ tạo lịch trình chạy Lambda mỗi 6 giờ để thu thập dự báo thời tiết.\nVí dụ: Function sẽ chạy lúc 00:00, 06:00, 12:00, 18:00 hàng ngày\n2.1 Tạo Rule thứ hai Trong EventBridge Console → \u0026ldquo;Create rule\u0026rdquo;\nBước 1 - Define rule detail:\nName: weather-forecast-6hourly Description: Thu thập dữ liệu dự báo thời tiết mỗi 6 giờ cho 6 thành phố Việt Nam Event bus: default Rule type: Schedule 2.2 Cấu hình Schedule cho Forecast Schedule pattern: Chọn \u0026ldquo;A fine-grained schedule that runs at a specific time\u0026rdquo;\nCron expression:\ncron(0 0,6,12,18 * * ? *) 2.3 Select Target cho Forecast Target types: \u0026ldquo;AWS service\u0026rdquo;\nSelect a service: \u0026ldquo;Lambda function\u0026rdquo;\nFunction: weather-forecast-collector\nConfigure target input: \u0026ldquo;Constant (JSON text)\u0026rdquo;\n{ \u0026#34;source\u0026#34;: \u0026#34;eventbridge-schedule\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Scheduled Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;collection_type\u0026#34;: \u0026#34;forecast\u0026#34;, \u0026#34;scheduled_time\u0026#34;: \u0026#34;every_6_hours\u0026#34;, \u0026#34;trigger_source\u0026#34;: \u0026#34;eventbridge\u0026#34; } } Create rule Bước 3: Thiết lập Monitoring với CloudWatch Alarms Tại sao cần Monitoring?\nKhi Lambda functions chạy tự động 24/7, bạn cần biết ngay khi có vấn đề:\nLambda function bị lỗi Function chạy quá lâu Tỷ lệ thành công thấp Chi phí tăng bất thường 3.1 Tạo SNS Topic cho Email Alerts Trước tiên, tạo SNS Topic để nhận email thông báo khi có lỗi:\nAWS Console → \u0026ldquo;SNS\u0026rdquo; → \u0026ldquo;Topics\u0026rdquo; → \u0026ldquo;Create topic\u0026rdquo; Topic configuration:\nType: Standard Name: weather-etl-alerts Display name: Weather ETL Alerts Create topic\nTạo Subscription:\nProtocol: Email Endpoint: your-email@example.com (thay bằng email của bạn) Confirm subscription qua email 3.2 Tạo CloudWatch Alarm cho Lambda Errors AWS Console → \u0026ldquo;CloudWatch\u0026rdquo; → \u0026ldquo;Alarms\u0026rdquo; → \u0026ldquo;Create alarm\u0026rdquo;\nSelect metric:\nNamespace: AWS/Lambda Metric name: Errors Dimensions: FunctionName: weather-current-collector Specify metric and conditions:\nStatistic: Sum Period: 5 minutes Threshold type: Static Condition: Greater/Equal Threshold value: 1 (alert khi có ≥1 error trong 5 phút) Configure actions:\nAlarm state trigger: In alarm SNS topic: weather-etl-alerts Add name and description:\nAlarm name: WeatherCurrentCollector-Errors Description: Alert khi Lambda weather-current-collector có lỗi Create alarm Quan trọng: Hãy đảm bảo tất cả hoạt động đúng trước khi để nó tự động chạy\nTối ưu hóa Chi phí và Hiệu suất 1. Smart Scheduling Strategy Thay vì chạy cùng frequency 24/7, có thể tối ưu:\nGiờ cao điểm (6:00-23:00): Mỗi giờ Giờ thấp điểm (23:00-6:00): Mỗi 2 giờ Cuối tuần: Mỗi 2 giờ (ít người quan tâm thời tiết công việc) Tạo multiple rules với different schedules:\nRule 1 - Peak Hours:\ncron(0 6-23 * * ? *) Rule 2 - Off-peak Hours:\ncron(0 0,2,4 * * ? *) 2. Regional Optimization Nếu cần collect data cho multiple regions:\n{ \u0026#34;source\u0026#34;: \u0026#34;eventbridge-schedule\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;region\u0026#34;: \u0026#34;southeast-asia\u0026#34;, \u0026#34;cities\u0026#34;: [\u0026#34;HoChiMinh\u0026#34;, \u0026#34;Hanoi\u0026#34;, \u0026#34;Bangkok\u0026#34;], \u0026#34;priority\u0026#34;: \u0026#34;high\u0026#34; } } 3. Error Recovery Strategy Thêm Dead Letter Queue cho Lambda:\nLambda function configuration → \u0026ldquo;Asynchronous invocation\u0026rdquo; Dead letter queue: Enable với SQS queue Maximum age of event: 6 hours Retry attempts: 2 Tóm tắt Trong phần này, chúng ta đã hoàn thành:\nThiết lập EventBridge Rules:\nCurrent weather: Mỗi giờ (24 lần/ngày) Forecast: Mỗi 6 giờ (4 lần/ngày) Testing và Verification:\nManual testing các rules Verify S3 data collection Check CloudWatch logs và metrics Kết quả: Hệ thống thu thập dữ liệu thời tiết tự động 24/7 với monitoring đầy đủ!\nTiếp theo: Trong module 2.4, chúng ta sẽ thiết lập testing và validation toàn diện để đảm bảo data quality và system reliability.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduction/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Mục tiêu Xây dựng hệ thống thu thập dữ liệu serverless sử dụng AWS Lambda Triển khai quy trình chuyển đổi và xử lý dữ liệu Lưu trữ và truy vấn dữ liệu sử dụng Amazon S3 và Athena Tạo trực quan hóa với Amazon QuickSight Áp dụng các best practices của AWS cho tối ưu chi phí và dọn dẹp tài nguyên Tổng quan Kiến trúc Pipeline ETL thời tiết của chúng ta tuân theo kiến trúc serverless đơn giản này: Các thành phần chính:\nNguồn dữ liệu: OpenWeatherMap API cho dữ liệu thời tiết thời gian thực Thu thập: AWS Lambda function để lấy dữ liệu thời tiết Lưu trữ: Amazon S3 cho cả dữ liệu thô và đã xử lý Xử lý: AWS Lambda cho chuyển đổi dữ liệu Phân tích: Amazon Athena cho truy vấn SQL Trực quan hóa: Amazon QuickSight cho dashboard Yêu cầu Tiên quyết Trước khi bắt đầu workshop này, hãy đảm bảo bạn có:\nTài khoản AWS với quyền truy cập quản trị Hiểu biết cơ bản về AWS console Hiểu biết về các khái niệm lập trình cơ bản Tài khoản OpenWeatherMap (tier miễn phí là đủ, ở bài workshop này em sử dụng Developer plan) "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/",
	"title": "Thu thập Dữ liệu Thời tiết với OpenWeatherMap",
	"tags": [],
	"description": "",
	"content": "Trong phần này, ta sẽ học cách thiết lập thu thập dữ liệu thời tiết tự động bằng OpenWeatherMap API và AWS Lambda. Đây là nền tảng của pipeline ETL phân tích thời tiết, nơi chúng ta sẽ xây dựng hệ thống thu thập dữ liệu serverless đáng tin cậy.\n2.1 OpenWeatherMap Setup Thiết lập API và Credentials\nThiết lập tài khoản OpenWeatherMap, lấy API key, và cấu hình Systems Manager Parameter Store để lưu trữ credentials một cách bảo mật. Bạn sẽ học cách quản lý API keys và test connectivity.\n2.2 Lambda Weather Collector Xây dựng Functions Thu thập Dữ liệu\nTạo các Lambda functions để thu thập dữ liệu thời tiết hiện tại và dự báo từ OpenWeatherMap API. Bao gồm IAM roles, S3 bucket setup, và function code với error handling.\n2.3 Automated Scheduling Lập lịch Tự động với CloudWatch Events\nThiết lập CloudWatch Events để chạy các Lambda functions theo lịch trình tự động. Cấu hình monitoring, alarms, và notifications để đảm bảo hệ thống chạy ổn định.\n2.4 Testing và Monitoring Testing và Monitoring Toàn diện\nThiết lập testing strategy bao gồm manual testing, data quality validation, performance testing, và automated health checks. Tạo dashboard để monitor hệ thống.\nKiến trúc Tổng quan graph LR A[OpenWeatherMap API] --\u0026gt; B[Lambda Weather Collector] C[CloudWatch Events] --\u0026gt; B B --\u0026gt; D[S3 Raw Data Storage] B --\u0026gt; E[CloudWatch Logs] style A fill:#e1f5fe style B fill:#ff9900,stroke:#232f3e,stroke-width:3px style C fill:#e8f5e8 style D fill:#f3e5f5 style E fill:#fff3e0 Loại Dữ liệu Thu thập Thu thập dữ liệu thời tiết sẽ tập trung vào:\nThời tiết Hiện tại: Điều kiện thời gian thực cho 6 tỉnh thành ở Việt Nam là: Hà Nội, Hồ Chí Minh, Đà Nẵng, Gia Lai, Cần Thơ, Huế Dự báo 5 Ngày: Dự đoán thời tiết mỗi 3 giờ Metadata: Timestamp, location, collection info Lịch trình Thu thập Thời tiết Hiện tại: Mỗi giờ (24 lần/ngày)\nDự báo Thời tiết: Mỗi 6 giờ (4 lần/ngày)\nƯớc tính Chi phí Dịch vụ Sử dụng Chi phí OpenWeatherMap API 1,000 calls/ngày Free Lambda Executions 4,000 invocations Free Tier S3 Storage 1 GB dữ liệu thời tiết Free Tier CloudWatch Logs 5 GB logs $2.50 Tổng ~$2.50/tháng OpenWeatherMap cung cấp 1,000 lời gọi API miễn phí mỗi ngày, đủ cho workshop này.\nKết quả Mong đợi Sau khi hoàn thành module này, bạn sẽ có:\nHệ thống thu thập dữ liệu thời tiết serverless hoạt động 24/7 Dữ liệu thời tiết được lưu trữ có cấu trúc trong S3 Monitoring và alerting system đầy đủ Kiến thức về AWS Lambda, CloudWatch Events, và S3 integration Bắt đầu Sẵn sàng xây dựng hệ thống thu thập dữ liệu thời tiết? Bắt đầu với 2.1 OpenWeatherMap Setup để thiết lập API và credentials.\n"
},
{
	"uri": "//localhost:1313/vi/3-serverless-processing-lambda/",
	"title": "Xử lý và Chuyển đổi Dữ liệu Serverless",
	"tags": [],
	"description": "",
	"content": "Trong module này, chúng ta sẽ xây dựng Lambda functions để xử lý và chuyển đổi dữ liệu thời tiết thô từ module 2 thành định dạng phù hợp cho phân tích. Đây là bước \u0026ldquo;Transform\u0026rdquo; trong pipeline ETL, giúp làm sạch, chuẩn hóa và tạo ra các metrics có ý nghĩa từ dữ liệu thô.\nDữ liệu thô từ OpenWeatherMap API có nhiều vấn đề:\nCấu trúc phức tạp: Nested JSON khó query Đơn vị không thống nhất: Kelvin, m/s, Pascal\u0026hellip; Dữ liệu dư thừa: Nhiều fields không cần thiết Thiếu insights: Không có derived metrics Vì vậy cần phải processing để có:\nCấu trúc phẳng: Dễ query với SQL Đơn vị thống nhất: Celsius, km/h, %\u0026hellip; Dữ liệu sạch: Chỉ giữ thông tin cần thiết Rich insights: Heat index, comfort level, weather severity\u0026hellip; Luồng xử lý:\nRaw data từ Module 2 được lưu vào S3 S3 Event trigger Lambda processor Lambda transform data và lưu vào processed bucket Processed data sẵn sàng cho analytics (Module 4) Bước 1: Tạo S3 Bucket cho Processed Data Tại sao cần chia bucket?\nTách biệt concerns: Raw vs Processed data Security: Khác nhau về access permissions Cost optimization: Khác nhau về storage class Analytics: Processed data tối ưu cho query 1.1 Tạo Processed Data Bucket AWS Console → S3 → Create bucket\nBucket configuration:\nBucket name: weather-processed-{your-account-id} Region: ap-southeast-1 (same as raw bucket) Block all public access: Enabled Bucket versioning: Enabled Default encryption: SSE-S3 Create bucket 1.2 Tạo Folder Structure Tạo folder structure tối ưu cho analytics:\nweather-processed-{account-id}/ ├── current-weather/ │ ├── year=2025/ │ │ ├── month=01/ │ │ │ ├── day=03/ │ │ │ │ ├── hour=00/ │ │ │ │ │ ├── hcm_20250103_000000.json │ │ │ │ │ ├── hanoi_20250103_000000.json │ │ │ │ │ └── ... │ │ │ │ └── hour=01/ │ │ │ └── day=04/ │ │ └── month=02/ │ └── year=2026/ └── forecast/ ├── year=2025/ │ ├── month=01/ │ │ ├── day=03/ │ │ │ ├── hour=00/ │ │ │ │ ├── hcm_forecast_20250103_000000.json │ │ │ │ └── ... │ │ │ └── hour=06/ │ │ └── day=04/ │ └── month=02/ └── year=2026/ Tại sao dùng Hive-style partitioning?\n📊 Athena optimization: Query performance tốt hơn 💰 Cost savings: Chỉ scan data cần thiết 🔍 Easy filtering: Filter theo year/month/day/hour 📈 Scalability: Handle large datasets efficiently Bước 2: Tạo Lambda Function cho Data Processing 2.1 Tạo IAM Role cho Lambda AWS Console → IAM → Roles → Create role\nTrusted entity: AWS service → Lambda\nPermissions: Create policy với JSON:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:logs:*:*:*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:GetObject\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::weather-data-*/*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:PutObjectAcl\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::weather-processed-*/*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;cloudwatch:PutMetricData\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Role name: WeatherDataProcessorRole 2.2 Tạo Lambda Function AWS Console → Lambda → Create function\nFunction configuration:\nFunction name: weather-data-processor Runtime: Python 3.11 Architecture: x86_64 Execution role: WeatherDataProcessorRole Advanced settings: Memory: 512 MB Timeout: 5 minutes Environment variables: PROCESSED_BUCKET_NAME: weather-processed-{your-account-id} LOG_LEVEL: INFO 2.3 Lambda Function Code Thay thế code mặc định bằng code sau:\nimport json import boto3 import os import logging from datetime import datetime, timezone from typing import Dict, List, Optional, Any from decimal import Decimal import urllib.parse # Logging configuration logger = logging.getLogger() logger.setLevel(os.environ.get(\u0026#39;LOG_LEVEL\u0026#39;, \u0026#39;INFO\u0026#39;)) # AWS clients s3_client = boto3.client(\u0026#39;s3\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) # Configuration PROCESSED_BUCKET_NAME = os.environ.get(\u0026#39;PROCESSED_BUCKET_NAME\u0026#39;) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; Main Lambda handler for weather data processing \u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Processing event: {json.dumps(event)}\u0026#34;) processed_count = 0 failed_count = 0 try: # Handle S3 event trigger if \u0026#39;Records\u0026#39; in event: for record in event[\u0026#39;Records\u0026#39;]: try: # Extract S3 information bucket = record[\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;] key = urllib.parse.unquote_plus(record[\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;]) logger.info(f\u0026#34;Processing file: s3://{bucket}/{key}\u0026#34;) # Process the file success = process_weather_file(bucket, key) if success: processed_count += 1 else: failed_count += 1 except Exception as e: logger.error(f\u0026#34;Error processing record: {e}\u0026#34;) failed_count += 1 # Handle manual invocation else: logger.info(\u0026#34;Manual invocation - processing recent files\u0026#34;) # This could be extended to process recent files processed_count = 1 # Send metrics to CloudWatch send_processing_metrics(processed_count, failed_count) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Weather data processing completed\u0026#39;, \u0026#39;processed_count\u0026#39;: processed_count, \u0026#39;failed_count\u0026#39;: failed_count }) } except Exception as e: logger.error(f\u0026#34;Lambda handler error: {e}\u0026#34;) # Send error metric send_processing_metrics(0, 1) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal processing error\u0026#39;, \u0026#39;message\u0026#39;: str(e) }) } def process_weather_file(source_bucket: str, source_key: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; Process a single weather data file \u0026#34;\u0026#34;\u0026#34; try: # Download raw data from S3 response = s3_client.get_object(Bucket=source_bucket, Key=source_key) raw_data = json.loads(response[\u0026#39;Body\u0026#39;].read().decode(\u0026#39;utf-8\u0026#39;)) # Determine data type based on key path if \u0026#39;current-weather\u0026#39; in source_key: processed_data = transform_current_weather(raw_data) data_type = \u0026#39;current-weather\u0026#39; elif \u0026#39;forecast\u0026#39; in source_key: processed_data = transform_forecast_weather(raw_data) data_type = \u0026#39;forecast\u0026#39; else: logger.warning(f\u0026#34;Unknown data type for key: {source_key}\u0026#34;) return False # Generate processed file key processed_key = generate_processed_key(source_key, data_type) # Save processed data to S3 s3_client.put_object( Bucket=PROCESSED_BUCKET_NAME, Key=processed_key, Body=json.dumps(processed_data, indent=2, ensure_ascii=False, default=decimal_default), ContentType=\u0026#39;application/json; charset=utf-8\u0026#39;, Metadata={ \u0026#39;source-key\u0026#39;: source_key, \u0026#39;processing-timestamp\u0026#39;: datetime.now(timezone.utc).isoformat(), \u0026#39;data-type\u0026#39;: data_type, \u0026#39;city\u0026#39;: processed_data.get(\u0026#39;city_name\u0026#39;, \u0026#39;unknown\u0026#39;) } ) logger.info(f\u0026#34;Successfully processed and saved: s3://{PROCESSED_BUCKET_NAME}/{processed_key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;Error processing file {source_key}: {e}\u0026#34;) return False def transform_current_weather(raw_data: Dict) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34; Transform current weather data from OpenWeatherMap format to analytics format \u0026#34;\u0026#34;\u0026#34; try: # Extract basic information city_name = raw_data.get(\u0026#39;name\u0026#39;, \u0026#39;Unknown\u0026#39;) # Get collection timestamp from metadata (added by our collector) collection_timestamp = raw_data.get(\u0026#39;collection_timestamp\u0026#39;) if collection_timestamp: dt = datetime.fromisoformat(collection_timestamp.replace(\u0026#39;Z\u0026#39;, \u0026#39;+00:00\u0026#39;)) else: # Fallback to API timestamp dt = datetime.fromtimestamp(raw_data.get(\u0026#39;dt\u0026#39;, 0), tz=timezone.utc) # Base processed data structure processed = { # Identifiers \u0026#39;city_name\u0026#39;: city_name, \u0026#39;city_id\u0026#39;: raw_data.get(\u0026#39;id\u0026#39;), \u0026#39;country_code\u0026#39;: raw_data.get(\u0026#39;sys\u0026#39;, {}).get(\u0026#39;country\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;latitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lat\u0026#39;), \u0026#39;longitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lon\u0026#39;), # Timestamps \u0026#39;collection_timestamp\u0026#39;: dt.isoformat(), \u0026#39;collection_date\u0026#39;: dt.strftime(\u0026#39;%Y-%m-%d\u0026#39;), \u0026#39;collection_hour\u0026#39;: dt.hour, \u0026#39;api_timestamp\u0026#39;: datetime.fromtimestamp(raw_data.get(\u0026#39;dt\u0026#39;, 0), tz=timezone.utc).isoformat(), # Weather conditions \u0026#39;weather_id\u0026#39;: None, \u0026#39;weather_main\u0026#39;: None, \u0026#39;weather_description\u0026#39;: None, \u0026#39;weather_icon\u0026#39;: None, # Temperature (convert from Kelvin to Celsius) \u0026#39;temperature_celsius\u0026#39;: None, \u0026#39;temperature_fahrenheit\u0026#39;: None, \u0026#39;feels_like_celsius\u0026#39;: None, \u0026#39;feels_like_fahrenheit\u0026#39;: None, \u0026#39;temp_min_celsius\u0026#39;: None, \u0026#39;temp_max_celsius\u0026#39;: None, # Atmospheric conditions \u0026#39;pressure_hpa\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;pressure\u0026#39;), \u0026#39;humidity_percent\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;humidity\u0026#39;), \u0026#39;visibility_meters\u0026#39;: raw_data.get(\u0026#39;visibility\u0026#39;), # Wind \u0026#39;wind_speed_ms\u0026#39;: raw_data.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;speed\u0026#39;), \u0026#39;wind_speed_kmh\u0026#39;: None, \u0026#39;wind_direction_deg\u0026#39;: raw_data.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;deg\u0026#39;), \u0026#39;wind_gust_ms\u0026#39;: raw_data.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;gust\u0026#39;), # Clouds and precipitation \u0026#39;cloud_coverage_percent\u0026#39;: raw_data.get(\u0026#39;clouds\u0026#39;, {}).get(\u0026#39;all\u0026#39;), \u0026#39;rain_1h_mm\u0026#39;: raw_data.get(\u0026#39;rain\u0026#39;, {}).get(\u0026#39;1h\u0026#39;), \u0026#39;rain_3h_mm\u0026#39;: raw_data.get(\u0026#39;rain\u0026#39;, {}).get(\u0026#39;3h\u0026#39;), \u0026#39;snow_1h_mm\u0026#39;: raw_data.get(\u0026#39;snow\u0026#39;, {}).get(\u0026#39;1h\u0026#39;), \u0026#39;snow_3h_mm\u0026#39;: raw_data.get(\u0026#39;snow\u0026#39;, {}).get(\u0026#39;3h\u0026#39;), # Sun times \u0026#39;sunrise_timestamp\u0026#39;: None, \u0026#39;sunset_timestamp\u0026#39;: None, # Derived metrics (calculated later) \u0026#39;heat_index_celsius\u0026#39;: None, \u0026#39;comfort_level\u0026#39;: None, \u0026#39;wind_condition\u0026#39;: None, \u0026#39;weather_severity\u0026#39;: None, \u0026#39;uv_risk_level\u0026#39;: None } # Process weather conditions weather_list = raw_data.get(\u0026#39;weather\u0026#39;, []) if weather_list: weather = weather_list[0] processed.update({ \u0026#39;weather_id\u0026#39;: weather.get(\u0026#39;id\u0026#39;), \u0026#39;weather_main\u0026#39;: weather.get(\u0026#39;main\u0026#39;), \u0026#39;weather_description\u0026#39;: weather.get(\u0026#39;description\u0026#39;), \u0026#39;weather_icon\u0026#39;: weather.get(\u0026#39;icon\u0026#39;) }) # Process temperature data main_data = raw_data.get(\u0026#39;main\u0026#39;, {}) if main_data.get(\u0026#39;temp\u0026#39;): temp_k = main_data[\u0026#39;temp\u0026#39;] processed[\u0026#39;temperature_celsius\u0026#39;] = round(temp_k - 273.15, 1) processed[\u0026#39;temperature_fahrenheit\u0026#39;] = round((temp_k - 273.15) * 9/5 + 32, 1) if main_data.get(\u0026#39;feels_like\u0026#39;): feels_k = main_data[\u0026#39;feels_like\u0026#39;] processed[\u0026#39;feels_like_celsius\u0026#39;] = round(feels_k - 273.15, 1) processed[\u0026#39;feels_like_fahrenheit\u0026#39;] = round((feels_k - 273.15) * 9/5 + 32, 1) if main_data.get(\u0026#39;temp_min\u0026#39;): min_k = main_data[\u0026#39;temp_min\u0026#39;] processed[\u0026#39;temp_min_celsius\u0026#39;] = round(min_k - 273.15, 1) if main_data.get(\u0026#39;temp_max\u0026#39;): max_k = main_data[\u0026#39;temp_max\u0026#39;] processed[\u0026#39;temp_max_celsius\u0026#39;] = round(max_k - 273.15, 1) # Process wind data if processed[\u0026#39;wind_speed_ms\u0026#39;]: processed[\u0026#39;wind_speed_kmh\u0026#39;] = round(processed[\u0026#39;wind_speed_ms\u0026#39;] * 3.6, 1) # Process sun times sys_data = raw_data.get(\u0026#39;sys\u0026#39;, {}) if sys_data.get(\u0026#39;sunrise\u0026#39;): processed[\u0026#39;sunrise_timestamp\u0026#39;] = datetime.fromtimestamp(sys_data[\u0026#39;sunrise\u0026#39;], tz=timezone.utc).isoformat() if sys_data.get(\u0026#39;sunset\u0026#39;): processed[\u0026#39;sunset_timestamp\u0026#39;] = datetime.fromtimestamp(sys_data[\u0026#39;sunset\u0026#39;], tz=timezone.utc).isoformat() # Calculate derived metrics processed.update(calculate_derived_metrics(processed)) return processed except Exception as e: logger.error(f\u0026#34;Error transforming current weather data: {e}\u0026#34;) raise def transform_forecast_weather(raw_data: Dict) -\u0026gt; List[Dict]: \u0026#34;\u0026#34;\u0026#34; Transform forecast weather data from OpenWeatherMap format to analytics format \u0026#34;\u0026#34;\u0026#34; try: # Extract city information city_info = raw_data.get(\u0026#39;city\u0026#39;, {}) city_name = city_info.get(\u0026#39;name\u0026#39;, \u0026#39;Unknown\u0026#39;) processed_forecasts = [] # Process each forecast item for item in raw_data.get(\u0026#39;list\u0026#39;, []): # Get forecast timestamp dt = datetime.fromtimestamp(item.get(\u0026#39;dt\u0026#39;, 0), tz=timezone.utc) # Base forecast data structure forecast = { # Identifiers \u0026#39;city_name\u0026#39;: city_name, \u0026#39;city_id\u0026#39;: city_info.get(\u0026#39;id\u0026#39;), \u0026#39;country_code\u0026#39;: city_info.get(\u0026#39;country\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;latitude\u0026#39;: city_info.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lat\u0026#39;), \u0026#39;longitude\u0026#39;: city_info.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lon\u0026#39;), # Timestamps \u0026#39;forecast_timestamp\u0026#39;: dt.isoformat(), \u0026#39;forecast_date\u0026#39;: dt.strftime(\u0026#39;%Y-%m-%d\u0026#39;), \u0026#39;forecast_hour\u0026#39;: dt.hour, \u0026#39;collection_timestamp\u0026#39;: raw_data.get(\u0026#39;collection_timestamp\u0026#39;), # Weather conditions \u0026#39;weather_id\u0026#39;: None, \u0026#39;weather_main\u0026#39;: None, \u0026#39;weather_description\u0026#39;: None, \u0026#39;weather_icon\u0026#39;: None, # Temperature \u0026#39;temperature_celsius\u0026#39;: None, \u0026#39;temperature_fahrenheit\u0026#39;: None, \u0026#39;feels_like_celsius\u0026#39;: None, \u0026#39;feels_like_fahrenheit\u0026#39;: None, \u0026#39;temp_min_celsius\u0026#39;: None, \u0026#39;temp_max_celsius\u0026#39;: None, # Atmospheric conditions \u0026#39;pressure_hpa\u0026#39;: item.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;pressure\u0026#39;), \u0026#39;humidity_percent\u0026#39;: item.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;humidity\u0026#39;), \u0026#39;visibility_meters\u0026#39;: item.get(\u0026#39;visibility\u0026#39;), # Wind \u0026#39;wind_speed_ms\u0026#39;: item.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;speed\u0026#39;), \u0026#39;wind_speed_kmh\u0026#39;: None, \u0026#39;wind_direction_deg\u0026#39;: item.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;deg\u0026#39;), \u0026#39;wind_gust_ms\u0026#39;: item.get(\u0026#39;wind\u0026#39;, {}).get(\u0026#39;gust\u0026#39;), # Clouds and precipitation \u0026#39;cloud_coverage_percent\u0026#39;: item.get(\u0026#39;clouds\u0026#39;, {}).get(\u0026#39;all\u0026#39;), \u0026#39;rain_3h_mm\u0026#39;: item.get(\u0026#39;rain\u0026#39;, {}).get(\u0026#39;3h\u0026#39;), \u0026#39;snow_3h_mm\u0026#39;: item.get(\u0026#39;snow\u0026#39;, {}).get(\u0026#39;3h\u0026#39;), \u0026#39;precipitation_probability\u0026#39;: item.get(\u0026#39;pop\u0026#39;, 0) * 100, # Convert to percentage # Derived metrics \u0026#39;heat_index_celsius\u0026#39;: None, \u0026#39;comfort_level\u0026#39;: None, \u0026#39;wind_condition\u0026#39;: None, \u0026#39;weather_severity\u0026#39;: None } # Process weather conditions weather_list = item.get(\u0026#39;weather\u0026#39;, []) if weather_list: weather = weather_list[0] forecast.update({ \u0026#39;weather_id\u0026#39;: weather.get(\u0026#39;id\u0026#39;), \u0026#39;weather_main\u0026#39;: weather.get(\u0026#39;main\u0026#39;), \u0026#39;weather_description\u0026#39;: weather.get(\u0026#39;description\u0026#39;), \u0026#39;weather_icon\u0026#39;: weather.get(\u0026#39;icon\u0026#39;) }) # Process temperature data main_data = item.get(\u0026#39;main\u0026#39;, {}) if main_data.get(\u0026#39;temp\u0026#39;): temp_k = main_data[\u0026#39;temp\u0026#39;] forecast[\u0026#39;temperature_celsius\u0026#39;] = round(temp_k - 273.15, 1) forecast[\u0026#39;temperature_fahrenheit\u0026#39;] = round((temp_k - 273.15) * 9/5 + 32, 1) if main_data.get(\u0026#39;feels_like\u0026#39;): feels_k = main_data[\u0026#39;feels_like\u0026#39;] forecast[\u0026#39;feels_like_celsius\u0026#39;] = round(feels_k - 273.15, 1) forecast[\u0026#39;feels_like_fahrenheit\u0026#39;] = round((feels_k - 273.15) * 9/5 + 32, 1) if main_data.get(\u0026#39;temp_min\u0026#39;): min_k = main_data[\u0026#39;temp_min\u0026#39;] forecast[\u0026#39;temp_min_celsius\u0026#39;] = round(min_k - 273.15, 1) if main_data.get(\u0026#39;temp_max\u0026#39;): max_k = main_data[\u0026#39;temp_max\u0026#39;] forecast[\u0026#39;temp_max_celsius\u0026#39;] = round(max_k - 273.15, 1) # Process wind data if forecast[\u0026#39;wind_speed_ms\u0026#39;]: forecast[\u0026#39;wind_speed_kmh\u0026#39;] = round(forecast[\u0026#39;wind_speed_ms\u0026#39;] * 3.6, 1) # Calculate derived metrics forecast.update(calculate_derived_metrics(forecast)) processed_forecasts.append(forecast) return processed_forecasts except Exception as e: logger.error(f\u0026#34;Error transforming forecast weather data: {e}\u0026#34;) raise def calculate_derived_metrics(data: Dict) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34; Calculate derived weather metrics \u0026#34;\u0026#34;\u0026#34; derived = {} try: temp_c = data.get(\u0026#39;temperature_celsius\u0026#39;) humidity = data.get(\u0026#39;humidity_percent\u0026#39;) wind_speed_kmh = data.get(\u0026#39;wind_speed_kmh\u0026#39;) weather_main = data.get(\u0026#39;weather_main\u0026#39;, \u0026#39;\u0026#39;).lower() # Calculate heat index (only meaningful above 27°C) if temp_c and humidity and temp_c \u0026gt;= 27: temp_f = temp_c * 9/5 + 32 # Simplified heat index calculation if temp_f \u0026gt;= 80: heat_index_f = ( -42.379 + 2.04901523 * temp_f + 10.14333127 * humidity - 0.22475541 * temp_f * humidity - 6.83783e-3 * temp_f**2 - 5.481717e-2 * humidity**2 + 1.22874e-3 * temp_f**2 * humidity + 8.5282e-4 * temp_f * humidity**2 - 1.99e-6 * temp_f**2 * humidity**2 ) derived[\u0026#39;heat_index_celsius\u0026#39;] = round((heat_index_f - 32) * 5/9, 1) # Calculate comfort level if temp_c and humidity: if temp_c \u0026lt; 16: comfort = \u0026#39;cold\u0026#39; elif temp_c \u0026lt; 20: comfort = \u0026#39;cool\u0026#39; elif temp_c \u0026lt;= 26 and humidity \u0026lt;= 60: comfort = \u0026#39;comfortable\u0026#39; elif temp_c \u0026lt;= 30 and humidity \u0026lt;= 70: comfort = \u0026#39;warm\u0026#39; elif temp_c \u0026lt;= 35: comfort = \u0026#39;hot\u0026#39; else: comfort = \u0026#39;very_hot\u0026#39; derived[\u0026#39;comfort_level\u0026#39;] = comfort # Calculate wind condition if wind_speed_kmh: if wind_speed_kmh \u0026lt; 5: wind_condition = \u0026#39;calm\u0026#39; elif wind_speed_kmh \u0026lt; 20: wind_condition = \u0026#39;light\u0026#39; elif wind_speed_kmh \u0026lt; 40: wind_condition = \u0026#39;moderate\u0026#39; elif wind_speed_kmh \u0026lt; 60: wind_condition = \u0026#39;strong\u0026#39; else: wind_condition = \u0026#39;very_strong\u0026#39; derived[\u0026#39;wind_condition\u0026#39;] = wind_condition # Calculate weather severity if weather_main: if weather_main in [\u0026#39;thunderstorm\u0026#39;, \u0026#39;tornado\u0026#39;]: severity = \u0026#39;severe\u0026#39; elif weather_main in [\u0026#39;rain\u0026#39;, \u0026#39;snow\u0026#39;, \u0026#39;drizzle\u0026#39;]: severity = \u0026#39;moderate\u0026#39; elif weather_main in [\u0026#39;mist\u0026#39;, \u0026#39;fog\u0026#39;, \u0026#39;haze\u0026#39;, \u0026#39;smoke\u0026#39;]: severity = \u0026#39;mild\u0026#39; else: severity = \u0026#39;normal\u0026#39; derived[\u0026#39;weather_severity\u0026#39;] = severity return derived except Exception as e: logger.error(f\u0026#34;Error calculating derived metrics: {e}\u0026#34;) return {} def generate_processed_key(source_key: str, data_type: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Generate processed file key with proper partitioning \u0026#34;\u0026#34;\u0026#34; try: # Extract timestamp from source key now = datetime.now(timezone.utc) # Extract city name from source key key_parts = source_key.split(\u0026#39;/\u0026#39;) filename = key_parts[-1] city_name = filename.split(\u0026#39;_\u0026#39;)[0] # Generate processed key with Hive partitioning processed_key = ( f\u0026#34;{data_type}/\u0026#34; f\u0026#34;year={now.year}/\u0026#34; f\u0026#34;month={now.month:02d}/\u0026#34; f\u0026#34;day={now.day:02d}/\u0026#34; f\u0026#34;hour={now.hour:02d}/\u0026#34; f\u0026#34;{city_name}_processed_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; ) return processed_key except Exception as e: logger.error(f\u0026#34;Error generating processed key: {e}\u0026#34;) return f\u0026#34;processed/{source_key}\u0026#34; def send_processing_metrics(processed_count: int, failed_count: int): \u0026#34;\u0026#34;\u0026#34; Send processing metrics to CloudWatch \u0026#34;\u0026#34;\u0026#34; try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/Processing\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;ProcessedFiles\u0026#39;, \u0026#39;Value\u0026#39;: processed_count, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;FailedFiles\u0026#39;, \u0026#39;Value\u0026#39;: failed_count, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;ProcessingSuccess\u0026#39;, \u0026#39;Value\u0026#39;: 1 if failed_count == 0 else 0, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) logger.info(f\u0026#34;Sent metrics - Processed: {processed_count}, Failed: {failed_count}\u0026#34;) except Exception as e: logger.error(f\u0026#34;Error sending metrics: {e}\u0026#34;) def decimal_default(obj): \u0026#34;\u0026#34;\u0026#34; JSON serializer for objects not serializable by default json code \u0026#34;\u0026#34;\u0026#34; if isinstance(obj, Decimal): return float(obj) raise TypeError(f\u0026#34;Object of type {type(obj)} is not JSON serializable\u0026#34;) Deploy code bằng cách click \u0026ldquo;Deploy\u0026rdquo; Bước 3: Thiết lập S3 Event Trigger Quan trọng: S3 Event Trigger sẽ tự động chạy Lambda mỗi khi có file mới được upload vào raw bucket. Đảm bảo Lambda function hoạt động đúng trước khi enable trigger.\n3.1 Thêm Permission cho S3 invoke Lambda Lambda Console → weather-data-processor → Configuration → Permissions\nResource-based policy → Add permissions:\nPrincipal: s3.amazonaws.com Source ARN: arn:aws:s3:::weather-data-{your-account-id} Action: lambda:InvokeFunction 3.2 Configure S3 Event Notification S3 Console → weather-data-{your-account-id} bucket → Properties\nEvent notifications → Create event notification:\nEvent name: weather-data-processing-trigger Event types: ✅ All object create events Prefix: raw/ Suffix: .json Destination: Lambda function → weather-data-processor Save changes Bước 4: Testing Data Processing 4.1 Test với Manual Upload Upload một file test để trigger processing:\nTạo test file test_weather.json: { \u0026#34;coord\u0026#34;: { \u0026#34;lon\u0026#34;: 106.6297, \u0026#34;lat\u0026#34;: 10.8231 }, \u0026#34;weather\u0026#34;: [ { \u0026#34;id\u0026#34;: 800, \u0026#34;main\u0026#34;: \u0026#34;Clear\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;clear sky\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;01d\u0026#34; } ], \u0026#34;main\u0026#34;: { \u0026#34;temp\u0026#34;: 305.15, \u0026#34;feels_like\u0026#34;: 309.65, \u0026#34;temp_min\u0026#34;: 305.15, \u0026#34;temp_max\u0026#34;: 305.15, \u0026#34;pressure\u0026#34;: 1013, \u0026#34;humidity\u0026#34;: 74 }, \u0026#34;wind\u0026#34;: { \u0026#34;speed\u0026#34;: 3.2, \u0026#34;deg\u0026#34;: 220 }, \u0026#34;clouds\u0026#34;: { \u0026#34;all\u0026#34;: 0 }, \u0026#34;dt\u0026#34;: 1704268800, \u0026#34;sys\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;sunrise\u0026#34;: 1704225600, \u0026#34;sunset\u0026#34;: 1704268800 }, \u0026#34;timezone\u0026#34;: 25200, \u0026#34;id\u0026#34;: 1566083, \u0026#34;name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;collection_timestamp\u0026#34;: \u0026#34;2025-01-03T08:00:00Z\u0026#34; } Upload file: aws s3 cp test_weather.json s3://weather-data-{your-account-id}/raw/current-weather/year=2025/month=01/day=03/hour=08/hcm_20250103_080000.json Check CloudWatch Logs: CloudWatch Console → Log groups → /aws/lambda/weather-data-processor Latest log stream → Verify processing logs 4.2 Verify Processed Data Check processed bucket: aws s3 ls s3://weather-processed-{your-account-id}/current-weather/ --recursive Download và examine processed file: aws s3 cp s3://weather-processed-{your-account-id}/current-weather/year=2025/month=01/day=03/hour=08/hcm_processed_20250103_080000.json ./ cat hcm_processed_20250103_080000.json | jq . Expected processed output:\n{ \u0026#34;city_name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;country_code\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;latitude\u0026#34;: 10.8231, \u0026#34;longitude\u0026#34;: 106.6297, \u0026#34;collection_timestamp\u0026#34;: \u0026#34;2025-01-03T08:00:00+00:00\u0026#34;, \u0026#34;collection_date\u0026#34;: \u0026#34;2025-01-03\u0026#34;, \u0026#34;collection_hour\u0026#34;: 8, \u0026#34;weather_main\u0026#34;: \u0026#34;Clear\u0026#34;, \u0026#34;weather_description\u0026#34;: \u0026#34;clear sky\u0026#34;, \u0026#34;temperature_celsius\u0026#34;: 32.0, \u0026#34;temperature_fahrenheit\u0026#34;: 89.6, \u0026#34;feels_like_celsius\u0026#34;: 36.5, \u0026#34;feels_like_fahrenheit\u0026#34;: 97.7, \u0026#34;humidity_percent\u0026#34;: 74, \u0026#34;pressure_hpa\u0026#34;: 1013, \u0026#34;wind_speed_ms\u0026#34;: 3.2, \u0026#34;wind_speed_kmh\u0026#34;: 11.5, \u0026#34;wind_direction_deg\u0026#34;: 220, \u0026#34;cloud_coverage_percent\u0026#34;: 0, \u0026#34;comfort_level\u0026#34;: \u0026#34;hot\u0026#34;, \u0026#34;wind_condition\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;weather_severity\u0026#34;: \u0026#34;normal\u0026#34; } 4.3 Test với Real Data từ Module 2 Nếu EventBridge rules từ Module 2 đang chạy:\nWait for scheduled collection (next hour hoặc 6-hour interval)\nCheck logs để verify automatic processing:\naws logs filter-log-events \\ --log-group-name /aws/lambda/weather-data-processor \\ --start-time $(date -d \u0026#39;1 hour ago\u0026#39; +%s)000 \\ --filter-pattern \u0026#34;Processing file\u0026#34; Verify processed data structure: aws s3 ls s3://weather-processed-{your-account-id}/ --recursive | head -20 Bước 5: Monitoring và Optimization 5.1 CloudWatch Metrics Dashboard CloudWatch Console → Dashboards → Create dashboard\nDashboard name: Weather-Data-Processing\nAdd widgets:\nWidget 1 - Processing Success Rate:\nMetric: Weather/Processing \u0026gt; ProcessedFiles Metric: Weather/Processing \u0026gt; FailedFiles Period: 1 hour Statistic: Sum Widget 2 - Lambda Performance:\nMetric: AWS/Lambda \u0026gt; Duration (function: weather-data-processor) Metric: AWS/Lambda \u0026gt; Errors (function: weather-data-processor) Period: 5 minutes Widget 3 - S3 Object Count:\nMetric: AWS/S3 \u0026gt; NumberOfObjects (bucket: weather-processed-*) Period: 1 day 5.2 CloudWatch Alarms Tạo alarm cho processing failures:\nAlarm name: WeatherProcessing-HighFailureRate Metric: Weather/Processing \u0026gt; FailedFiles Condition: Greater than 2 (trong 1 hour) Action: Send to SNS topic từ Module 2 Tạo alarm cho Lambda errors:\nAlarm name: WeatherProcessor-LambdaErrors Metric: AWS/Lambda \u0026gt; Errors Condition: Greater than 1 (trong 5 minutes) Action: Send to SNS topic 5.3 Cost Optimization Optimize Lambda configuration:\nMemory: Monitor actual usage và adjust accordingly Timeout: Reduce nếu processing time stable Reserved concurrency: Set limit để avoid cost spikes S3 Storage optimization:\nLifecycle policies cho processed data: After 30 days: Move to IA After 90 days: Move to Glacier After 365 days: Move to Deep Archive Data Comparison: Raw vs Processed Raw Data (từ Module 2) { \u0026#34;coord\u0026#34;: { \u0026#34;lon\u0026#34;: 106.6297, \u0026#34;lat\u0026#34;: 10.8231 }, \u0026#34;weather\u0026#34;: [ { \u0026#34;id\u0026#34;: 800, \u0026#34;main\u0026#34;: \u0026#34;Clear\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;clear sky\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;01d\u0026#34; } ], \u0026#34;main\u0026#34;: { \u0026#34;temp\u0026#34;: 305.15, \u0026#34;feels_like\u0026#34;: 309.65, \u0026#34;pressure\u0026#34;: 1013, \u0026#34;humidity\u0026#34;: 74 }, \u0026#34;wind\u0026#34;: { \u0026#34;speed\u0026#34;: 3.2, \u0026#34;deg\u0026#34;: 220 }, \u0026#34;clouds\u0026#34;: { \u0026#34;all\u0026#34;: 0 }, \u0026#34;dt\u0026#34;: 1704268800, \u0026#34;sys\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;sunrise\u0026#34;: 1704225600, \u0026#34;sunset\u0026#34;: 1704268800 }, \u0026#34;timezone\u0026#34;: 25200, \u0026#34;id\u0026#34;: 1566083, \u0026#34;name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;collection_timestamp\u0026#34;: \u0026#34;2025-01-03T08:00:00Z\u0026#34; } Processed Data (sau Module 3) { \u0026#34;city_name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;country_code\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;latitude\u0026#34;: 10.8231, \u0026#34;longitude\u0026#34;: 106.6297, \u0026#34;collection_timestamp\u0026#34;: \u0026#34;2025-01-03T08:00:00+00:00\u0026#34;, \u0026#34;collection_date\u0026#34;: \u0026#34;2025-01-03\u0026#34;, \u0026#34;collection_hour\u0026#34;: 8, \u0026#34;weather_main\u0026#34;: \u0026#34;Clear\u0026#34;, \u0026#34;weather_description\u0026#34;: \u0026#34;clear sky\u0026#34;, \u0026#34;temperature_celsius\u0026#34;: 32.0, \u0026#34;temperature_fahrenheit\u0026#34;: 89.6, \u0026#34;feels_like_celsius\u0026#34;: 36.5, \u0026#34;feels_like_fahrenheit\u0026#34;: 97.7, \u0026#34;humidity_percent\u0026#34;: 74, \u0026#34;pressure_hpa\u0026#34;: 1013, \u0026#34;wind_speed_ms\u0026#34;: 3.2, \u0026#34;wind_speed_kmh\u0026#34;: 11.5, \u0026#34;wind_direction_deg\u0026#34;: 220, \u0026#34;cloud_coverage_percent\u0026#34;: 0, \u0026#34;comfort_level\u0026#34;: \u0026#34;hot\u0026#34;, \u0026#34;wind_condition\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;weather_severity\u0026#34;: \u0026#34;normal\u0026#34; } Key improvements:\n✅ Flat structure: Dễ query với SQL ✅ Standardized units: Celsius, km/h, % ✅ Rich metadata: Date, hour partitioning ✅ Derived insights: Comfort level, wind condition, weather severity ✅ Analytics-ready: Optimized cho Athena queries Troubleshooting Common Issues Processing Failures Issue: Lambda function timeout Solution:\nIncrease timeout (max 15 minutes) Optimize code performance Process files in batches Issue: S3 permission denied Solution:\nVerify IAM role permissions Check bucket policies Ensure correct bucket names Issue: JSON parsing errors Solution:\nAdd error handling for malformed JSON Log problematic files for manual inspection Implement retry logic Performance Issues Issue: High processing latency Solution:\nIncrease Lambda memory (more CPU) Optimize data transformation logic Use concurrent processing Issue: High costs Solution:\nRight-size Lambda memory Implement S3 lifecycle policies Use reserved concurrency limits Tóm tắt Trong module này, chúng ta đã hoàn thành:\nXây dựng Data Processing Pipeline:\nLambda function xử lý real-time data từ S3 events Transform raw weather data thành analytics-ready format Automatic partitioning cho optimal query performance Data Transformation Features:\nConvert units (Kelvin → Celsius, m/s → km/h) Calculate derived metrics (heat index, comfort level) Clean và normalize data structure Add rich metadata cho analytics Monitoring và Optimization:\nCloudWatch metrics và alarms Performance monitoring dashboard Cost optimization strategies Error handling và retry logic Kết quả: Dữ liệu thời tiết clean, structured, và ready cho advanced analytics trong Module 4!\nTiếp theo: Trong Module 4, chúng ta sẽ sử dụng Amazon Athena để query và analyze processed data này một cách hiệu quả.\n"
},
{
	"uri": "//localhost:1313/vi/4-data-storage-solutions/",
	"title": "Phân tích Dữ liệu với Athena",
	"tags": [],
	"description": "",
	"content": "Phân tích Dữ liệu với Athena Trong module này, bạn sẽ học cách sử dụng Amazon Athena để chạy các truy vấn SQL trực tiếp trên dữ liệu thời tiết đã xử lý được lưu trữ trong S3. Athena là dịch vụ truy vấn serverless giúp dễ dàng phân tích dữ liệu bằng SQL tiêu chuẩn mà không cần thiết lập cơ sở hạ tầng kho dữ liệu phức tạp.\nTổng quan Module Amazon Athena cho phép bạn phân tích dữ liệu trong S3 bằng các truy vấn SQL tiêu chuẩn mà không cần phải di chuyển dữ liệu hoặc thiết lập máy chủ. Điều này làm cho nó trở thành công cụ lý tưởng để phân tích dữ liệu thời tiết của bạn. Trong module này, chúng ta sẽ thiết lập Athena để truy vấn dữ liệu thời tiết đã xử lý và trích xuất những hiểu biết có ý nghĩa.\nThời gian: 40-50 phút\nChi phí: ~$0.50\nNhững gì bạn sẽ xây dựng graph LR\rA[S3 Processed Data] --\u0026gt; B[Athena Query Service]\rB --\u0026gt; C[SQL Analysis]\rC --\u0026gt; D[Weather Insights]\rstyle B fill:#4fc3f7,stroke:#232f3e,stroke-width:3px\rstyle A fill:#f3e5f5\rstyle D fill:#66bb6a Điều kiện tiên quyết Đã hoàn thành Module 3: Xử lý và Chuyển đổi Dữ liệu Dữ liệu thời tiết đã xử lý có sẵn trong S3 Truy cập AWS Console Bước 1: Thiết lập Vị trí Kết quả Truy vấn Athena Trước khi sử dụng Athena, bạn cần cấu hình vị trí để lưu trữ kết quả truy vấn.\n1.1 Tạo S3 Bucket cho Kết quả Truy vấn # Tạo bucket cho kết quả truy vấn Athena aws s3 mb s3://your-athena-query-results-bucket # Tùy chọn: Thiết lập lifecycle policy để xóa kết quả cũ sau 30 ngày cat \u0026gt; lifecycle-policy.json \u0026lt;\u0026lt; EOF { \u0026#34;Rules\u0026#34;: [ { \u0026#34;ID\u0026#34;: \u0026#34;DeleteOldQueryResults\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Enabled\u0026#34;, \u0026#34;Filter\u0026#34;: {\u0026#34;Prefix\u0026#34;: \u0026#34;\u0026#34;}, \u0026#34;Expiration\u0026#34;: {\u0026#34;Days\u0026#34;: 30} } ] } EOF aws s3api put-bucket-lifecycle-configuration \\ --bucket your-athena-query-results-bucket \\ --lifecycle-configuration file://lifecycle-policy.json 1.2 Cấu hình Vị trí Kết quả Truy vấn Athena Mở Amazon Athena console Nhấp Settings ở góc phải trên Nhấp Manage Nhập đường dẫn S3 bucket: s3://your-athena-query-results-bucket/ Nhấp Save Bước 2: Tạo Database và Table 2.1 Tạo Weather Analytics Database Trong Athena Query Editor, chạy:\nCREATE DATABASE IF NOT EXISTS weather_analytics COMMENT \u0026#39;Database for weather data analysis\u0026#39; LOCATION \u0026#39;s3://your-athena-query-results-bucket/databases/weather_analytics/\u0026#39;; 2.2 Tạo External Table cho Dữ liệu Thời tiết Đã Xử lý CREATE EXTERNAL TABLE IF NOT EXISTS weather_analytics.current_weather ( timestamp STRING, city_name STRING, country STRING, latitude DOUBLE, longitude DOUBLE, data_collection_date STRING, temperature_kelvin DOUBLE, temperature_celsius DOUBLE, temperature_fahrenheit DOUBLE, feels_like_celsius DOUBLE, feels_like_fahrenheit DOUBLE, humidity_percent INT, pressure_hpa INT, visibility_meters BIGINT, uv_index DOUBLE, weather_id INT, weather_main STRING, weather_description STRING, weather_icon STRING, wind_speed_ms DOUBLE, wind_speed_kmh DOUBLE, wind_speed_mph DOUBLE, wind_direction_deg INT, wind_gust_ms DOUBLE, cloud_coverage_percent INT, rain_1h_mm DOUBLE, rain_3h_mm DOUBLE, snow_1h_mm DOUBLE, snow_3h_mm DOUBLE, heat_index_fahrenheit DOUBLE, heat_index_celsius DOUBLE, comfort_level STRING, wind_condition STRING, weather_severity STRING ) ROW FORMAT SERDE \u0026#39;org.openx.data.jsonserde.JsonSerDe\u0026#39; WITH SERDEPROPERTIES ( \u0026#39;serialization.format\u0026#39; = \u0026#39;1\u0026#39; ) LOCATION \u0026#39;s3://your-weather-processed-bucket/processed/\u0026#39; TBLPROPERTIES ( \u0026#39;has_encrypted_data\u0026#39;=\u0026#39;false\u0026#39;, \u0026#39;projection.enabled\u0026#39;=\u0026#39;true\u0026#39;, \u0026#39;projection.data_collection_date.type\u0026#39;=\u0026#39;date\u0026#39;, \u0026#39;projection.data_collection_date.range\u0026#39;=\u0026#39;2025-01-01,NOW\u0026#39;, \u0026#39;projection.data_collection_date.format\u0026#39;=\u0026#39;yyyy-MM-dd\u0026#39;, \u0026#39;storage.location.template\u0026#39;=\u0026#39;s3://your-weather-processed-bucket/processed/year=${data_collection_date}\u0026#39; ); 2.3 Xác minh Tạo Table -- Kiểm tra xem table đã được tạo thành công chưa SHOW TABLES IN weather_analytics; -- Lấy schema của table DESCRIBE weather_analytics.current_weather; -- Đếm tổng số bản ghi SELECT COUNT(*) as total_records FROM weather_analytics.current_weather; Bước 3: Phân tích Dữ liệu Thời tiết Cơ bản 3.1 Truy vấn Khám phá Dữ liệu Xem Dữ liệu Mẫu -- Lấy mẫu dữ liệu của bạn SELECT * FROM weather_analytics.current_weather LIMIT 10; Kiểm tra Chất lượng Dữ liệu -- Kiểm tra giá trị thiếu trong các trường chính SELECT COUNT(*) as total_records, COUNT(temperature_celsius) as temp_records, COUNT(humidity_percent) as humidity_records, COUNT(pressure_hpa) as pressure_records, COUNT(wind_speed_ms) as wind_records FROM weather_analytics.current_weather; Phân tích Phạm vi Ngày -- Kiểm tra phạm vi ngày của dữ liệu SELECT MIN(data_collection_date) as earliest_date, MAX(data_collection_date) as latest_date, COUNT(DISTINCT data_collection_date) as unique_dates FROM weather_analytics.current_weather; 3.2 Phân tích Nhiệt độ Nhiệt độ Trung bình theo Thành phố SELECT city_name, country, COUNT(*) as measurement_count, ROUND(AVG(temperature_celsius), 2) as avg_temp_celsius, ROUND(MIN(temperature_celsius), 2) as min_temp_celsius, ROUND(MAX(temperature_celsius), 2) as max_temp_celsius FROM weather_analytics.current_weather GROUP BY city_name, country ORDER BY avg_temp_celsius DESC; Xu hướng Nhiệt độ Theo Thời gian SELECT data_collection_date, city_name, ROUND(AVG(temperature_celsius), 2) as avg_temp, ROUND(AVG(feels_like_celsius), 2) as avg_feels_like FROM weather_analytics.current_weather WHERE data_collection_date \u0026gt;= DATE(\u0026#39;2025-01-01\u0026#39;) GROUP BY data_collection_date, city_name ORDER BY data_collection_date, city_name; Phân tích Chỉ số Nhiệt SELECT city_name, ROUND(AVG(heat_index_celsius), 2) as avg_heat_index, comfort_level, COUNT(*) as occurrence_count FROM weather_analytics.current_weather WHERE heat_index_celsius IS NOT NULL GROUP BY city_name, comfort_level ORDER BY avg_heat_index DESC; 3.3 Phân tích Mẫu Thời tiết Phân bố Điều kiện Thời tiết SELECT weather_main, weather_description, COUNT(*) as occurrence_count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage FROM weather_analytics.current_weather GROUP BY weather_main, weather_description ORDER BY occurrence_count DESC; Phân tích Gió SELECT city_name, wind_condition, COUNT(*) as occurrence_count, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed_kmh, ROUND(MAX(wind_speed_kmh), 2) as max_wind_speed_kmh FROM weather_analytics.current_weather GROUP BY city_name, wind_condition ORDER BY city_name, avg_wind_speed_kmh DESC; Tương quan Độ ẩm và Nhiệt độ SELECT city_name, CASE WHEN temperature_celsius \u0026lt; 15 THEN \u0026#39;Lạnh\u0026#39; WHEN temperature_celsius \u0026lt; 25 THEN \u0026#39;Vừa\u0026#39; ELSE \u0026#39;Nóng\u0026#39; END as temp_category, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(temperature_celsius), 2) as avg_temperature, COUNT(*) as sample_count FROM weather_analytics.current_weather GROUP BY city_name, CASE WHEN temperature_celsius \u0026lt; 15 THEN \u0026#39;Lạnh\u0026#39; WHEN temperature_celsius \u0026lt; 25 THEN \u0026#39;Vừa\u0026#39; ELSE \u0026#39;Nóng\u0026#39; END ORDER BY city_name, temp_category; Bước 4: Truy vấn Phân tích Nâng cao 4.1 Phân tích Chuỗi Thời gian Tóm tắt Thời tiết Hàng ngày SELECT data_collection_date, COUNT(DISTINCT city_name) as cities_measured, ROUND(AVG(temperature_celsius), 2) as global_avg_temp, ROUND(AVG(humidity_percent), 2) as global_avg_humidity, ROUND(AVG(pressure_hpa), 2) as global_avg_pressure FROM weather_analytics.current_weather GROUP BY data_collection_date ORDER BY data_collection_date; Cực trị Thời tiết -- Tìm cực trị nhiệt độ WITH temp_extremes AS ( SELECT data_collection_date, city_name, temperature_celsius, ROW_NUMBER() OVER (PARTITION BY data_collection_date ORDER BY temperature_celsius DESC) as hot_rank, ROW_NUMBER() OVER (PARTITION BY data_collection_date ORDER BY temperature_celsius ASC) as cold_rank FROM weather_analytics.current_weather ) SELECT data_collection_date, MAX(CASE WHEN hot_rank = 1 THEN city_name END) as hottest_city, MAX(CASE WHEN hot_rank = 1 THEN temperature_celsius END) as highest_temp, MAX(CASE WHEN cold_rank = 1 THEN city_name END) as coldest_city, MAX(CASE WHEN cold_rank = 1 THEN temperature_celsius END) as lowest_temp FROM temp_extremes WHERE hot_rank = 1 OR cold_rank = 1 GROUP BY data_collection_date ORDER BY data_collection_date; 4.2 Phân tích Địa lý Thời tiết theo Vùng Địa lý SELECT CASE WHEN latitude \u0026gt; 23.5 THEN \u0026#39;Ôn đới Bắc\u0026#39; WHEN latitude \u0026gt; 0 THEN \u0026#39;Nhiệt đới Bắc\u0026#39; WHEN latitude \u0026gt; -23.5 THEN \u0026#39;Nhiệt đới Nam\u0026#39; ELSE \u0026#39;Ôn đới Nam\u0026#39; END as climate_zone, COUNT(*) as measurement_count, ROUND(AVG(temperature_celsius), 2) as avg_temperature, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed FROM weather_analytics.current_weather GROUP BY CASE WHEN latitude \u0026gt; 23.5 THEN \u0026#39;Ôn đới Bắc\u0026#39; WHEN latitude \u0026gt; 0 THEN \u0026#39;Nhiệt đới Bắc\u0026#39; WHEN latitude \u0026gt; -23.5 THEN \u0026#39;Nhiệt đới Nam\u0026#39; ELSE \u0026#39;Ôn đới Nam\u0026#39; END ORDER BY avg_temperature DESC; Bước 5: Xuất và Trực quan hóa Kết quả 5.1 Lưu Kết quả Truy vấn Chạy bất kỳ truy vấn nào trong Athena Nhấp Download để lưu kết quả dưới dạng CSV Kết quả cũng được tự động lưu vào S3 query results bucket của bạn 5.2 Tạo Trực quan hóa Đơn giản Bạn có thể sử dụng các file CSV đã xuất để tạo biểu đồ trong:\nExcel hoặc Google Sheets cho biểu đồ cơ bản Python/Jupyter cho phân tích nâng cao QuickSight (được đề cập trong module tiếp theo) 5.3 Ví dụ Quy trình Phân tích -- Tạo báo cáo thời tiết toàn diện SELECT city_name, country, COUNT(*) as total_measurements, ROUND(AVG(temperature_celsius), 1) as avg_temp_c, ROUND(MIN(temperature_celsius), 1) as min_temp_c, ROUND(MAX(temperature_celsius), 1) as max_temp_c, ROUND(AVG(humidity_percent), 1) as avg_humidity, ROUND(AVG(pressure_hpa), 1) as avg_pressure, ROUND(AVG(wind_speed_kmh), 1) as avg_wind_kmh, MODE() WITHIN GROUP (ORDER BY weather_main) as most_common_weather, MODE() WITHIN GROUP (ORDER BY comfort_level) as most_common_comfort FROM weather_analytics.current_weather GROUP BY city_name, country HAVING COUNT(*) \u0026gt;= 5 -- Chỉ các thành phố có ít nhất 5 phép đo ORDER BY avg_temp_c DESC; Bước 6: Tối ưu hóa Hiệu suất 6.1 Mẹo Hiệu suất Truy vấn Sử dụng LIMIT cho truy vấn khám phá: SELECT * FROM weather_analytics.current_weather WHERE data_collection_date = \u0026#39;2025-01-15\u0026#39; LIMIT 100; Lọc trên cột partition: -- Tốt - lọc trên cột đã partition SELECT * FROM weather_analytics.current_weather WHERE data_collection_date BETWEEN \u0026#39;2025-01-01\u0026#39; AND \u0026#39;2025-01-07\u0026#39;; Chỉ select cột cần thiết: -- Hiệu suất tốt hơn SELECT city_name, temperature_celsius, humidity_percent FROM weather_analytics.current_weather; 6.2 Tối ưu hóa Chi phí Giám sát việc sử dụng Athena của bạn:\nKiểm tra CloudWatch metrics cho dữ liệu được quét Sử dụng Athena Query History để phân tích chi phí Xem xét chuyển đổi sang định dạng Parquet cho dataset lớn Khắc phục Các Vấn đề Thường gặp Vấn đề 1: Lỗi \u0026ldquo;Table not found\u0026rdquo; Xác minh quyền S3 bucket của bạn Kiểm tra dữ liệu tồn tại trong vị trí S3 đã chỉ định Đảm bảo schema table phù hợp với dữ liệu của bạn Vấn đề 2: \u0026ldquo;Zero records returned\u0026rdquo; Xác minh định dạng dữ liệu phù hợp với schema table Kiểm tra đường dẫn S3 trong định nghĩa table Đảm bảo files ở định dạng JSON như mong đợi Vấn đề 3: Lỗi \u0026ldquo;Access denied\u0026rdquo; Kiểm tra quyền IAM cho Athena và S3 Xác minh quyền query results bucket Phân tích Chi phí Chi phí điển hình cho module này:\nTruy vấn Athena: ~$5 per TB dữ liệu được quét Lưu trữ S3: ~$0.023 per GB/tháng Yêu cầu S3: ~$0.0004 per 1,000 yêu cầu Đối với dataset thời tiết điển hình (1-10 MB), mong đợi tổng chi phí dưới $0.50.\nCác bước tiếp theo Sau khi hoàn thành module này, bạn sẽ có thể phân tích dữ liệu thời tiết của mình bằng các truy vấn SQL trong Athena. Trong module tiếp theo, chúng ta sẽ xây dựng trên nền tảng này để tạo bảng điều khiển tương tác bằng Amazon QuickSight.\nKhi viết truy vấn Athena, luôn cố gắng giới hạn lượng dữ liệu được quét bằng cách sử dụng mệnh đề WHERE thích hợp trên các trường ngày tháng và các cột được lọc thường xuyên khác.\nLưu các truy vấn hữu ích của bạn dưới dạng Saved Queries trong Athena để tái sử dụng. Bạn cũng có thể tạo Views cho các truy vấn phức tạp thường được sử dụng.\nNhớ thay thế tên bucket placeholder bằng tên S3 bucket thực tế của bạn trong tất cả truy vấn SQL.\n"
},
{
	"uri": "//localhost:1313/vi/5-analytics-visualization/",
	"title": "Trực quan hóa Dữ liệu với QuickSight",
	"tags": [],
	"description": "",
	"content": "Trực quan hóa Dữ liệu với Amazon QuickSight Bây giờ khi bạn đã có dữ liệu thời tiết được lưu trữ và có thể truy vấn thông qua Athena, đã đến lúc tạo các trực quan hóa hấp dẫn! Trong module này, bạn sẽ sử dụng Amazon QuickSight để xây dựng dashboard tương tác giúp dữ liệu thời tiết của bạn trở nên sinh động.\nTổng quan Module Amazon QuickSight là dịch vụ business intelligence (BI) của AWS giúp dễ dàng tạo và xuất bản các dashboard tương tác. Bạn sẽ kết nối QuickSight với nguồn dữ liệu Athena và tạo các trực quan hóa tiết lộ các mẫu và thông tin chi tiết từ dữ liệu thời tiết.\nThời gian: 45-60 phút\nChi phí: ~$3-4 (sử dụng dùng thử miễn phí)\nNhững gì bạn sẽ Xây dựng graph LR\rA[Athena Data] --\u0026gt; B[QuickSight Dataset]\rB --\u0026gt; C[Visualizations]\rC --\u0026gt; D[Interactive Dashboard]\rD --\u0026gt; E[Published Reports]\rstyle B fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle D fill:#66bb6a Điều kiện tiên quyết Đã hoàn thành Module 4: Phân tích Dữ liệu với Athena Dữ liệu thời tiết có sẵn trong bảng Athena Tài khoản AWS với quyền QuickSight Bước 1: Thiết lập Amazon QuickSight 1.1 Đăng ký QuickSight Điều hướng đến Amazon QuickSight console Nhấp Sign up for QuickSight Chọn Standard Edition (bao gồm dùng thử miễn phí 30 ngày) Nhập thông tin tài khoản: Account name: weather-analytics-[ten-ban] Notification email: Địa chỉ email của bạn Nhấp Finish 1.2 Cấu hình Quyền QuickSight Trong QuickSight, nhấp biểu tượng profile (góc phải trên) Chọn Manage QuickSight Chọn Security \u0026amp; permissions Nhấp Add or remove Kích hoạt các dịch vụ sau: ✅ Amazon Athena ✅ Amazon S3 Cho S3, nhấp Select S3 buckets Chọn bucket dữ liệu thời tiết: your-weather-processed-bucket your-athena-query-results-bucket Nhấp Update Bước 2: Tạo Data Source và Dataset 2.1 Kết nối với Athena Trong trang chủ QuickSight, nhấp Datasets Nhấp New dataset Chọn Athena làm data source Cấu hình kết nối: Data source name: Weather-Data-Athena Athena workgroup: primary (mặc định) Nhấp Create data source 2.2 Tạo Dataset từ Weather Table Chọn database: weather_analytics Chọn table: current_weather Chọn Directly query your data Nhấp Visualize Nếu dataset của bạn nhỏ (\u0026lt; 1GB), bạn có thể chọn \u0026ldquo;Import to SPICE\u0026rdquo; để có hiệu suất tốt hơn. SPICE là engine tính toán trong bộ nhớ của QuickSight.\nBước 3: Tạo Trực quan hóa Thời tiết 3.1 Biểu đồ Đường Xu hướng Nhiệt độ Tạo phân tích mới:\nNhấp + Add → Add visual Chọn Line chart Cấu hình biểu đồ:\nX-axis: Kéo data_collection_date vào X-axis Value: Kéo temperature_celsius vào Value Color: Kéo city_name vào Color Tùy chỉnh biểu đồ:\nNhấp visual → Format visual Title: \u0026ldquo;Xu hướng Nhiệt độ theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ (°C)\u0026rdquo; Legend: Đặt ở dưới cùng 3.2 Biểu đồ Tròn Điều kiện Thời tiết Thêm visual mới:\nNhấp + Add → Add visual Chọn Pie chart Cấu hình biểu đồ:\nGroup/Color: Kéo weather_main vào Group/Color Value: Kéo city_name vào Value Aggregate: Đổi thành Count Tùy chỉnh:\nTitle: \u0026ldquo;Phân bố Điều kiện Thời tiết\u0026rdquo; Legend: Hiển thị phần trăm 3.3 Biểu đồ Cột So sánh Nhiệt độ Thành phố Thêm visual mới:\nChọn Vertical bar chart Cấu hình:\nX-axis: Kéo city_name vào X-axis Value: Kéo temperature_celsius vào Value Aggregate: Đổi thành Average Tùy chỉnh:\nTitle: \u0026ldquo;Nhiệt độ Trung bình theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ Trung bình (°C)\u0026rdquo; Sắp xếp theo giá trị (giảm dần) 3.4 Biểu đồ Phân tán Độ ẩm vs Nhiệt độ Thêm visual mới:\nChọn Scatter plot Cấu hình:\nX-axis: Kéo temperature_celsius vào X-axis Y-axis: Kéo humidity_percent vào Y-axis Color: Kéo comfort_level vào Color Size: Kéo pressure_hpa vào Size Tùy chỉnh:\nTitle: \u0026ldquo;Tương quan Độ ẩm và Nhiệt độ\u0026rdquo; X-axis label: \u0026ldquo;Nhiệt độ (°C)\u0026rdquo; Y-axis label: \u0026ldquo;Độ ẩm (%)\u0026rdquo; 3.5 Chỉ số Hiệu suất Chính (KPIs) Tạo các ô KPI cho dữ liệu thời tiết mới nhất:\nKPI Nhiệt độ Hiện tại Thêm visual mới → KPI Cấu hình: Value: temperature_celsius Aggregate: Average Filter: Thêm filter cho ngày mới nhất Title: \u0026ldquo;Nhiệt độ Trung bình Hiện tại\u0026rdquo; KPI Tốc độ Gió Thêm KPI visual Cấu hình: Value: wind_speed_kmh Aggregate: Average Title: \u0026ldquo;Tốc độ Gió Trung bình Hiện tại\u0026rdquo; KPI Độ ẩm Thêm KPI visual Cấu hình: Value: humidity_percent Aggregate: Average Title: \u0026ldquo;Độ ẩm Trung bình Hiện tại\u0026rdquo; Bước 4: Xây dựng Dashboard Toàn diện 4.1 Tổ chức Bố cục Dashboard Thay đổi kích thước và sắp xếp visuals:\nĐặt KPIs ở trên cùng theo hàng ngang Biểu đồ xu hướng nhiệt độ ở khu vực chính Biểu đồ tròn và biểu đồ cột cạnh nhau bên dưới Biểu đồ phân tán ở dưới cùng Thêm tiêu đề dashboard:\nNhấp + Add → Add title Text: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Style: Lớn, căn giữa 4.2 Thêm Bộ lọc Tương tác Thêm bộ lọc ngày:\nNhấp Filter pane (bên trái) Nhấp Create one → Chọn data_collection_date Filter type: Date range Default: 7 ngày gần nhất Thêm bộ lọc thành phố:\nTạo filter cho city_name Filter type: Multi-select dropdown Hiển thị tất cả thành phố theo mặc định Thêm bộ lọc điều kiện thời tiết:\nTạo filter cho weather_main Filter type: Multi-select dropdown 4.3 Áp dụng Styling Dashboard Chọn color theme:\nNhấp Themes (menu trên) Chọn Midnight hoặc Classic Tùy chỉnh màu sắc:\nCho biểu đồ nhiệt độ: Sử dụng gradient xanh-đỏ Cho điều kiện thời tiết: Sử dụng màu riêng biệt cho mỗi điều kiện Thêm text mô tả:\nNhấp + Add → Add text box Thêm insights hoặc hướng dẫn cho người dùng dashboard Bước 5: Trực quan hóa Nâng cao 5.1 Tạo Heat Map cho Nhiệt độ theo Thời gian Thêm visual mới → Heat map Cấu hình: Rows: city_name Columns: data_collection_date Values: temperature_celsius (Average) Tùy chỉnh: Title: \u0026ldquo;Heat Map Nhiệt độ theo Thành phố và Ngày\u0026rdquo; Color scale: Xanh (lạnh) đến Đỏ (nóng) 5.2 Biểu đồ Hướng Gió (Sử dụng Calculated Fields) Tạo calculated field:\nNhấp + Add → Add calculated field Name: wind_direction_category Formula: ifelse(\rwind_direction_deg \u0026gt;= 337.5 OR wind_direction_deg \u0026lt; 22.5, \u0026#34;N\u0026#34;,\rwind_direction_deg \u0026gt;= 22.5 AND wind_direction_deg \u0026lt; 67.5, \u0026#34;NE\u0026#34;,\rwind_direction_deg \u0026gt;= 67.5 AND wind_direction_deg \u0026lt; 112.5, \u0026#34;E\u0026#34;,\rwind_direction_deg \u0026gt;= 112.5 AND wind_direction_deg \u0026lt; 157.5, \u0026#34;SE\u0026#34;,\rwind_direction_deg \u0026gt;= 157.5 AND wind_direction_deg \u0026lt; 202.5, \u0026#34;S\u0026#34;,\rwind_direction_deg \u0026gt;= 202.5 AND wind_direction_deg \u0026lt; 247.5, \u0026#34;SW\u0026#34;,\rwind_direction_deg \u0026gt;= 247.5 AND wind_direction_deg \u0026lt; 292.5, \u0026#34;W\u0026#34;,\r\u0026#34;NW\u0026#34;\r) Tạo biểu đồ hướng gió:\nVisual type: Donut chart Group: wind_direction_category Value: Count of records Title: \u0026ldquo;Phân bố Hướng Gió\u0026rdquo; 5.3 Gauge Mức độ Nghiêm trọng Thời tiết Tạo calculated field:\nName: severity_score Formula: ifelse(\rweather_severity = \u0026#34;nghiêm_trọng\u0026#34;, 4,\rweather_severity = \u0026#34;vừa\u0026#34;, 3,\rweather_severity = \u0026#34;nhẹ\u0026#34;, 2,\r1\r) Thêm gauge visual:\nValue: severity_score (Average) Title: \u0026ldquo;Chỉ số Mức độ Nghiêm trọng Thời tiết\u0026rdquo; Range: 1-4 Bước 6: Xuất bản và Chia sẻ Dashboard 6.1 Xuất bản Dashboard Nhấp Share (góc phải trên) Nhấp Publish dashboard Dashboard name: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Description: \u0026ldquo;Trực quan hóa dữ liệu thời tiết tương tác hiển thị xu hướng nhiệt độ, mẫu thời tiết và so sánh thành phố\u0026rdquo; Nhấp Publish dashboard 6.2 Thiết lập Quyền Chia sẻ Trong dashboard đã xuất bản, nhấp Share Add users or groups: Nhập địa chỉ email của người dùng để chia sẻ Đặt quyền: Viewer hoặc Co-owner Nhấp Share 6.3 Tạo Dashboard Công khai (Tùy chọn) Nhấp Share → Manage dashboard access Kích hoạt Make dashboard public Sao chép URL công khai để chia sẻ bên ngoài Chỉ công khai dashboard nếu dữ liệu thời tiết của bạn không chứa thông tin nhạy cảm.\nBước 7: Thiết lập Làm mới Dữ liệu Tự động 7.1 Cấu hình Làm mới Dataset Đi đến Datasets Chọn weather dataset của bạn Nhấp Refresh → Schedule refresh Cấu hình lịch: Frequency: Daily Time: Sáng sớm (ví dụ: 6 AM) Time zone: Múi giờ địa phương của bạn Lưu lịch 7.2 Giám sát Trạng thái Làm mới Kiểm tra lịch sử làm mới trong Dataset settings Thiết lập thông báo cho làm mới thất bại Giám sát chỉ báo độ tươi của dữ liệu trong dashboard Bước 8: Tối ưu hóa Dashboard và Best Practices 8.1 Tối ưu hóa Hiệu suất Sử dụng SPICE cho hiệu suất tốt hơn:\nImport dữ liệu vào SPICE nếu dataset \u0026lt; 10GB Lập lịch làm mới SPICE thường xuyên Tối ưu hóa truy vấn:\nSử dụng filter để giảm việc quét dữ liệu Tạo bảng tóm tắt trong Athena cho dataset lớn Giới hạn độ phức tạp visual:\nTối đa 15-20 điểm dữ liệu mỗi biểu đồ Sử dụng drill-down cho view chi tiết 8.2 Best Practices Trải nghiệm Người dùng Thứ bậc visual rõ ràng:\nCác metric quan trọng nhất ở trên Các visual liên quan được nhóm lại Màu sắc nhất quán Các yếu tố tương tác:\nCung cấp hướng dẫn filter rõ ràng Sử dụng phạm vi ngày nhất quán Kích hoạt cross-filtering giữa các visual Tính responsive di động:\nKiểm tra dashboard trên thiết bị di động Điều chỉnh layout cho màn hình nhỏ hơn Ưu tiên metric chính cho view di động Khắc phục Các Vấn đề Thường gặp Vấn đề 1: Lỗi \u0026ldquo;Insufficient permissions\u0026rdquo; Giải pháp: Kiểm tra quyền IAM của QuickSight cho truy cập Athena và S3 Xác minh quyền bucket trong cài đặt bảo mật QuickSight Vấn đề 2: Dữ liệu Không Làm mới Giải pháp: Kiểm tra quyền truy vấn Athena Xác minh trạng thái kết nối data source Xem lại error logs của làm mới Vấn đề 3: Hiệu suất Dashboard Chậm Giải pháp: Import dữ liệu vào SPICE Tối ưu hóa truy vấn Athena với filtering phù hợp Giảm số lượng visual mỗi dashboard Phân tích Chi phí Chi phí QuickSight cho module này:\nStandard Edition: $9/tháng mỗi author (dùng thử miễn phí 30 ngày) SPICE storage: $0.25/GB/tháng Enterprise Edition: $18/tháng mỗi author (tính năng nâng cao) Tổng chi phí ước tính: $0-4 trong thời gian dùng thử miễn phí\nBest Practices Bảo mật Kiểm soát Truy cập:\nSử dụng IAM roles cho quyền dịch vụ Triển khai row-level security nếu cần Audit thường xuyên quyền truy cập người dùng Bảo vệ Dữ liệu:\nKích hoạt mã hóa trong transit và at rest Sử dụng VPC endpoints cho kết nối riêng tư Giám sát patterns truy cập dữ liệu Các bước tiếp theo Sau khi hoàn thành module này, bạn sẽ có:\n✅ Dashboard thời tiết tương tác với nhiều trực quan hóa ✅ Làm mới dữ liệu tự động từ ETL pipeline ✅ Insights có thể chia sẻ cho phân tích thời tiết ✅ Hiểu biết về best practices của QuickSight Sắp tới trong Module 6: Học cách dọn dẹp đúng cách các tài nguyên AWS và khám phá các cải tiến nâng cao cho nền tảng phân tích thời tiết của bạn.\nLưu dashboard của bạn dưới dạng template để nhanh chóng tạo dashboard tương tự cho các dataset hoặc thời gian khác nhau.\nQuickSight cung cấp insights được hỗ trợ ML. Hãy thử tính năng ML Insights để tự động khám phá anomalies và trends trong dữ liệu thời tiết của bạn.\nNhớ hủy đăng ký QuickSight sau workshop nếu bạn không có kế hoạch tiếp tục sử dụng để tránh các khoản phí liên tục.\n"
},
{
	"uri": "//localhost:1313/vi/6-cleanup-next-steps/",
	"title": "Dọn dẹp Tài nguyên và Bước tiếp theo",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp Tài nguyên và Bước tiếp theo Chúc mừng bạn đã xây dựng xong pipeline ETL thời tiết serverless hoàn chỉnh! Module cuối cùng này tập trung vào việc dọn dẹp đúng cách tất cả tài nguyên AWS để tránh các khoản phí liên tục và khám phá các cơ hội cải tiến thêm.\nTổng quan Module Sau khi hoàn thành workshop thực hành, việc dọn dẹp tài nguyên là rất quan trọng để ngăn ngừa các khoản phí bất ngờ. Module này cung cấp các thủ tục dọn dẹp toàn diện và gợi ý các bước tiếp theo để mở rộng pipeline thời tiết của bạn.\nMục tiêu Học tập Sau khi hoàn thành module này, bạn sẽ:\nHiểu tầm quan trọng của việc dọn dẹp tài nguyên trong AWS Thực hiện các thủ tục dọn dẹp toàn diện cho tất cả tài nguyên đã tạo Học các chiến lược tối ưu chi phí cho các dự án tương lai Khám phá các tính năng nâng cao và cải tiến cho pipeline của bạn Khám phá các tài nguyên học tập bổ sung Tầm quan trọng của Dọn dẹp Dọn dẹp đúng cách là cần thiết vì:\nQuản lý Chi phí: Ngăn ngừa các khoản phí bất ngờ từ tài nguyên không sử dụng Bảo mật: Loại bỏ các quyền và điểm truy cập không sử dụng Best Practices: Thiết lập thói quen quản lý tài nguyên AWS tốt Vệ sinh Tài khoản: Giữ tài khoản AWS của bạn có tổ chức và dễ quản lý Danh sách Kiểm tra Dọn dẹp Hoàn chỉnh 6.1 Tài nguyên QuickSight Ưu tiên: Cao (Chi phí đăng ký liên tục)\nXóa Dashboard\nLoại bỏ dashboard thời tiết của bạn Xóa mọi phiên bản đã chia sẻ Xóa Dataset\nLoại bỏ dataset dữ liệu thời tiết Xóa mọi dữ liệu cached Hủy Đăng ký (nếu không còn cần thiết)\nHạ cấp từ Author xuống Reader Hủy đăng ký để tránh phí hàng tháng 6.2 Tài nguyên Athena Ưu tiên: Trung bình (Lưu trữ kết quả truy vấn)\nDrop Tables\nDROP TABLE weather_data_processed; DROP TABLE weather_data_raw; Drop Database\nDROP DATABASE weather_analytics; Dọn dẹp Kết quả Truy vấn\nXóa các file kết quả truy vấn Athena từ S3 6.3 S3 Bucket và Dữ liệu Ưu tiên: Cao (Chi phí lưu trữ)\nXóa Raw Data Bucket\naws s3 rm s3://weather-data-raw-[YOUR-ID] --recursive aws s3 rb s3://weather-data-raw-[YOUR-ID] Xóa Processed Data Bucket\naws s3 rm s3://weather-data-processed-[YOUR-ID] --recursive aws s3 rb s3://weather-data-processed-[YOUR-ID] Xóa Athena Results Bucket\naws s3 rm s3://aws-athena-query-results-[ACCOUNT-ID]-[REGION] --recursive 6.4 Lambda Function Ưu tiên: Trung bình (Chi phí liên tục tối thiểu)\nXóa Weather Collector Function\naws lambda delete-function --function-name weather-data-collector Xóa Weather Processor Function\naws lambda delete-function --function-name weather-data-processor Loại bỏ Function Trigger\nXóa EventBridge rules Loại bỏ S3 event notification 6.5 Tài nguyên CloudWatch Ưu tiên: Thấp (Free tier bao gồm hầu hết việc sử dụng)\nXóa Log Group\naws logs delete-log-group --log-group-name /aws/lambda/weather-data-collector aws logs delete-log-group --log-group-name /aws/lambda/weather-data-processor Xóa EventBridge Rule\naws events delete-rule --name weather-collection-schedule Loại bỏ Custom Metric (nếu có)\n6.6 IAM Role và Policy Ưu tiên: Trung bình (Bảo mật và tổ chức)\nDetach Policy từ Role\naws iam detach-role-policy --role-name weather-lambda-role --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess aws iam detach-role-policy --role-name weather-lambda-role --policy-arn arn:aws:iam::aws:policy/CloudWatchLogsFullAccess Xóa IAM Role\naws iam delete-role --role-name weather-lambda-role aws iam delete-role --role-name quicksight-athena-role Loại bỏ Custom Policy (nếu đã tạo)\n6.7 Systems Manager Parameter Ưu tiên: Thấp (Không có chi phí liên tục)\nXóa Parameter Store Value aws ssm delete-parameter --name /weather-etl/openweathermap/api-key Tóm tắt Chi phí Cuối cùng Sau khi hoàn thành dọn dẹp, tổng chi phí workshop ước tính của bạn sẽ là:\nLambda Execution: ~$0.10 (trong Free Tier) S3 Storage: ~$0.20 (dữ liệu tối thiểu được lưu trữ) Athena Queries: ~$0.15 (truy vấn dataset nhỏ) QuickSight: ~$3-4 (nếu sử dụng free trial) Data Transfer: ~$0.05 (tối thiểu) Tổng Chi phí Workshop: Dưới $5 (không bao gồm đăng ký QuickSight)\nBước tiếp theo và Cải tiến Cải tiến Ngay lập tức Thu thập Dữ liệu Nâng cao\nThêm nhiều thành phố và thông số thời tiết Triển khai xử lý lỗi và retry Thêm xác thực và kiểm tra chất lượng dữ liệu Xử lý Nâng cao\nTriển khai tổng hợp dữ liệu và xu hướng Thêm cảnh báo và thông báo thời tiết Bao gồm so sánh thời tiết lịch sử Phân tích Tốt hơn\nTạo truy vấn Athena phức tạp hơn Triển khai dự đoán machine learning Thêm phân tích streaming real-time Cân nhắc Production Cải tiến Bảo mật\nTriển khai IAM policy least-privilege Thêm mã hóa khi lưu trữ và truyền tải Sử dụng AWS Secrets Manager cho API key Giám sát và Cảnh báo\nThiết lập CloudWatch dashboard toàn diện Triển khai SNS notification cho lỗi Thêm custom metric và alarm Tối ưu hóa Hiệu suất\nTối ưu hóa bộ nhớ và timeout setting Lambda Triển khai S3 lifecycle policy Thêm caching layer khi thích hợp Tài nguyên Học tập AWS Documentation: Tìm hiểu sâu hơn về các dịch vụ cụ thể AWS Training: Tham gia các khóa học AWS chính thức về data engineering Community: Tham gia diễn đàn và nhóm người dùng AWS Certification: Cân nhắc AWS Certified Data Analytics specialty Bước Xác minh Sau khi dọn dẹp, xác minh mọi thứ đã được loại bỏ:\nKiểm tra AWS Console\nXem lại từng service console để tìm tài nguyên còn lại Kiểm tra billing dashboard cho các khoản phí liên tục Xác minh CLI\naws s3 ls | grep weather aws lambda list-functions | grep weather aws iam list-roles | grep weather Giám sát Chi phí\nThiết lập billing alert cho các dự án tương lai Xem lại AWS Cost Explorer cho bất kỳ khoản phí bất ngờ nào Kết luận Bạn đã xây dựng thành công và giờ đây dọn dẹp một pipeline ETL thời tiết serverless hoàn chỉnh! Trải nghiệm này cung cấp nền tảng vững chắc để xây dựng các hệ thống xử lý dữ liệu phức tạp hơn.\nĐiểm chính:\nKiến trúc serverless tiết kiệm chi phí và có thể mở rộng Dọn dẹp tài nguyên đúng cách là cần thiết cho quản lý chi phí AWS cung cấp các công cụ mạnh mẽ cho thu thập, xử lý và trực quan hóa dữ liệu Pipeline ETL có thể được xây dựng từng bước và kiểm tra ở mỗi giai đoạn Cảm ơn bạn đã hoàn thành workshop này! Các kỹ năng bạn đã học có thể được áp dụng cho nhiều thách thức data engineering trong thế giới thực.\nWorkshop Hoàn thành - Nhớ xác minh tất cả tài nguyên đã được dọn dẹp để tránh các khoản phí bất ngờ.\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]