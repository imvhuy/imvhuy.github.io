[
{
	"uri": "//localhost:1313/vi/",
	"title": "Xây dựng Pipeline ETL Thời tiết Serverless",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Tổng quan Workshop Trong workshop này, em sẽ tạo một pipeline dữ liệu thời tiết đơn giản nhưng hoàn chỉnh, minh họa các khái niệm ETL cốt lõi sử dụng công nghệ serverless của AWS.\nWorkshop này trình bày cách xây dựng một pipeline ETL đơn giản sử dụng công nghệ serverless của AWS:\nThu thập dữ liệu thời tiết từ OpenWeatherMap API sử dụng AWS Lambda Xử lý và chuyển đổi dữ liệu thô thành định dạng phân tích Lưu trữ dữ liệu trong Amazon S3 cho cả dữ liệu thô và đã xử lý Phân tích dữ liệu sử dụng Amazon Athena với truy vấn SQL Trực quan hóa insights thông qua Amazon QuickSight dashboard Dọn dẹp tài nguyên để tối ưu chi phí Công nghệ sử dụng: Workshop sử dụng AWS Lambda, S3, Athena, QuickSight kết hợp với OpenWeatherMap API để xây dựng pipeline ETL serverless thu thập và phân tích dữ liệu thời tiết. Các phần chính 1. Giới thiệu Tổng quan workshop và mục tiêu học tập Thiết kế kiến trúc và giới thiệu các dịch vụ AWS Yêu cầu tiên quyết và thiết lập 2. Thu thập Dữ liệu Thời tiết với OpenWeatherMap Thiết lập tài khoản OpenWeatherMap API Tạo Lambda function cho thu thập dữ liệu Cấu hình tự động lấy dữ liệu Kiểm tra và giám sát quá trình thu thập 3. Xử lý Dữ liệu Serverless với Lambda Xây dựng Lambda function chuyển đổi dữ liệu Chuyển đổi JSON thời tiết thô sang định dạng phân tích Triển khai xác thực và làm giàu dữ liệu Thiết lập triggers xử lý 4. Phân tích Dữ liệu với Amazon Athena Tạo cấu trúc data lake S3 Thiết lập bảng và schema Athena Viết truy vấn SQL cho phân tích thời tiết Khám phá các mẫu và thông tin chi tiết từ dữ liệu 5. Trực quan hóa Dữ liệu với QuickSight Thiết lập Amazon QuickSight Tạo dashboard thời tiết Xây dựng trực quan hóa tương tác Chia sẻ và xuất bản dashboard 6. Dọn dẹp Tài nguyên và Bước tiếp theo Danh sách kiểm tra dọn dẹp toàn diện Chiến lược tối ưu chi phí Đề xuất cải tiến và mở rộng Tài nguyên học tập bổ sung "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.1-openweathermap-setup/",
	"title": "Thiết lập OpenWeatherMap API",
	"tags": [],
	"description": "",
	"content": "Thiết lập OpenWeatherMap API Trong phần đơn giản hóa này, chúng ta sẽ nhanh chóng thiết lập tài khoản OpenWeatherMap API để thu thập dữ liệu thời tiết cho pipeline của chúng ta.\nBước 1: Đăng ký OpenWeatherMap Tạo tài khoản Truy cập https://openweathermap.org và nhấp vào \u0026ldquo;Sign Up\u0026rdquo; Hoàn thành đăng ký với email của bạn Xác minh email và đăng nhập Bước 2: Lấy API Key Truy cập API Keys Sau khi đăng nhập, đi đến phần \u0026ldquo;API keys\u0026rdquo; Ghi chú API key mặc định hoặc tạo key mới với tên \u0026ldquo;weather-data-collection\u0026rdquo; Gói miễn phí bao gồm 1,000 lệnh gọi API mỗi ngày và 60 lệnh gọi mỗi phút, từng này là đủ cho workshop của tôi.\nBước 3: Kiểm tra API Key Kiểm tra API key của bạn bằng một trong các phương pháp sau:\nPhương pháp trình duyệt:\nhttps://api.openweathermap.org/data/2.5/weather?lat=10.7769\u0026amp;lon=106.7009\u0026amp;appid=YOUR_API_KEY Phương pháp cURL:\ncurl \u0026#34;https://api.openweathermap.org/data/2.5/weather?lat=10.7769\u0026amp;lon=106.7009\u0026amp;appid=YOUR_API_KEY\u0026#34; Bạn sẽ thấy phản hồi JSON với dữ liệu thời tiết hiện tại của Thành phố Hồ Chí Minh.\nCác API Endpoints chính sẽ sử dụng # Thời tiết hiện tại\rhttps://api.openweathermap.org/data/2.5/weather?q={city}\u0026amp;appid={API key}\r# Dự báo 5 ngày (khoảng thời gian 3 giờ)\rhttps://api.openweathermap.org/data/2.5/forecast?q={city}\u0026amp;appid={API key} Các bước tiếp theo Vậy là xong! Bạn đã có API key OpenWeatherMap hoạt động được lưu trữ an toàn trong Parameter Store. Trong phần tiếp theo, chúng ta sẽ tạo một Lambda function để thu thập dữ liệu thời tiết.\nĐã hoàn thành:\nTạo tài khoản OpenWeatherMap Lấy API key Lưu trữ API key trong AWS Parameter Store "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.2-lambda-weather-collector/",
	"title": "Xây dựng Lambda Weather Collector",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo các hàm AWS Lambda để tự động thu thập dữ liệu thời tiết từ OpenWeatherMap API và lưu trữ vào S3. Những hàm này sẽ là lõi của hệ thống thu thập dữ liệu thời tiết.\nBước 1: Tạo IAM Role cho Lambda 1.1 Tạo Lambda Execution Role Điều hướng đến IAM Console\nAWS Console → IAM → Roles Click \u0026ldquo;Create role\u0026rdquo; Chọn Trusted Entity\nService: Lambda Click \u0026ldquo;Next\u0026rdquo; Cấu hình Role\nRole Name: WeatherCollectorLambdaRole Description: Execution role for weather data collection Lambda functions 1.2 Gắn AWS Managed Policies AWS Managed Policy là gì?\nAWS đã tạo sẵn nhiều policies phổ biến mà chúng ta có thể \u0026ldquo;gắn\u0026rdquo; (attach) vào Role thay vì tự viết từ đầu. Điều này tiết kiệm thời gian và đảm bảo bảo mật.\nCách gắn các policies trong AWS Console:\nKhi tạo Role WeatherCollectorLambdaRole, ở bước \u0026ldquo;Add permissions\u0026rdquo; Tab \u0026ldquo;Permissions\u0026rdquo; → Click \u0026ldquo;Attach policies directly\u0026rdquo; Tìm kiếm và chọn từng policy sau: ✅ Gõ AWSLambdaBasicExecutionRole → tick chọn ✅ Gõ AmazonS3FullAccess → tick chọn ✅ Gõ AmazonSSMReadOnlyAccess → tick chọn ✅ Gõ CloudWatchAgentServerPolicy → tick chọn Click \u0026ldquo;Add Permissions\u0026rdquo; và hoàn thành tạo role Kết quả: Role WeatherCollectorLambdaRole sẽ có 4 managed policies\nPolicy này cho phép Lambda:\nTạo CloudWatch Log Group để ghi logs Ghi logs vào CloudWatch khi function chạy Basic networking để Lambda hoạt động Bước 2: Tạo S3 Bucket cho Dữ liệu Thời tiết 2.1 Tạo Weather Data Bucket Điều hướng đến S3 Console\nAWS Console → S3 → Create bucket Cấu hình Bucket\nBucket Name: weather-data-{your-account-id} (thay thế bằng AWS account ID của bạn) Region: us-east-1 (hoặc region ưa thích của bạn) Block Public Access: Giữ tất cả cài đặt được bật (khuyến nghị) Cấu trúc Bucket weather-data-123456789012/\r├── raw/\r├── current-weather/\r│ └── year=2025/month=01/day=03/hour=10/\r└── year=2025/month=01/day=03/ Bước 3: Lambda Function cho Current Weather 3.1 Tạo Current Weather Function Điều hướng đến Lambda Console\nAWS Console → Lambda → Create function Cấu hình Function\nFunction Name: weather-current-collector Runtime: Python 3.11 Architecture: x86_64 Execution Role: Use existing role → WeatherCollectorLambdaRole 3.2 Thêm Function Code Quan trọng: Trước khi copy code, bạn cần thay đổi API key. Ở dòng OPENWEATHER_API_KEY = 'API Key\n→ Thay bằng API key của bạn từ OpenWeatherMap\nTrong Lambda Console → Scroll xuống Code source Xóa toàn bộ code mặc định trong file lambda_function.py Copy và paste code sau: File: lambda_function.py\nimport json import boto3 import urllib.request import urllib.parse import urllib.error import os from datetime import datetime, timezone from typing import Dict, List, Optional import logging # Logging configuration logger = logging.getLogger() logger.setLevel(logging.INFO) # AWS clients with retry configuration s3_client = boto3.client(\u0026#39;s3\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) # Configuration BUCKET_NAME = os.environ.get(\u0026#39;WEATHER_BUCKET_NAME\u0026#39;) OPENWEATHER_API_KEY = \u0026#39;your_api_key\u0026#39; # Replace with your actual API key # Target cities for weather data collection CITIES = [ {\u0026#34;name\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;lat\u0026#34;: 10.7769, \u0026#34;lon\u0026#34;: 106.7009}, {\u0026#34;name\u0026#34;: \u0026#34;Hanoi\u0026#34;, \u0026#34;lat\u0026#34;: 21.0285, \u0026#34;lon\u0026#34;: 105.8542}, {\u0026#34;name\u0026#34;: \u0026#34;Danang\u0026#34;, \u0026#34;lat\u0026#34;: 16.0471, \u0026#34;lon\u0026#34;: 108.2068}, {\u0026#34;name\u0026#34;: \u0026#34;GiaLai\u0026#34;, \u0026#34;lat\u0026#34;: 13.9833, \u0026#34;lon\u0026#34;: 108.0000}, {\u0026#34;name\u0026#34;: \u0026#34;CanTho\u0026#34;, \u0026#34;lat\u0026#34;: 10.0452, \u0026#34;lon\u0026#34;: 105.7469}, {\u0026#34;name\u0026#34;: \u0026#34;Hue\u0026#34;, \u0026#34;lat\u0026#34;: 16.4637, \u0026#34;lon\u0026#34;: 107.5909} ] def fetch_current_weather(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Fetch current weather data for a city.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/weather\u0026#34; params = { \u0026#39;lat\u0026#39;: str(city[\u0026#39;lat\u0026#39;]), \u0026#39;lon\u0026#39;: str(city[\u0026#39;lon\u0026#39;]), \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39;, \u0026#39;lang\u0026#39;: \u0026#39;en\u0026#39; } try: # Build URL with parameters query_string = urllib.parse.urlencode(params) full_url = f\u0026#34;{base_url}?{query_string}\u0026#34; # Make HTTP request with urllib.request.urlopen(full_url, timeout=30) as response: if response.status != 200: logger.error(f\u0026#34;HTTP error {response.status} for {city[\u0026#39;name\u0026#39;]}\u0026#34;) return None response_data = response.read().decode(\u0026#39;utf-8\u0026#39;) data = json.loads(response_data) # Add metadata data[\u0026#39;collection_timestamp\u0026#39;] = datetime.now(timezone.utc).isoformat() data[\u0026#39;city_metadata\u0026#39;] = city return data except urllib.error.URLError as e: logger.error(f\u0026#34;URL error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except urllib.error.HTTPError as e: logger.error(f\u0026#34;HTTP error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except json.JSONDecodeError as e: logger.error(f\u0026#34;JSON decode error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except Exception as e: logger.error(f\u0026#34;Unexpected error for {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None def save_to_s3(data: Dict, city_name: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Save weather data to S3.\u0026#34;\u0026#34;\u0026#34; try: if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable not set\u0026#34;) return False now = datetime.now(timezone.utc) # Create S3 key with time partitioning (Hive format for analytics) city_safe = city_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;) key = f\u0026#34;raw/current-weather/year={now.year}/month={now.month:02d}/day={now.day:02d}/hour={now.hour:02d}/{city_safe}_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; # Prepare body data with UTF-8 encoding json_data = json.dumps(data, ensure_ascii=False, indent=2) body_bytes = json_data.encode(\u0026#39;utf-8\u0026#39;) # Upload file with optimized S3 parameters s3_client.put_object( Bucket=BUCKET_NAME, Key=key, Body=body_bytes, ContentType=\u0026#39;application/json; charset=utf-8\u0026#39;, ContentEncoding=\u0026#39;utf-8\u0026#39;, Metadata={ \u0026#39;city\u0026#39;: city_name, \u0026#39;collection-time\u0026#39;: now.isoformat(), \u0026#39;data-type\u0026#39;: \u0026#39;current-weather\u0026#39;, \u0026#39;source\u0026#39;: \u0026#39;openweathermap\u0026#39; }, ServerSideEncryption=\u0026#39;AES256\u0026#39;, # Server-side encryption StorageClass=\u0026#39;STANDARD_IA\u0026#39; # Save 40% storage cost compared to STANDARD ) logger.info(f\u0026#34;Saved data for {city_name} at s3://{BUCKET_NAME}/{key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;S3 save error for {city_name}: {e}\u0026#34;) return False def send_metrics(metric_name: str, value: float, unit: str = \u0026#39;Count\u0026#39;): \u0026#34;\u0026#34;\u0026#34;Send custom metrics to CloudWatch.\u0026#34;\u0026#34;\u0026#34; try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: value, \u0026#39;Unit\u0026#39;: unit, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Metric send error {metric_name}: {e}\u0026#34;) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Main handler for Lambda function.\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Starting weather data collection: {json.dumps(event)}\u0026#34;) # Basic validation if not BUCKET_NAME: logger.error(\u0026#34;WEATHER_BUCKET_NAME environment variable is required\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;WEATHER_BUCKET_NAME environment variable not set\u0026#39; }) } successful_collections = 0 failed_collections = 0 results = [] try: # API key validation if not OPENWEATHER_API_KEY or OPENWEATHER_API_KEY == \u0026#39;your_api_key_here\u0026#39;: logger.error(\u0026#34;OpenWeatherMap API key is not configured\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;OpenWeatherMap API key not set\u0026#39; }) } # Collect data for each city for city in CITIES: logger.info(f\u0026#34;Collecting data for {city[\u0026#39;name\u0026#39;]}\u0026#34;) # Fetch weather data weather_data = fetch_current_weather(city, OPENWEATHER_API_KEY) if weather_data: # Save to S3 if save_to_s3(weather_data, city[\u0026#39;name\u0026#39;]): successful_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;temperature\u0026#39;: weather_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;temp\u0026#39;), \u0026#39;description\u0026#39;: weather_data.get(\u0026#39;weather\u0026#39;, [{}])[0].get(\u0026#39;description\u0026#39;) }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;S3 save failed\u0026#39; }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;API fetch failed\u0026#39; }) # Send metrics (batched to save cost) if successful_collections \u0026gt; 0 or failed_collections \u0026gt; 0: try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;SuccessfulCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;FailedCollections\u0026#39;, \u0026#39;Value\u0026#39;: failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) }, { \u0026#39;MetricName\u0026#39;: \u0026#39;TotalCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections + failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Metrics send error: {e}\u0026#34;) # Log results logger.info(f\u0026#34;Collection completed - Success: {successful_collections}, Failed: {failed_collections}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Weather data collection completed\u0026#39;, \u0026#39;successful_collections\u0026#39;: successful_collections, \u0026#39;failed_collections\u0026#39;: failed_collections, \u0026#39;results\u0026#39;: results }) } except Exception as e: logger.error(f\u0026#34;Lambda handler error: {e}\u0026#34;) send_metrics(\u0026#39;LambdaErrors\u0026#39;, 1) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal error\u0026#39;, \u0026#39;message\u0026#39;: str(e) }) } Giải thích code\nImport libraries: Các thư viện cần thiết cho HTTP requests, AWS services, logging Cấu hình API key: Lưu OpenWeatherMap API key (nhớ thay bằng key của bạn!) Danh sách thành phố: 6 thành phố Việt Nam với tọa độ GPS chính xác fetch_current_weather(): Gọi API để lấy thời tiết hiện tại save_to_s3(): Lưu dữ liệu JSON vào S3 với cấu trúc partition thông minh send_metrics(): Gửi metrics tới CloudWatch để monitoring lambda_handler(): Hàm chính - xử lý từng thành phố và trả về kết quả Luồng hoạt động: Lambda được trigger → Kiểm tra cấu hình → Lặp qua 6 thành phố → Gọi API → Lưu vào S3 → Gửi metrics → Trả về kết quả\n3.3 Cấu hình Environment Variables Bước quan trọng: Lambda cần biết tên S3 bucket để lưu dữ liệu.\nTrong Lambda Console → Configuration tab → Environment variables Click \u0026ldquo;Edit\u0026rdquo; → Add environment variable: Key: WEATHER_BUCKET_NAME Value: weather-data-{your-account-id} (thay {your-account-id} bằng account ID thật) Account ID có thể tìm ở góc phải trên AWS Console (dãy số 12 chữ số)\n3.4 Test Lambda Function Bây giờ hãy test xem function hoạt động không!\nClick \u0026ldquo;Deploy\u0026rdquo; để lưu code và cấu hình Tạo test event: Test tab → Create new event Event name: manual-test Event JSON: {} (để trống vì không cần input) Click \u0026ldquo;Test\u0026rdquo; và đợi kết quả Kết quả mong đợi:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Weather data collection completed\u0026#34;, \u0026#34;successful_collections\u0026#34;: 6, \u0026#34;failed_collections\u0026#34;: 0, \u0026#34;results\u0026#34;: [ { \u0026#34;city\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;temperature\u0026#34;: 28.5, \u0026#34;description\u0026#34;: \u0026#34;broken clouds\u0026#34; } // ... 5 thành phố khác ] } } 4. Kiểm tra S3: Vào S3 bucket và xem có file JSON mới không\nNếu test thành công, bạn đã có:\nLambda function hoạt động Dữ liệu thời tiết được lưu vào S3 CloudWatch metrics được gửi Error handling hoạt động Lambda đã sẵn sàng để tự động chạy theo schedule\nNếu test thất bại, kiểm tra:\nCloudWatch Logs: Lambda → Monitoring → View logs → Xem lỗi cụ thể API Key: Đảm bảo key OpenWeatherMap đúng Environment variable: WEATHER_BUCKET_NAME đúng format IAM Role: Đảm bảo role có đủ permissions S3 Bucket: Bucket đã được tạo chưa 4.1 Test Lambda Function Bây giờ hãy test xem function hoạt động không!\nClick \u0026ldquo;Deploy\u0026rdquo; để lưu code và cấu hình Tạo test event: Test tab → Create new event Event name: manual-test Event JSON: {} (để trống vì không cần input) Click \u0026ldquo;Test\u0026rdquo; và đợi kết quả Kết quả mong đợi:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: { \u0026#34;message\u0026#34;: \u0026#34;Weather data collection completed\u0026#34;, \u0026#34;successful_collections\u0026#34;: 6, \u0026#34;failed_collections\u0026#34;: 0, \u0026#34;results\u0026#34;: [ { \u0026#34;city\u0026#34;: \u0026#34;HoChiMinh\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;temperature\u0026#34;: 28.5, \u0026#34;description\u0026#34;: \u0026#34;broken clouds\u0026#34; } // ... 5 thành phố khác ] } } 4. Kiểm tra S3: Vào S3 bucket và xem có file JSON mới không\nNếu test thành công, bạn đã có:\nLambda function hoạt động Dữ liệu thời tiết được lưu vào S3 CloudWatch metrics được gửi Error handling hoạt động Lambda đã sẵn sàng để tự động chạy theo schedule\nNếu test thất bại, kiểm tra:\nCloudWatch Logs: Lambda → Monitoring → View logs → Xem lỗi cụ thể API Key: Đảm bảo key OpenWeatherMap đúng Environment variable: WEATHER_BUCKET_NAME đúng format IAM Role: Đảm bảo role có đủ permissions S3 Bucket: Bucket đã được tạo chưa Tóm tắt Trong phần này, chúng ta đã:\n✅ Tạo IAM roles và policies cho Lambda function ✅ Thiết lập S3 bucket với cấu trúc partition thông minh ✅ Xây dựng Lambda function thu thập thời tiết hiện tại ✅ Cấu hình error handling và CloudWatch metrics ✅ Test function thành công với 6 thành phố Việt Nam Kết quả đạt được:\nLambda function weather-current-collector hoạt động ổn định Dữ liệu thời tiết được lưu vào S3 với format analytics-ready Monitoring và metrics đầy đủ qua CloudWatch Error handling robust với retry mechanism Tiếp theo: Trong module 2.3, chúng ta sẽ thiết lập automated scheduling với EventBridge để chạy function này theo lịch trình tự động.\n"
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.3-automated-scheduling/",
	"title": "Lập lịch Tự động với EventBridge",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ thiết lập lập lịch tự động cho việc thu thập dữ liệu thời tiết bằng Amazon EventBridge (trước đây gọi là CloudWatch Events). Điều này giúp các Lambda functions chạy theo lịch trình đều đặn mà không cần can thiệp thủ công.\nEventBridge giống như \u0026ldquo;đồng hồ báo thức thông minh\u0026rdquo; của AWS:\nChạy đúng giờ: Trigger Lambda functions theo lịch trình cụ thể Chính xác: Chạy đúng thời gian đã định (ví dụ: mỗi giờ, mỗi ngày) Tự động: Không cần can thiệp thủ công Tiết kiệm: Chỉ chạy khi cần, không tốn tài nguyên khi không hoạt động Tại sao cần Scheduling?\nThu thập dữ liệu đều đặn 24/7 Dữ liệu luôn fresh và cập nhật Tự động hóa hoàn toàn Không phụ thuộc vào người vận hành Lịch trình đề xuất:\nCurrent Weather: Mỗi giờ (24 lần/ngày) - Để theo dõi thời tiết real-time Bước 1: Thiết lập EventBridge Rule cho Current Weather Bước này sẽ tạo lịch trình chạy Lambda mỗi giờ để thu thập thời tiết hiện tại.\nVí dụ: Function sẽ chạy lúc 00:00, 01:00, 02:00\u0026hellip; 23:00 hàng ngày\n1.1 Truy cập EventBridge Console Vào AWS Console → Tìm \u0026ldquo;EventBridge\u0026rdquo; (hoặc \u0026ldquo;CloudWatch\u0026rdquo; → \u0026ldquo;Events\u0026rdquo;) Click \u0026ldquo;EventBridge\u0026rdquo; → \u0026ldquo;Rules\u0026rdquo; ở menu bên trái Chọn Region phù hợp (ví dụ: us-east-1) 1.2 Tạo Rule cho Current Weather Click \u0026ldquo;Create rule\u0026rdquo; Bước 1 - Define rule detail: Name: weather-current-hourly Description: Thu thập dữ liệu thời tiết hiện tại mỗi giờ cho 6 thành phố Việt Nam Event bus: default Rule type: Schedule Click \u0026ldquo;Continue to create rule\u0026rdquo; 1.3 Cấu hình Schedule Pattern Schedule pattern: Chọn \u0026ldquo;A schedule that runs at a regular rate, such as every 10 minutes\u0026rdquo;\nRate expression: Chọn \u0026ldquo;rate\u0026rdquo; và nhập:\n1 hour Các lựa chọn Schedule Pattern:\nRate expression:\nrate(1 hour) = mỗi giờ rate(30 minutes) = mỗi 30 phút rate(1 day) = mỗi ngày Cron expression (nâng cao):\ncron(0 * * * ? *) = mỗi giờ đúng phút 0 cron(0 8,12,16,20 * * ? *) = 4 lần/ngày (8h, 12h, 16h, 20h) cron(0 0 * * ? *) = mỗi ngày lúc 00:00 Click \u0026ldquo;Next\u0026rdquo; 1.4 Select Target (Lambda Function) Target types: Chọn \u0026ldquo;AWS service\u0026rdquo;\nSelect a service: Chọn \u0026ldquo;Lambda function\u0026rdquo;\nFunction: Chọn weather-current-collector (function đã tạo ở bước trước)\nAdditional settings: Configure target input: Chọn \u0026ldquo;Constant (JSON text)\u0026rdquo; JSON text: { \u0026#34;source\u0026#34;: \u0026#34;eventbridge-schedule\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Scheduled Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;collection_type\u0026#34;: \u0026#34;current_weather\u0026#34;, \u0026#34;scheduled_time\u0026#34;: \u0026#34;hourly\u0026#34;, \u0026#34;trigger_source\u0026#34;: \u0026#34;eventbridge\u0026#34; } } JSON input này sẽ:\nCho Lambda biết đây là scheduled event (không phải manual test) Giúp phân biệt current weather Cung cấp metadata để logging và monitoring Click \u0026ldquo;Next\u0026rdquo; 1.5 Configure tags và Review Tags (Optional):\nKey: Project → Value: WeatherETL Key: Environment → Value: Production Review tất cả cài đặt:\n✅ Name: weather-current-hourly ✅ Schedule: rate(1 hour) ✅ Target: weather-current-collector ✅ State: Enabled Click \u0026ldquo;Create rule\u0026rdquo;\nRule cho current weather đã được tạo thành công.\nRule sẽ trigger Lambda function weather-current-collector mỗi giờ để thu thập dữ liệu thời tiết hiện tại.\nHoàn thành EventBridge Setup!\nEventBridge rule đã được tạo và sẽ tự động trigger Lambda function mỗi giờ:\n⏰ Schedule: Mỗi giờ (24 lần/ngày) 🎯 Target: weather-current-collector Lambda function 📊 Data: Thu thập thời tiết hiện tại cho 6 thành phố 🔄 Status: Enabled và ready to run Workflow tự động: EventBridge → weather-current-collector → S3 Storage → CloudWatch Metrics\nBước 3: Thiết lập Monitoring với CloudWatch Alarms Tại sao cần Monitoring?\nKhi Lambda functions chạy tự động 24/7, bạn cần biết ngay khi có vấn đề:\nLambda function bị lỗi Function chạy quá lâu Tỷ lệ thành công thấp Chi phí tăng bất thường 3.1 Tạo SNS Topic cho Email Alerts Trước tiên, tạo SNS Topic để nhận email thông báo khi có lỗi:\nAWS Console → \u0026ldquo;SNS\u0026rdquo; → \u0026ldquo;Topics\u0026rdquo; → \u0026ldquo;Create topic\u0026rdquo; Topic configuration:\nType: Standard Name: weather-etl-alerts Display name: Weather ETL Alerts Create topic\nTạo Subscription:\nProtocol: Email Endpoint: your-email@example.com (thay bằng email của bạn) Confirm subscription qua email 3.2 Tạo CloudWatch Alarm cho Lambda Errors AWS Console → \u0026ldquo;CloudWatch\u0026rdquo; → \u0026ldquo;Alarms\u0026rdquo; → \u0026ldquo;Create alarm\u0026rdquo;\nSelect metric:\nNamespace: AWS/Lambda Metric name: Errors Dimensions: FunctionName: weather-current-collector Specify metric and conditions:\nStatistic: Sum Period: 5 minutes Threshold type: Static Condition: Greater/Equal Threshold value: 1 (alert khi có ≥1 error trong 5 phút) Configure actions:\nAlarm state trigger: In alarm SNS topic: weather-etl-alerts Add name and description:\nAlarm name: WeatherCurrentCollector-Errors Description: Alert khi Lambda weather-current-collector có lỗi Create alarm Quan trọng: Hãy đảm bảo tất cả hoạt động đúng trước khi để nó tự động chạy\nTối ưu hóa Chi phí và Hiệu suất 1. Smart Scheduling Strategy Thay vì chạy cùng frequency 24/7, có thể tối ưu:\nGiờ cao điểm (6:00-23:00): Mỗi giờ Giờ thấp điểm (23:00-6:00): Mỗi 2 giờ Cuối tuần: Mỗi 2 giờ (ít người quan tâm thời tiết công việc) Tạo multiple rules với different schedules:\nRule 1 - Peak Hours:\ncron(0 6-23 * * ? *) Rule 2 - Off-peak Hours:\ncron(0 0,2,4 * * ? *) 2. Regional Optimization Nếu cần collect data cho multiple regions:\n{ \u0026#34;source\u0026#34;: \u0026#34;eventbridge-schedule\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;region\u0026#34;: \u0026#34;southeast-asia\u0026#34;, \u0026#34;cities\u0026#34;: [\u0026#34;HoChiMinh\u0026#34;, \u0026#34;Hanoi\u0026#34;, \u0026#34;Bangkok\u0026#34;], \u0026#34;priority\u0026#34;: \u0026#34;high\u0026#34; } } 3. Error Recovery Strategy Thêm Dead Letter Queue cho Lambda:\nLambda function configuration → \u0026ldquo;Asynchronous invocation\u0026rdquo; Dead letter queue: Enable với SQS queue Maximum age of event: 6 hours Retry attempts: 2 Tóm tắt Trong phần này, chúng ta đã hoàn thành:\n✅ Thiết lập EventBridge Rule:\n⏰ Current weather collection: Mỗi giờ (24 lần/ngày) 🎯 Target: weather-current-collector Lambda function 📊 Thu thập dữ liệu 6 thành phố Việt Nam tự động ✅ CloudWatch Monitoring:\nSNS topic cho email alerts CloudWatch alarms cho Lambda errors và duration Metrics tracking cho system health ✅ Testing và Verification:\nManual testing EventBridge rules Verify S3 data collection hoạt động Check CloudWatch logs và metrics 🎉 Kết quả đạt được:\nHệ thống thu thập dữ liệu thời tiết tự động 24/7 Monitoring và alerting đầy đủ Data pipeline reliable và scalable Sẵn sàng cho data processing ở Module 3 Tiếp theo: Trong module 2.4, chúng ta sẽ thiết lập testing và validation toàn diện để đảm bảo data quality và system reliability.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduction/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Mục tiêu Xây dựng hệ thống thu thập dữ liệu serverless sử dụng AWS Lambda Triển khai quy trình chuyển đổi và xử lý dữ liệu Lưu trữ và truy vấn dữ liệu sử dụng Amazon S3 và Athena Tạo trực quan hóa với Amazon QuickSight Áp dụng các best practices của AWS cho tối ưu chi phí và dọn dẹp tài nguyên Tổng quan Kiến trúc Pipeline ETL thời tiết của chúng ta tuân theo kiến trúc serverless đơn giản này: Các thành phần chính:\nNguồn dữ liệu: OpenWeatherMap API cho dữ liệu thời tiết thời gian thực Thu thập: AWS Lambda function để lấy dữ liệu thời tiết Lưu trữ: Amazon S3 cho cả dữ liệu thô và đã xử lý Xử lý: AWS Lambda cho chuyển đổi dữ liệu Phân tích: Amazon Athena cho truy vấn SQL Trực quan hóa: Amazon QuickSight cho dashboard Yêu cầu Tiên quyết Trước khi bắt đầu workshop này, hãy đảm bảo bạn có:\nTài khoản AWS với quyền truy cập quản trị Hiểu biết cơ bản về AWS console Hiểu biết về các khái niệm lập trình cơ bản Tài khoản OpenWeatherMap (tier miễn phí là đủ, ở bài workshop này em sử dụng Developer plan) "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/",
	"title": "Thu thập Dữ liệu Thời tiết với OpenWeatherMap",
	"tags": [],
	"description": "",
	"content": "Trong phần này, ta sẽ học cách thiết lập thu thập dữ liệu thời tiết tự động bằng OpenWeatherMap API và AWS Lambda. Đây là nền tảng của pipeline ETL phân tích thời tiết, nơi chúng ta sẽ xây dựng hệ thống thu thập dữ liệu serverless đáng tin cậy.\n2.1 OpenWeatherMap Setup Thiết lập API và Credentials\nThiết lập tài khoản OpenWeatherMap, lấy API key, và cấu hình Systems Manager Parameter Store để lưu trữ credentials một cách bảo mật. Bạn sẽ học cách quản lý API keys và test connectivity.\n2.2 Lambda Weather Collector Xây dựng Functions Thu thập Dữ liệu\nTạo các Lambda functions để thu thập dữ liệu thời tiết hiện tại và dự báo từ OpenWeatherMap API. Bao gồm IAM roles, S3 bucket setup, và function code với error handling.\n2.3 Automated Scheduling Lập lịch Tự động với CloudWatch Events\nThiết lập CloudWatch Events để chạy các Lambda functions theo lịch trình tự động. Cấu hình monitoring, alarms, và notifications để đảm bảo hệ thống chạy ổn định.\n2.4 Testing và Monitoring Testing và Monitoring Toàn diện\nThiết lập testing strategy bao gồm manual testing, data quality validation, performance testing, và automated health checks. Tạo dashboard để monitor hệ thống.\nKiến trúc Tổng quan graph TD\rA[OpenWeatherMap API\u0026lt;br/\u0026gt;Current Weather Data] --\u0026gt; B[Lambda Function\u0026lt;br/\u0026gt;weather-current-collector]\rC[EventBridge Rule\u0026lt;br/\u0026gt;Every Hour] --\u0026gt; B\rB --\u0026gt; D[S3 Raw Storage\u0026lt;br/\u0026gt;current-weather/]\rB --\u0026gt; E[CloudWatch Logs\u0026lt;br/\u0026gt;Monitoring]\rB --\u0026gt; F[CloudWatch Metrics\u0026lt;br/\u0026gt;Success/Error Counts]\rG[6 Vietnamese Cities\u0026lt;br/\u0026gt;HCM, Hanoi, Danang\u0026lt;br/\u0026gt;GiaLai, CanTho, Hue] --\u0026gt; A\rstyle A fill:#e1f5fe,stroke:#01579b,stroke-width:2px\rstyle B fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle C fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\rstyle D fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\rstyle E fill:#fff3e0,stroke:#ef6c00,stroke-width:2px\rstyle F fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\rstyle G fill:#f1f8e9,stroke:#558b2f,stroke-width:2px Loại Dữ liệu Thu thập Thu thập dữ liệu thời tiết hiện tại cho 6 tỉnh thành Việt Nam:\n🏙️ Thành phố chính: Hà Nội, Hồ Chí Minh, Đà Nẵng 🌾 Khu vực nông nghiệp: Gia Lai, Cần Thơ 🏛️ Di sản văn hóa: Huế 📊 Dữ liệu thu thập:\nNhiệt độ (°C, °F), độ ẩm, áp suất Tốc độ gió, hướng gió, mây che phủ Mô tả thời tiết, weather condition Metadata: timestamp, location, collection info Lịch trình Thu thập ⏰ Thời tiết Hiện tại: Mỗi giờ (24 lần/ngày × 6 thành phố = 144 data points/ngày)\nƯớc tính Chi phí Dịch vụ Sử dụng Chi phí OpenWeatherMap API 144 calls/ngày Free Lambda Executions 720 invocations/tháng Free Tier S3 Storage 500 MB dữ liệu Free Tier CloudWatch Logs 2 GB logs $1.00 Tổng ~$1.00/tháng OpenWeatherMap cung cấp 1,000 lời gọi API miễn phí mỗi ngày, đủ cho workshop này.\nKết quả Mong đợi Sau khi hoàn thành module này, bạn sẽ có:\nHệ thống thu thập dữ liệu thời tiết serverless hoạt động 24/7 Dữ liệu thời tiết được lưu trữ có cấu trúc trong S3 Monitoring và alerting system đầy đủ Kiến thức về AWS Lambda, CloudWatch Events, và S3 integration Bắt đầu Sẵn sàng xây dựng hệ thống thu thập dữ liệu thời tiết? Bắt đầu với 2.1 OpenWeatherMap Setup để thiết lập API và credentials.\n"
},
{
	"uri": "//localhost:1313/vi/3-serverless-processing-lambda/",
	"title": "Xử lý và Chuyển đổi Dữ liệu Serverless",
	"tags": [],
	"description": "",
	"content": "Trong module này, chúng ta sẽ xây dựng Lambda functions để xử lý và chuyển đổi dữ liệu thời tiết thô từ module 2 thành định dạng phù hợp cho phân tích. Đây là bước \u0026ldquo;Transform\u0026rdquo; trong pipeline ETL, giúp làm sạch, chuẩn hóa và tạo ra các metrics có ý nghĩa từ dữ liệu thô.\nDữ liệu thô từ OpenWeatherMap API có nhiều vấn đề:\nCấu trúc phức tạp: Nested JSON khó query Đơn vị không thống nhất: Kelvin, m/s, Pascal\u0026hellip; Dữ liệu dư thừa: Nhiều fields không cần thiết Thiếu insights: Không có derived metrics Vì vậy cần phải processing để có:\nCấu trúc phẳng: Dễ query với SQL Đơn vị thống nhất: Celsius, km/h, %\u0026hellip; Dữ liệu sạch: Chỉ giữ thông tin cần thiết Rich insights: Heat index, comfort level, weather severity\u0026hellip; Luồng xử lý:\nRaw data từ Module 2 được lưu vào S3 S3 Event trigger Lambda processor Lambda transform data và lưu vào processed bucket Processed data sẵn sàng cho analytics (Module 4) Bước 1: Tạo S3 Bucket cho Processed Data Tại sao cần chia bucket?\nTách biệt concerns: Raw vs Processed data Security: Khác nhau về access permissions Cost optimization: Khác nhau về storage class Analytics: Processed data tối ưu cho query 1.1 Tạo Processed Data Bucket AWS Console → S3 → Create bucket\nBucket configuration:\nBucket name: weather-processed-{your-account-id} Region: ap-southeast-1 (same as raw bucket) Block all public access: Enabled Bucket versioning: Disable Default encryption: SSE-S3 Create bucket 1.2 Tạo Folder Structure Tạo folder structure tối ưu cho analytics:\nweather-processed-{account-id}/\r├── current-weather/\r├── year=2025/\r│ ├── month=01/\r│ │ ├── day=03/\r│ │ │ ├── hour=00/\r│ │ │ │ ├── hcm_20250103_000000.json\r│ │ │ │ ├── hanoi_20250103_000000.json\r│ │ │ │ └── ...\r│ │ │ └── hour=01/\r│ │ └── day=04/\r│ └── month=02/\r└── year=2026/ Ở đây sẽ dùng Hive-style partitioning vì:\nAthena optimization: Query performance tốt hơn Cost savings: Chỉ scan data cần thiết Easy filtering: Filter theo year/month/day/hour Scalability: Xử lý các bộ dữ liệu lớn một cách hiệu quả Bước 2: Tạo Lambda Function cho Data Processing 2.1 Tạo Lambda Function AWS Console → Lambda → Create function\nFunction configuration:\nFunction name: weather-data-processor Runtime: Python 3.11 Architecture: x86_64 Execution role: WeatherCollectorLambdaRole Advanced settings: Memory: 512 MB Timeout: 5 minutes Environment variables: PROCESSED_BUCKET_NAME: weather-processed-{your-account-id} LOG_LEVEL: INFO 2.2 Lambda Function Code Thay thế code mặc định bằng code sau:\nimport json import boto3 import datetime import logging from decimal import Decimal import os from urllib.parse import unquote_plus # Logging configuration logger = logging.getLogger() logger.setLevel(logging.INFO) # AWS clients with retry configuration s3_client = boto3.client(\u0026#39;s3\u0026#39;, config=boto3.session.Config( retries={\u0026#39;max_attempts\u0026#39;: 3, \u0026#39;mode\u0026#39;: \u0026#39;adaptive\u0026#39;} )) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; Main Lambda handler for weather data processing \u0026#34;\u0026#34;\u0026#34; try: # Environment variable validation processed_bucket = os.environ.get(\u0026#39;PROCESSED_BUCKET_NAME\u0026#39;) if not processed_bucket: logger.error(\u0026#34;PROCESSED_BUCKET_NAME environment variable is required\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Configuration error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;PROCESSED_BUCKET_NAME environment variable not set\u0026#39; }) } processed_count = 0 # Process each S3 event record for record in event[\u0026#39;Records\u0026#39;]: try: # Extract bucket and key from event source_bucket = record[\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;] source_key_encoded = record[\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;] source_key = unquote_plus(source_key_encoded) logger.info(f\u0026#34;Processing file: {source_key} from bucket: {source_bucket}\u0026#34;) if source_key_encoded != source_key: logger.debug(f\u0026#34;URL decoded key from {source_key_encoded} to {source_key}\u0026#34;) # Get raw weather data from S3 response = s3_client.get_object(Bucket=source_bucket, Key=source_key) raw_data = json.loads(response[\u0026#39;Body\u0026#39;].read().decode(\u0026#39;utf-8\u0026#39;)) # Transform weather data processed_data = transform_weather_data(raw_data) # Create key for processed file processed_key = source_key.replace(\u0026#39;raw/\u0026#39;, \u0026#39;processed/\u0026#39;).replace(\u0026#39;.json\u0026#39;, \u0026#39;.jsonl\u0026#39;) # Save processed data to S3 dưới dạng NDJSON (jsonl) if isinstance(processed_data, list): jsonl_content = \u0026#39;\\n\u0026#39;.join(json.dumps(obj, default=decimal_default) for obj in processed_data) else: jsonl_content = json.dumps(processed_data, default=decimal_default) s3_client.put_object( Bucket=processed_bucket, Key=processed_key, Body=jsonl_content, ContentType=\u0026#39;application/jsonl; charset=utf-8\u0026#39;, ServerSideEncryption=\u0026#39;AES256\u0026#39; ) processed_count += 1 logger.info(f\u0026#34;Successfully processed and saved: {processed_key}\u0026#34;) except Exception as e: logger.error(f\u0026#34;Error processing record {source_key}: {str(e)}\u0026#34;) continue return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: f\u0026#39;Successfully processed {processed_count} files\u0026#39;, \u0026#39;processedCount\u0026#39;: processed_count }) } except Exception as e: logger.error(f\u0026#34;Lambda execution error: {str(e)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: str(e) }) } def transform_weather_data(raw_data): \u0026#34;\u0026#34;\u0026#34; Transform raw OpenWeatherMap data into analytics-friendly format \u0026#34;\u0026#34;\u0026#34; try: # Extract timestamp (use collection_timestamp if available, otherwise dt) if \u0026#39;collection_timestamp\u0026#39; in raw_data: timestamp = raw_data[\u0026#39;collection_timestamp\u0026#39;] collection_date = datetime.datetime.fromisoformat(timestamp.replace(\u0026#39;Z\u0026#39;, \u0026#39;+00:00\u0026#39;)).strftime(\u0026#39;%Y-%m-%d\u0026#39;) else: timestamp = datetime.datetime.fromtimestamp(raw_data[\u0026#39;dt\u0026#39;]).isoformat() + \u0026#39;Z\u0026#39; collection_date = datetime.datetime.fromtimestamp(raw_data[\u0026#39;dt\u0026#39;]).strftime(\u0026#39;%Y-%m-%d\u0026#39;) # Extract basic location and weather information processed_data = { \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;city_name\u0026#39;: raw_data.get(\u0026#39;name\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;country\u0026#39;: raw_data.get(\u0026#39;sys\u0026#39;, {}).get(\u0026#39;country\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;latitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lat\u0026#39;), \u0026#39;longitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lon\u0026#39;), \u0026#39;data_collection_date\u0026#39;: collection_date } # Add custom city metadata if available if \u0026#39;city_metadata\u0026#39; in raw_data: city_meta = raw_data[\u0026#39;city_metadata\u0026#39;] processed_data.update({ \u0026#39;city_name\u0026#39;: city_meta.get(\u0026#39;name\u0026#39;, processed_data[\u0026#39;city_name\u0026#39;]), \u0026#39;latitude\u0026#39;: city_meta.get(\u0026#39;lat\u0026#39;, processed_data[\u0026#39;latitude\u0026#39;]), \u0026#39;longitude\u0026#39;: city_meta.get(\u0026#39;lon\u0026#39;, processed_data[\u0026#39;longitude\u0026#39;]) }) # Temperature conversion (OpenWeatherMap returns Celsius when units=metric) temp_celsius = raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;temp\u0026#39;) if temp_celsius: processed_data[\u0026#39;temperature_celsius\u0026#39;] = round(temp_celsius, 2) processed_data[\u0026#39;temperature_fahrenheit\u0026#39;] = round(temp_celsius * 9/5 + 32, 2) processed_data[\u0026#39;temperature_kelvin\u0026#39;] = round(temp_celsius + 273.15, 2) # Feels like temperature feels_like_celsius = raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;feels_like\u0026#39;) if feels_like_celsius: processed_data[\u0026#39;feels_like_celsius\u0026#39;] = round(feels_like_celsius, 2) processed_data[\u0026#39;feels_like_fahrenheit\u0026#39;] = round(feels_like_celsius * 9/5 + 32, 2) # Other weather parameters processed_data.update({ \u0026#39;humidity_percent\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;humidity\u0026#39;), \u0026#39;pressure_hpa\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;pressure\u0026#39;), \u0026#39;visibility_meters\u0026#39;: raw_data.get(\u0026#39;visibility\u0026#39;), \u0026#39;uv_index\u0026#39;: raw_data.get(\u0026#39;uvi\u0026#39;) # If available }) # Weather description weather_list = raw_data.get(\u0026#39;weather\u0026#39;, []) if weather_list: weather = weather_list[0] processed_data.update({ \u0026#39;weather_id\u0026#39;: weather.get(\u0026#39;id\u0026#39;), \u0026#39;weather_main\u0026#39;: weather.get(\u0026#39;main\u0026#39;), \u0026#39;weather_description\u0026#39;: weather.get(\u0026#39;description\u0026#39;), \u0026#39;weather_icon\u0026#39;: weather.get(\u0026#39;icon\u0026#39;) }) # Wind information wind_data = raw_data.get(\u0026#39;wind\u0026#39;, {}) processed_data.update({ \u0026#39;wind_speed_ms\u0026#39;: wind_data.get(\u0026#39;speed\u0026#39;), \u0026#39;wind_direction_deg\u0026#39;: wind_data.get(\u0026#39;deg\u0026#39;), \u0026#39;wind_gust_ms\u0026#39;: wind_data.get(\u0026#39;gust\u0026#39;) }) # Convert wind speed to km/h and mph if wind_data.get(\u0026#39;speed\u0026#39;): processed_data[\u0026#39;wind_speed_kmh\u0026#39;] = round(wind_data[\u0026#39;speed\u0026#39;] * 3.6, 2) processed_data[\u0026#39;wind_speed_mph\u0026#39;] = round(wind_data[\u0026#39;speed\u0026#39;] * 2.237, 2) # Cloud coverage processed_data[\u0026#39;cloud_coverage_percent\u0026#39;] = raw_data.get(\u0026#39;clouds\u0026#39;, {}).get(\u0026#39;all\u0026#39;) # Precipitation (if available) rain_data = raw_data.get(\u0026#39;rain\u0026#39;, {}) if rain_data: processed_data[\u0026#39;rain_1h_mm\u0026#39;] = rain_data.get(\u0026#39;1h\u0026#39;) processed_data[\u0026#39;rain_3h_mm\u0026#39;] = rain_data.get(\u0026#39;3h\u0026#39;) snow_data = raw_data.get(\u0026#39;snow\u0026#39;, {}) if snow_data: processed_data[\u0026#39;snow_1h_mm\u0026#39;] = snow_data.get(\u0026#39;1h\u0026#39;) processed_data[\u0026#39;snow_3h_mm\u0026#39;] = snow_data.get(\u0026#39;3h\u0026#39;) # Add derived fields processed_data.update(calculate_derived_fields(processed_data)) return processed_data except Exception as e: logger.error(f\u0026#34;Weather data transformation error: {str(e)}\u0026#34;) raise def calculate_derived_fields(data): \u0026#34;\u0026#34;\u0026#34; Calculate derived weather indicators \u0026#34;\u0026#34;\u0026#34; derived = {} try: # Calculate heat index (simplified) temp_f = data.get(\u0026#39;temperature_fahrenheit\u0026#39;) humidity = data.get(\u0026#39;humidity_percent\u0026#39;) if temp_f and humidity: if temp_f \u0026gt;= 80: # Heat index only meaningful above 80°F # Simplified heat index formula heat_index_f = ( -42.379 + 2.04901523 * temp_f + 10.14333127 * humidity - 0.22475541 * temp_f * humidity - 6.83783e-3 * temp_f**2 - 5.481717e-2 * humidity**2 + 1.22874e-3 * temp_f**2 * humidity + 8.5282e-4 * temp_f * humidity**2 - 1.99e-6 * temp_f**2 * humidity**2 ) derived[\u0026#39;heat_index_fahrenheit\u0026#39;] = round(heat_index_f, 2) derived[\u0026#39;heat_index_celsius\u0026#39;] = round((heat_index_f - 32) * 5/9, 2) # Comfort level based on temperature and humidity temp_c = data.get(\u0026#39;temperature_celsius\u0026#39;) if temp_c and humidity: if temp_c \u0026lt; 10: comfort = \u0026#39;cold\u0026#39; elif temp_c \u0026lt; 18: comfort = \u0026#39;cool\u0026#39; elif temp_c \u0026lt;= 24 and humidity \u0026lt;= 60: comfort = \u0026#39;comfortable\u0026#39; elif temp_c \u0026lt;= 30 and humidity \u0026lt;= 70: comfort = \u0026#39;warm\u0026#39; else: comfort = \u0026#39;hot\u0026#39; derived[\u0026#39;comfort_level\u0026#39;] = comfort # Wind condition wind_speed_kmh = data.get(\u0026#39;wind_speed_kmh\u0026#39;) if wind_speed_kmh: if wind_speed_kmh \u0026lt; 5: wind_condition = \u0026#39;calm\u0026#39; elif wind_speed_kmh \u0026lt; 20: wind_condition = \u0026#39;light\u0026#39; elif wind_speed_kmh \u0026lt; 40: wind_condition = \u0026#39;moderate\u0026#39; elif wind_speed_kmh \u0026lt; 60: wind_condition = \u0026#39;strong\u0026#39; else: wind_condition = \u0026#39;very_strong\u0026#39; derived[\u0026#39;wind_condition\u0026#39;] = wind_condition # Weather severity level weather_main = data.get(\u0026#39;weather_main\u0026#39;, \u0026#39;\u0026#39;).lower() if weather_main: if weather_main in [\u0026#39;thunderstorm\u0026#39;, \u0026#39;tornado\u0026#39;]: severity = \u0026#39;severe\u0026#39; elif weather_main in [\u0026#39;rain\u0026#39;, \u0026#39;snow\u0026#39;, \u0026#39;drizzle\u0026#39;]: severity = \u0026#39;moderate\u0026#39; elif weather_main in [\u0026#39;mist\u0026#39;, \u0026#39;fog\u0026#39;, \u0026#39;haze\u0026#39;]: severity = \u0026#39;light\u0026#39; else: severity = \u0026#39;normal\u0026#39; derived[\u0026#39;weather_severity\u0026#39;] = severity return derived except Exception as e: logger.error(f\u0026#34;Error calculating derived fields: {str(e)}\u0026#34;) return {} def decimal_default(obj): \u0026#34;\u0026#34;\u0026#34; JSON serializer for objects that are not serializable by default \u0026#34;\u0026#34;\u0026#34; if isinstance(obj, Decimal): return float(obj) raise TypeError Deploy code bằng cách click \u0026ldquo;Deploy\u0026rdquo; Bước 3: Thiết lập S3 Event Trigger Quan trọng: S3 Event Trigger sẽ tự động chạy Lambda mỗi khi có file mới được upload vào raw bucket. Đảm bảo Lambda function hoạt động đúng trước khi enable trigger.\n3.1 Thêm Permission cho S3 invoke Lambda Lambda Console → weather-data-processor → Configuration → Permissions\nResource-based policy → Add permissions:\nPrincipal: s3.amazonaws.com Source ARN: arn:aws:s3:::weather-data-{your-account-id} Action: lambda:InvokeFunction 3.2 Configure S3 Event Notification S3 Console → weather-data-{your-account-id} bucket → Properties\nEvent notifications → Create event notification:\nEvent name: weather-data-processing-trigger Event types: All object create events Prefix: raw/ Suffix: .json Destination: Lambda function → weather-data-processor Save changes Bước 4: Testing Data Processing Test với Real Data từ Module 2 Nếu EventBridge rules từ Module 2 đang chạy:\nChờ Lambda tự động chạy: EventBridge sẽ trigger functions theo lịch:\nCurrent weather: Mỗi giờ Monitoring real-time processing:\n# Check raw data được tạo aws s3 ls s3://weather-data-{your-account-id}/raw/current-weather/ --recursive # Check processed data được tạo aws s3 ls s3://weather-processed-{your-account-id}/current-weather/ --recursive CloudWatch Logs real-time:\nLambda Console → Functions → weather-data-processor → Monitor → View logs in CloudWatch Expected workflow:\nModule 2 EventBridge → weather-current-collector → S3 raw/current-weather/\r↓ (S3 Event)\rweather-data-processor → S3 processed/current-weather/ Tổng kết Đã hoàn thành:\nS3 Processed Bucket: Storage tối ưu cho analytics Lambda Data Processor: Transform current weather data S3 Event Triggers: Tự động processing khi có raw data Data Transformation: Clean, enrich, standardize weather data Hive Partitioning: Analytics-ready folder structure Error Handling: Robust error handling và retry logic Kết quả:\nWeather data được transform từ complex JSON → flat structure Temperature converted từ Kelvin → Celsius/Fahrenheit Derived metrics: comfort level, wind condition, weather severity Partitioned data cho efficient querying Real-time processing pipeline hoạt động 24/7 Sẵn sàng cho Module 4: Data Analytics và Visualization!\n"
},
{
	"uri": "//localhost:1313/vi/4-data-storage-solutions/",
	"title": "Phân tích Dữ liệu với Athena",
	"tags": [],
	"description": "",
	"content": "Phân tích Dữ liệu với Athena Trong module này, ta sẽ sử dụng Amazon Athena để chạy các truy vấn SQL trực tiếp trên dữ liệu thời tiết đã xử lý được lưu trữ trong S3. Athena là dịch vụ truy vấn serverless giúp dễ dàng phân tích dữ liệu bằng SQL tiêu chuẩn mà không cần thiết lập cơ sở hạ tầng kho dữ liệu phức tạp.\nMục tiêu Module Thiết lập Amazon Athena để query dữ liệu từ S3 Tạo database và external table cho dữ liệu thời tiết Viết SQL queries để phân tích dữ liệu thời tiết Sử dụng các trường đã enriched như comfort_level, weather_severity, wind_condition Tạo reports và insights từ dữ liệu thời tiết Tối ưu hóa performance và cost cho Athena queries Điều kiện tiên quyết Hoàn thành Module 3: Xử lý và Chuyển đổi Dữ liệu Có dữ liệu thời tiết đã xử lý trong S3 với format JSON đã cung cấp Truy cập AWS Console với quyền Administrator hoặc quyền cho Athena, S3 Hiểu biết cơ bản về SQL (SELECT, WHERE, GROUP BY, etc.) Kiểm tra dữ liệu: Hãy chắc chắn rằng bạn có dữ liệu JSON trong S3 bucket processed với cấu trúc\nBước 1: Thiết lập S3 Bucket cho Athena Query Results Athena cần một S3 bucket để lưu trữ kết quả truy vấn. Chúng ta sẽ tạo bucket này thủ công qua AWS Console.\n1.1 Tạo S3 Bucket cho Query Results Bước 1: Truy cập S3 Console\nĐăng nhập vào AWS Console Tìm kiếm và chọn S3 service Nhấp Create bucket Bước 2: Cấu hình Bucket\nBucket name: Nhập tên unique, ví dụ: weather-athena-query-results-[your-account-id]\nRegion: Chọn cùng region với bucket dữ liệu weather của bạn\nObject Ownership: Để mặc định ACLs disabled\nBlock Public Access: Để mặc định (block all public access)\nBước 3: Advanced Settings\nBucket Versioning: Disable (không cần thiết cho query results) Default encryption: Enable với Amazon S3 managed keys (SSE-S3) Nhấp Create bucket 1.2 Thiết lập Lifecycle Policy (Tùy chọn) Để tự động xóa query results cũ và tiết kiệm chi phí:\nBước 1: Vào Bucket Management\nNhấp vào bucket vừa tạo Chọn tab Management Nhấp Create lifecycle rule Bước 2: Cấu hình Lifecycle Rule\nRule name: delete-old-query-results Status: Enable Rule scope: Apply to all objects in the bucket Lifecycle rule actions: Expire current versions of objects Expire current versions of objects: 30 days Nhấp Create rule Lifecycle policy này sẽ tự động xóa query results sau 30 ngày để tiết kiệm chi phí storage.\n1.3 Cấu hình Athena Query Result Location Bước 1: Truy cập Athena Console\nTìm kiếm và chọn Amazon Athena service Bước 2: Set up Query Result Location\nChọn Query editor ở menu bên phải Nhấp Settings ở góc phải trên cùng Nhấp Manage Bước 3: Configure Location\nQuery result location: Chọn Browse S3 đang có sẵn là bucket result vừa tạo ở trên\nNhớ thêm / ở cuối đường dẫn S3!\nExpected bucket owner: Để trống\nEncrypt query results: Check và chọn SSE-S3\nNhấp Save\nBước 2: Tạo Database và External Table 2.1 Tạo Weather Analytics Database Bước 1: Mở Query Editor\nTrong Athena Console, chọn Query editor từ menu bên trái Đảm bảo bạn đang ở Data source: AwsDataCatalog Database: default Bước 2: Tạo Database\nCopy và chạy query sau trong Athena Query Editor:\nCREATE DATABASE IF NOT EXISTS weather_analytics LOCATION \u0026#39;s3://weather-athena-query-results-[your-account-id]/databases/weather_analytics/\u0026#39;; Bước 3: Chọn Database\nSau khi query chạy thành công, refresh page Trong dropdown Database, chọn weather_analytics 2.2 Tạo External Table cho Weather Data Bước 1: Chuẩn bị Schema\nDựa trên cấu trúc JSON đã xử lý trước đó, chúng ta sẽ tạo external table:\nCREATE EXTERNAL TABLE IF NOT EXISTS weather_analytics.current_weather ( timestamp STRING, city_name STRING, country STRING, latitude DOUBLE, longitude DOUBLE, data_collection_date STRING, temperature_celsius DOUBLE, temperature_fahrenheit DOUBLE, temperature_kelvin DOUBLE, feels_like_celsius DOUBLE, feels_like_fahrenheit DOUBLE, humidity_percent INT, pressure_hpa INT, visibility_meters BIGINT, uv_index DOUBLE, weather_id INT, weather_main STRING, weather_description STRING, weather_icon STRING, wind_speed_ms DOUBLE, wind_direction_deg INT, wind_gust_ms DOUBLE, wind_speed_kmh DOUBLE, wind_speed_mph DOUBLE, cloud_coverage_percent INT, heat_index_fahrenheit DOUBLE, heat_index_celsius DOUBLE, comfort_level STRING, wind_condition STRING, weather_severity STRING ) ROW FORMAT SERDE \u0026#39;org.openx.data.jsonserde.JsonSerDe\u0026#39; WITH SERDEPROPERTIES ( \u0026#39;serialization.format\u0026#39; = \u0026#39;1\u0026#39; ) LOCATION \u0026#39;s3://your-weather-processed-bucket/processed/\u0026#39; TBLPROPERTIES ( \u0026#39;has_encrypted_data\u0026#39;=\u0026#39;false\u0026#39;, \u0026#39;projection.enabled\u0026#39;=\u0026#39;true\u0026#39;, \u0026#39;projection.data_collection_date.type\u0026#39;=\u0026#39;date\u0026#39;, \u0026#39;projection.data_collection_date.range\u0026#39;=\u0026#39;2025-01-01,NOW\u0026#39;, \u0026#39;projection.data_collection_date.format\u0026#39;=\u0026#39;yyyy-MM-dd\u0026#39;, \u0026#39;storage.location.template\u0026#39;=\u0026#39;s3://your-weather-processed-bucket/processed/year=${data_collection_date}\u0026#39; ); Schema Explanation:\nSchema này match chính xác với JSON structure từ module 3 Bao gồm các trường mới: comfort_level, wind_condition, weather_severity Sử dụng JsonSerDe để parse JSON files Có partition projection cho performance tốt hơn 2.3 Verify Table Creation Test Basic Query\nSELECT COUNT(*) as total_records FROM weather_analytics.current_weather; Sample Data\nSELECT * FROM weather_analytics.current_weather ORDER BY timestamp DESC LIMIT 5; Bước 3: Phân tích Dữ liệu Cơ bản 3.1 Data Quality Check Kiểm tra chất lượng dữ liệu:\nSELECT COUNT(*) as total_records, COUNT(DISTINCT city_name) as unique_cities, COUNT(DISTINCT data_collection_date) as unique_dates, COUNT(temperature_celsius) as temp_records, COUNT(comfort_level) as comfort_records, COUNT(weather_severity) as severity_records, MIN(data_collection_date) as earliest_date, MAX(data_collection_date) as latest_date FROM weather_analytics.current_weather; 3.2 City-wise Temperature Analysis Phân tích nhiệt độ theo thành phố:\nWITH base_data AS ( SELECT CASE WHEN city_name IN (\u0026#39;HoChiMinh\u0026#39;, \u0026#39;Ho Chi Minh City\u0026#39;, \u0026#39;TPHCM\u0026#39;) THEN \u0026#39;Ho Chi Minh\u0026#39; WHEN city_name IN (\u0026#39;CanTho\u0026#39;, \u0026#39;Can Tho\u0026#39;) THEN \u0026#39;Can Tho\u0026#39; WHEN city_name IN (\u0026#39;GiaLai\u0026#39;, \u0026#39;Pleiku\u0026#39;) THEN \u0026#39;Gia Lai\u0026#39; WHEN city_name IN (\u0026#39;Da Nang\u0026#39;, \u0026#39;Danang\u0026#39;, \u0026#39;Ap Ba\u0026#39;) THEN \u0026#39;Da Nang\u0026#39; WHEN city_name IN (\u0026#39;Hanoi\u0026#39;, \u0026#39;Ha Noi\u0026#39;, \u0026#39;Xom Pho\u0026#39;) THEN \u0026#39;Ha Noi\u0026#39; WHEN city_name IN (\u0026#39;Hue\u0026#39;) THEN \u0026#39;Hue\u0026#39; ELSE city_name END AS standardized_city, country, comfort_level, temperature_celsius, heat_index_celsius FROM weather_analytics.current_weather ), comfort_counts AS ( SELECT standardized_city, country, comfort_level, COUNT(*) AS level_count, ROW_NUMBER() OVER ( PARTITION BY standardized_city, country ORDER BY COUNT(*) DESC ) AS rn FROM base_data GROUP BY standardized_city, country, comfort_level ) SELECT t.standardized_city AS city_name, t.country, COUNT(*) AS measurement_count, ROUND(AVG(t.temperature_celsius), 2) AS avg_temp_celsius, ROUND(MIN(t.temperature_celsius), 2) AS min_temp_celsius, ROUND(MAX(t.temperature_celsius), 2) AS max_temp_celsius, ROUND(AVG(t.heat_index_celsius), 2) AS avg_heat_index, c.comfort_level AS most_common_comfort_level FROM base_data t LEFT JOIN comfort_counts c ON t.standardized_city = c.standardized_city AND t.country = c.country AND c.rn = 1 GROUP BY t.standardized_city, t.country, c.comfort_level ORDER BY avg_temp_celsius DESC; 3.3 Comfort Level Distribution Phân tích comfort level:\nSELECT comfort_level, COUNT(*) as occurrence_count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage, ROUND(AVG(temperature_celsius), 2) as avg_temp, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(heat_index_celsius), 2) as avg_heat_index FROM weather_analytics.current_weather WHERE comfort_level IS NOT NULL GROUP BY comfort_level ORDER BY occurrence_count DESC; 3.4 Weather Severity Analysis Phân tích mức độ nghiêm trọng thời tiết:\nSELECT weather_severity, COUNT(*) as total_occurrences, COUNT(DISTINCT city_name) as cities_affected, ROUND(AVG(temperature_celsius), 2) as avg_temperature, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(pressure_hpa), 2) as avg_pressure FROM weather_analytics.current_weather WHERE weather_severity IS NOT NULL GROUP BY weather_severity ORDER BY CASE weather_severity WHEN \u0026#39;severe\u0026#39; THEN 1 WHEN \u0026#39;moderate\u0026#39; THEN 2 WHEN \u0026#39;light\u0026#39; THEN 3 ELSE 4 END; Bước 4: Advanced Analytics 4.1 Daily Weather Summary Tạo báo cáo thời tiết hàng ngày:\nWITH mode_counts AS ( SELECT data_collection_date, city_name, weather_main, comfort_level, wind_condition, weather_severity, COUNT(*) AS freq, ROW_NUMBER() OVER (PARTITION BY data_collection_date, city_name ORDER BY COUNT(*) DESC) AS rn_weather, ROW_NUMBER() OVER (PARTITION BY data_collection_date, city_name, comfort_level ORDER BY COUNT(*) DESC) AS rn_comfort, ROW_NUMBER() OVER (PARTITION BY data_collection_date, city_name, wind_condition ORDER BY COUNT(*) DESC) AS rn_wind, ROW_NUMBER() OVER (PARTITION BY data_collection_date, city_name, weather_severity ORDER BY COUNT(*) DESC) AS rn_severity FROM weather_analytics.current_weather WHERE DATE(data_collection_date) \u0026gt;= DATE(\u0026#39;2025-07-01\u0026#39;) GROUP BY data_collection_date, city_name, weather_main, comfort_level, wind_condition, weather_severity ) SELECT stats.data_collection_date, stats.city_name, stats.daily_measurements, stats.avg_temp_c, stats.avg_humidity, stats.avg_pressure, stats.avg_wind_kmh, m.weather_main AS dominant_weather, m.comfort_level AS dominant_comfort, m.wind_condition AS dominant_wind_condition, m.weather_severity AS dominant_severity FROM ( SELECT data_collection_date, city_name, COUNT(*) AS daily_measurements, ROUND(AVG(temperature_celsius), 1) AS avg_temp_c, ROUND(AVG(humidity_percent), 1) AS avg_humidity, ROUND(AVG(pressure_hpa), 1) AS avg_pressure, ROUND(AVG(wind_speed_kmh), 1) AS avg_wind_kmh FROM weather_analytics.current_weather WHERE DATE(data_collection_date) \u0026gt;= DATE(\u0026#39;2025-07-01\u0026#39;) GROUP BY data_collection_date, city_name ) stats LEFT JOIN mode_counts m ON stats.data_collection_date = m.data_collection_date AND stats.city_name = m.city_name AND m.rn_weather = 1 AND m.rn_comfort = 1 AND m.rn_wind = 1 AND m.rn_severity = 1 ORDER BY stats.data_collection_date DESC, stats.city_name; 4.2 Weather Pattern Correlation Phân tích mối tương quan giữa các yếu tố thời tiết:\nSELECT comfort_level, weather_main, weather_severity, COUNT(*) as occurrence_count, ROUND(AVG(temperature_celsius), 2) as avg_temperature, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(heat_index_celsius), 2) as avg_heat_index, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed FROM weather_analytics.current_weather WHERE comfort_level IS NOT NULL AND weather_severity IS NOT NULL GROUP BY comfort_level, weather_main, weather_severity HAVING COUNT(*) \u0026gt;= 3 -- Chỉ hiển thị patterns với ít nhất 3 occurrences ORDER BY comfort_level, occurrence_count DESC; 4.3 Wind Analysis Phân tích điều kiện gió:\nWITH base_data AS ( SELECT CASE WHEN city_name IN (\u0026#39;HoChiMinh\u0026#39;, \u0026#39;Ho Chi Minh City\u0026#39;, \u0026#39;TPHCM\u0026#39;) THEN \u0026#39;Ho Chi Minh\u0026#39; WHEN city_name IN (\u0026#39;CanTho\u0026#39;, \u0026#39;Can Tho\u0026#39;) THEN \u0026#39;Can Tho\u0026#39; WHEN city_name IN (\u0026#39;GiaLai\u0026#39;, \u0026#39;Pleiku\u0026#39;) THEN \u0026#39;Gia Lai\u0026#39; WHEN city_name IN (\u0026#39;Da Nang\u0026#39;, \u0026#39;Danang\u0026#39;, \u0026#39;Ap Ba\u0026#39;) THEN \u0026#39;Da Nang\u0026#39; WHEN city_name IN (\u0026#39;Hanoi\u0026#39;, \u0026#39;Ha Noi\u0026#39;, \u0026#39;Xom Pho\u0026#39;) THEN \u0026#39;Ha Noi\u0026#39; WHEN city_name IN (\u0026#39;Hue\u0026#39;) THEN \u0026#39;Hue\u0026#39; ELSE city_name END AS standardized_city, wind_condition, wind_speed_kmh, wind_gust_ms, wind_direction_deg FROM weather_analytics.current_weather WHERE wind_condition IS NOT NULL ) SELECT standardized_city AS city_name, wind_condition, COUNT(*) AS occurrence_count, ROUND(AVG(wind_speed_kmh), 2) AS avg_wind_speed_kmh, ROUND(MAX(wind_speed_kmh), 2) AS max_wind_speed_kmh, ROUND(AVG(wind_gust_ms), 2) AS avg_wind_gust_ms, CASE WHEN AVG(wind_direction_deg) BETWEEN 0 AND 45 OR AVG(wind_direction_deg) \u0026gt; 315 THEN \u0026#39;North\u0026#39; WHEN AVG(wind_direction_deg) BETWEEN 45 AND 135 THEN \u0026#39;East\u0026#39; WHEN AVG(wind_direction_deg) BETWEEN 135 AND 225 THEN \u0026#39;South\u0026#39; WHEN AVG(wind_direction_deg) BETWEEN 225 AND 315 THEN \u0026#39;West\u0026#39; ELSE \u0026#39;Variable\u0026#39; END AS dominant_wind_direction FROM base_data GROUP BY standardized_city, wind_condition ORDER BY city_name, avg_wind_speed_kmh DESC; Bước 5: Tạo Views cho Reporting 5.1 Daily Weather Summary View Tạo view cho báo cáo hàng ngày:\nCREATE OR REPLACE VIEW weather_analytics.daily_weather_summary AS SELECT data_collection_date, city_name, country, COUNT(*) as measurement_count, ROUND(AVG(temperature_celsius), 2) as avg_temperature, ROUND(AVG(feels_like_celsius), 2) as avg_feels_like, ROUND(AVG(heat_index_celsius), 2) as avg_heat_index, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(pressure_hpa), 2) as avg_pressure, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed, MODE() WITHIN GROUP (ORDER BY weather_main) as dominant_weather, MODE() WITHIN GROUP (ORDER BY comfort_level) as dominant_comfort_level, MODE() WITHIN GROUP (ORDER BY wind_condition) as dominant_wind_condition, MODE() WITHIN GROUP (ORDER BY weather_severity) as dominant_weather_severity FROM weather_analytics.current_weather GROUP BY data_collection_date, city_name, country; 5.2 Sử dụng Views Query từ view:\nSELECT * FROM weather_analytics.daily_weather_summary WHERE data_collection_date \u0026gt;= DATE(\u0026#39;2025-07-01\u0026#39;) ORDER BY data_collection_date DESC, city_name; Export results:\nChạy query trong Athena Nhấp Download để lưu kết quả CSV Kết quả cũng tự động lưu trong S3 query results bucket Sau khi hoàn thành module này, bạn đã có thể:\nAnalyze weather data với SQL queries phức tạp\nCreate insights từ comfort levels và weather severity\nGenerate reports cho business applications\nUnderstand weather patterns qua correlations\nTrong module tiếp theo, chúng ta sẽ tạo QuickSight dashboards từ Athena data Visualize weather trends và patterns Create interactive business intelligence reports "
},
{
	"uri": "//localhost:1313/vi/5-analytics-visualization/",
	"title": "Trực quan hóa Dữ liệu với QuickSight",
	"tags": [],
	"description": "",
	"content": "Bây giờ khi bạn đã có dữ liệu thời tiết được lưu trữ và có thể truy vấn thông qua Athena, đã đến lúc tạo các trực quan hóa hấp dẫn! Trong module này, ta sẽ sử dụng Amazon QuickSight để xây dựng dashboard tương tác giúp dữ liệu thời tiết của chúng ta trở nên sinh động.\nTổng quan Module Amazon QuickSight là dịch vụ business intelligence (BI) của AWS giúp dễ dàng tạo và xuất bản các dashboard tương tác. Bạn sẽ kết nối QuickSight với nguồn dữ liệu Athena và tạo các trực quan hóa tiết lộ các mẫu và thông tin chi tiết từ dữ liệu thời tiết.\nĐiều kiện tiên quyết Phân tích Dữ liệu với Athena Dữ liệu thời tiết có sẵn trong bảng Athena Tài khoản AWS với quyền QuickSight Bước 1: Thiết lập Amazon QuickSight 1.1 Đăng ký QuickSight Truy cập QuickSight Đăng nhập AWS Console. Ở thanh tìm kiếm, nhập QuickSight và chọn Amazon QuickSight. Nhấp Sign up for QuickSight Chọn Standard Edition (bao gồm dùng thử miễn phí 30 ngày) Nhập thông tin tài khoản: Account name: weather-analytics-[ten-ban] Notification email: Địa chỉ email của bạn Nhấp Finish 1.2 Cấu hình Quyền QuickSight Trong QuickSight, nhấp biểu tượng profile (góc phải trên) Chọn Manage QuickSight Chọn Security \u0026amp; permissions Nhấp Manage Kích hoạt các dịch vụ sau: Amazon Athena Amazon S3 Cho S3, nhấp Select S3 buckets Chọn bucket dữ liệu thời tiết: your-weather-processed-bucket your-athena-query-results-bucket Nhấp Save Bước 2: Tạo Data Source và Dataset 2.1 Kết nối với Athena Trong trang chủ QuickSight, nhấp Datasets Nhấp New dataset Chọn Athena làm data source Cấu hình kết nối: Data source name: Weather-Data-Athena Athena workgroup: primary (mặc định) Nhấp Create data source 2.2 Tạo Dataset từ Weather Table Chọn database: weather_analytics Chọn table: current_weather Chọn Directly query your data Nhấp Visualize Nếu dataset của bạn nhỏ (\u0026lt; 1GB), bạn có thể chọn \u0026ldquo;Import to SPICE\u0026rdquo; để có hiệu suất tốt hơn. SPICE là engine tính toán trong bộ nhớ của QuickSight.\nBước 3: Tạo Trực quan hóa Thời tiết 3.1 Biểu đồ Đường Xu hướng Nhiệt độ Tạo phân tích mới:\nNhấp + Add → Add visual Chọn Line chart Cấu hình biểu đồ:\nX-axis: Kéo data_collection_date vào X-axis Value: Kéo temperature_celsius vào Value Color: Kéo city_name vào Color Tùy chỉnh biểu đồ:\nNhấp visual → Format visual Title: \u0026ldquo;Xu hướng Nhiệt độ theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ (°C)\u0026rdquo; Legend: Đặt ở dưới cùng 3.2 Biểu đồ Tròn Điều kiện Thời tiết Thêm visual mới:\nNhấp + Add → Add visual Chọn Pie chart Cấu hình biểu đồ:\nGroup/Color: Kéo weather_main vào Group/Color Value: Kéo city_name vào Value Aggregate: Đổi thành Count Tùy chỉnh:\nTitle: \u0026ldquo;Phân bố Điều kiện Thời tiết\u0026rdquo; Legend: Hiển thị phần trăm 3.3 Biểu đồ Cột So sánh Nhiệt độ Thành phố Thêm visual mới:\nChọn Vertical bar chart Cấu hình:\nX-axis: Kéo city_name vào X-axis Value: Kéo temperature_celsius vào Value Aggregate: Đổi thành Average Tùy chỉnh:\nTitle: \u0026ldquo;Nhiệt độ Trung bình theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ Trung bình (°C)\u0026rdquo; Sắp xếp theo giá trị (giảm dần) 3.4 Biểu đồ đường so sánh giữa temperature_celsius và feels_like_celsius Thêm visual mới:\nChọn Line chart Cấu hình:\nX-axis: Kéo timestamp vào X-axis Value: Kéo temperature_celsius và feels_like_celsius vào Value Aggregate: Đổi thành Average Tùy chỉnh:\nTitle: \u0026ldquo;So sánh nhiệt đồ ngoài trời và nhiệt độ cảm nhận\u0026rdquo; X-axis label: \u0026ldquo;Thời gian\u0026rdquo; 3.5 Chỉ số Hiệu suất Chính (KPIs) Tạo các ô KPI cho dữ liệu thời tiết mới nhất:\nKPI Nhiệt độ Hiện tại Thêm visual mới → KPI Cấu hình: Value: temperature_celsius Aggregate: Average Filter: Thêm filter cho ngày mới nhất Title: \u0026ldquo;Nhiệt độ Trung bình Hiện tại\u0026rdquo; KPI Độ ẩm Thêm KPI visual Cấu hình: Value: humidity_percent Aggregate: Average Title: \u0026ldquo;Độ ẩm Trung bình Hiện tại\u0026rdquo; Bước 4: Xây dựng Dashboard Toàn diện 4.1 Tổ chức Bố cục Dashboard Thay đổi kích thước và sắp xếp visuals:\nĐặt KPIs ở trên cùng theo hàng ngang Biểu đồ xu hướng nhiệt độ ở khu vực chính Biểu đồ tròn và biểu đồ cột cạnh nhau bên dưới Thêm tiêu đề dashboard:\nNhấp + Add → Add title Text: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Style: Lớn, căn giữa 4.2 Thêm Bộ lọc Tương tác Thêm bộ lọc ngày:\nNhấp Filter pane (bên trái) Nhấp Create one → Chọn data_collection_date Filter type: Date range Default: 7 ngày gần nhất Thêm bộ lọc thành phố:\nTạo filter cho city_name Filter type: Multi-select dropdown Hiển thị tất cả thành phố theo mặc định Thêm bộ lọc điều kiện thời tiết:\nTạo filter cho weather_main Filter type: Multi-select dropdown 4.3 Áp dụng Styling Dashboard Chọn color theme:\nNhấp Themes (menu trên) Chọn Midnight hoặc Classic Tùy chỉnh màu sắc:\nCho biểu đồ nhiệt độ: Sử dụng gradient xanh-đỏ Cho điều kiện thời tiết: Sử dụng màu riêng biệt cho mỗi điều kiện Thêm text mô tả:\nNhấp + Add → Add text box Thêm insights hoặc hướng dẫn cho người dùng dashboard Bước 5: Trực quan hóa Nâng cao Biểu đồ Hướng Gió (Sử dụng Calculated Fields) Tạo calculated field:\nNhấp + Add → Add calculated field Name: wind_direction_category Formula: ifelse(\rwind_direction_deg \u0026gt;= 337.5 OR wind_direction_deg \u0026lt; 22.5, \u0026#34;N\u0026#34;,\rwind_direction_deg \u0026gt;= 22.5 AND wind_direction_deg \u0026lt; 67.5, \u0026#34;NE\u0026#34;,\rwind_direction_deg \u0026gt;= 67.5 AND wind_direction_deg \u0026lt; 112.5, \u0026#34;E\u0026#34;,\rwind_direction_deg \u0026gt;= 112.5 AND wind_direction_deg \u0026lt; 157.5, \u0026#34;SE\u0026#34;,\rwind_direction_deg \u0026gt;= 157.5 AND wind_direction_deg \u0026lt; 202.5, \u0026#34;S\u0026#34;,\rwind_direction_deg \u0026gt;= 202.5 AND wind_direction_deg \u0026lt; 247.5, \u0026#34;SW\u0026#34;,\rwind_direction_deg \u0026gt;= 247.5 AND wind_direction_deg \u0026lt; 292.5, \u0026#34;W\u0026#34;,\r\u0026#34;NW\u0026#34;\r) Tạo biểu đồ hướng gió:\nVisual type: Donut chart Group: wind_direction_category Value: Count of records Title: \u0026ldquo;Phân bố Hướng Gió\u0026rdquo; Bước 6: Xuất bản và Chia sẻ Dashboard 6.1 Xuất bản Dashboard Nhấp Share (góc phải trên) Nhấp Publish dashboard Dashboard name: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Description: \u0026ldquo;Trực quan hóa dữ liệu thời tiết tương tác hiển thị xu hướng nhiệt độ, mẫu thời tiết và so sánh thành phố\u0026rdquo; Nhấp Publish dashboard 6.2 Thiết lập Quyền Chia sẻ Trong dashboard đã xuất bản, nhấp Share Add users or groups: Nhập địa chỉ email của người dùng để chia sẻ Đặt quyền: Viewer hoặc Co-owner Nhấp Share 6.3 Tạo Dashboard Công khai (Tùy chọn) Nhấp Share → Manage dashboard access Kích hoạt Make dashboard public Sao chép URL công khai để chia sẻ bên ngoài Chỉ công khai dashboard nếu dữ liệu không chứa thông tin nhạy cảm.\nBước 7: Thiết lập Làm mới Dữ liệu Tự động 7.1 Cấu hình Làm mới Dataset Đi đến Datasets Chọn weather dataset của bạn Nhấp Refresh → Schedule refresh Cấu hình lịch: Frequency: Daily Time: Sáng sớm (ví dụ: 6 AM) Time zone: Múi giờ địa phương của bạn Lưu lịch 7.2 Giám sát Trạng thái Làm mới Kiểm tra lịch sử làm mới trong Dataset settings Thiết lập thông báo cho làm mới thất bại Giám sát chỉ báo độ tươi của dữ liệu trong dashboard Bước 8: Tối ưu hóa Dashboard và Best Practices Kết quả:\nDashboard thời tiết tương tác với nhiều trực quan hóa Làm mới dữ liệu tự động từ ETL pipeline Insights có thể chia sẻ cho phân tích thời tiết Hiểu biết về best practices của QuickSight Sắp tới trong Module 6: Học cách dọn dẹp đúng cách các tài nguyên AWS và khám phá các cải tiến nâng cao cho nền tảng phân tích thời tiết của bạn.\nHủy đăng ký QuickSight sau workshop nếu không có kế hoạch tiếp tục sử dụng để tránh các khoản phí liên tục.\n"
},
{
	"uri": "//localhost:1313/vi/6-cleanup-next-steps/",
	"title": "Dọn dẹp Tài nguyên",
	"tags": [],
	"description": "",
	"content": "Sau khi hoàn thành workshop thực hành, việc dọn dẹp tài nguyên là rất quan trọng để ngăn ngừa các khoản phí bất ngờ. M\n6.1 Tài nguyên QuickSight Xóa Dashboard Chúng ta sẽ dọn dẹp theo thứ tự ngược lại của quá trình tạo để tránh các lỗi phụ thuộc (ví dụ: không thể xóa S3 bucket nếu nó vẫn còn được sử dụng bởi một dịch vụ khác).\nBước 1: Hủy đăng ký Amazon QuickSight QuickSight là dịch vụ có phí đăng ký hàng tháng, vì vậy hãy ưu tiên hủy nó trước.\nTruy cập QuickSight: Mở AWS Console, tìm và chọn QuickSight. Nhấp vào Go to QuickSight để vào giao diện quản lý. Xóa các tài sản (Analyses, Dashboards, Datasets): Trong menu bên trái, đi đến từng mục Dashboards, Analyses, và Datasets. Với mỗi mục, chọn tất cả các tài sản liên quan đến workshop (ví dụ: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo;) và nhấp Delete. Xác nhận xóa. Hủy đăng ký (Unsubscribe): Ở góc trên bên phải, nhấp vào biểu tượng profile của bạn và chọn Manage QuickSight. Trong menu bên trái, chọn Your Account. Nhấp vào Manage account. Một hộp thoại xác nhận sẽ hiện ra. Confirm và tiến hành xóa tài khoản Bước 2: Xóa tài nguyên Amazon Athena Athena tự nó không tốn phí, nhưng các kết quả truy vấn được lưu trong S3 thì có.\nTruy cập Athena: Mở AWS Console, tìm và chọn Athena. Xóa bảng (Drop Table): Trong Query editor, đảm bảo bạn đã chọn database weather_analytics. Chạy lệnh sau để xóa bảng: DROP TABLE IF EXISTS weather_analytics.current_weather; Xóa cơ sở dữ liệu (Drop Database): Sau khi xóa bảng, chạy lệnh sau: DROP DATABASE IF EXISTS weather_analytics; Bước 3: Xóa Amazon S3 Buckets S3 tính phí lưu trữ, vì vậy việc xóa bucket là rất quan trọng.\nBạn phải làm trống bucket (delete all objects) trước khi có thể xóa bucket.\nTruy cập S3: Mở AWS Console, tìm và chọn S3. Làm trống và xóa từng Bucket: Thực hiện các bước sau cho cả 3 bucket: your-weather-raw-bucket-[ID] your-weather-processed-bucket-[ID] your-athena-query-results-bucket-[ID] Các bước cho mỗi bucket: Nhấp vào tên bucket để mở nó. Chọn tất cả các đối tượng và thư mục bên trong. Nhấp vào nút Delete. Trong màn hình xác nhận, nhập permanently delete và nhấp Delete objects. Sau khi bucket trống, quay lại danh sách các bucket. Chọn bucket (đã trống) và nhấp Delete. Trong màn hình xác nhận, nhập tên bucket và nhấp Delete bucket. Bước 4: Xóa tài nguyên Scheduling và Lambda Xóa EventBridge (CloudWatch Events) Rule: Mở AWS Console, tìm và chọn Amazon EventBridge. Trong menu bên trái, chọn Rules. Chọn rule bạn đã tạo (ví dụ: weather-collection-schedule). Nhấp Delete và xác nhận. Xóa Lambda Functions: Mở AWS Console, tìm và chọn Lambda. Xóa từng hàm một: Chọn hàm weather-data-collector. Nhấp Actions \u0026gt; Delete. Xác nhận xóa. Chọn hàm weather-data-processor. Nhấp Actions \u0026gt; Delete. Xác nhận xóa. Bước 5: Xóa CloudWatch Log Groups Lambda tự động tạo các log group. Chúng chiếm dung lượng và có thể phát sinh chi phí nhỏ.\nTruy cập CloudWatch: Mở AWS Console, tìm và chọn CloudWatch. Xóa Log Groups: Trong menu bên trái, chọn Log groups. Tìm và chọn các log group sau: /aws/lambda/weather-data-collector /aws/lambda/weather-data-processor Nhấp Actions \u0026gt; Delete log group(s) và xác nhận. Bước 6: Xóa IAM Roles và Policies Đây là bước quan trọng để dọn dẹp các quyền không cần thiết.\nTruy cập IAM: Mở AWS Console, tìm và chọn IAM. Xóa IAM Role cho Lambda: Trong menu bên trái, chọn Roles. Tìm role bạn đã tạo cho Lambda (ví dụ: weather-lambda-role). Lưu ý: Nếu role này có các policy đính kèm, bạn cần detach chúng trước khi có thể xóa role. Thông thường, khi xóa role, AWS sẽ tự động detach các policy do bạn tạo. Chọn role, nhấp Delete và xác nhận. Xóa IAM Role cho QuickSight (nếu bạn đã tạo riêng): Lặp lại quy trình trên cho role của QuickSight (ví dụ: quicksight-athena-role). Xác minh lần cuối Sau khi hoàn thành các bước trên, hãy kiểm tra lại một lần nữa:\nKiểm tra Billing Dashboard: Truy cập AWS Billing và xem có chi phí phát sinh bất thường nào không trong vài giờ tới. Kiểm tra các dịch vụ: Lướt qua console của S3, Lambda, IAM để đảm bảo không còn tài nguyên nào có tên liên quan đến workshop. "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]