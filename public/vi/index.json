[
{
	"uri": "//localhost:1313/vi/",
	"title": "Xây dựng Pipeline ETL Thời tiết Serverless",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Tổng quan Workshop Trong workshop này, em sẽ tạo một pipeline dữ liệu thời tiết đơn giản nhưng hoàn chỉnh, minh họa các khái niệm ETL cốt lõi sử dụng công nghệ serverless của AWS.\nWorkshop này trình bày cách xây dựng một pipeline ETL đơn giản sử dụng công nghệ serverless của AWS:\nThu thập dữ liệu thời tiết từ OpenWeatherMap API sử dụng AWS Lambda Xử lý và chuyển đổi dữ liệu thô thành định dạng phân tích Lưu trữ dữ liệu trong Amazon S3 cho cả dữ liệu thô và đã xử lý Phân tích dữ liệu sử dụng Amazon Athena với truy vấn SQL Trực quan hóa insights thông qua Amazon QuickSight dashboard Dọn dẹp tài nguyên để tối ưu chi phí Công nghệ sử dụng: Workshop sử dụng AWS Lambda, S3, Athena, QuickSight kết hợp với OpenWeatherMap API để xây dựng pipeline ETL serverless thu thập và phân tích dữ liệu thời tiết. Các phần chính 1. Giới thiệu Tổng quan workshop và mục tiêu học tập Thiết kế kiến trúc và giới thiệu các dịch vụ AWS Yêu cầu tiên quyết và thiết lập 2. Thu thập Dữ liệu Thời tiết với OpenWeatherMap Thiết lập tài khoản OpenWeatherMap API Tạo Lambda function cho thu thập dữ liệu Cấu hình tự động lấy dữ liệu Kiểm tra và giám sát quá trình thu thập 3. Xử lý Dữ liệu Serverless với Lambda Xây dựng Lambda function chuyển đổi dữ liệu Chuyển đổi JSON thời tiết thô sang định dạng phân tích Triển khai xác thực và làm giàu dữ liệu Thiết lập triggers xử lý 4. Phân tích Dữ liệu với Amazon Athena Tạo cấu trúc data lake S3 Thiết lập bảng và schema Athena Viết truy vấn SQL cho phân tích thời tiết Khám phá các mẫu và thông tin chi tiết từ dữ liệu 5. Trực quan hóa Dữ liệu với QuickSight Thiết lập Amazon QuickSight Tạo dashboard thời tiết Xây dựng trực quan hóa tương tác Chia sẻ và xuất bản dashboard 6. Dọn dẹp Tài nguyên và Bước tiếp theo Danh sách kiểm tra dọn dẹp toàn diện Chiến lược tối ưu chi phí Đề xuất cải tiến và mở rộng Tài nguyên học tập bổ sung "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.1-openweathermap-setup/",
	"title": "Thiết lập OpenWeatherMap API",
	"tags": [],
	"description": "",
	"content": "Thiết lập OpenWeatherMap API Trong phần đơn giản hóa này, chúng ta sẽ nhanh chóng thiết lập tài khoản OpenWeatherMap API để thu thập dữ liệu thời tiết cho pipeline của chúng ta.\nBước 1: Đăng ký OpenWeatherMap Tạo tài khoản Truy cập https://openweathermap.org và nhấp vào \u0026ldquo;Sign Up\u0026rdquo; Hoàn thành đăng ký với email của bạn Xác minh email và đăng nhập Bước 2: Lấy API Key Truy cập API Keys Sau khi đăng nhập, đi đến phần \u0026ldquo;API keys\u0026rdquo; Ghi chú API key mặc định hoặc tạo key mới với tên \u0026ldquo;weather-data-collection\u0026rdquo; Gói miễn phí bao gồm 1,000 lệnh gọi API mỗi ngày và 60 lệnh gọi mỗi phút - nhiều hơn đủ cho workshop của chúng ta.\nBước 3: Kiểm tra API Key Kiểm tra API key của bạn bằng một trong các phương pháp sau:\nPhương pháp trình duyệt:\nhttps://api.openweathermap.org/data/2.5/weather?q=London\u0026amp;appid=YOUR_API_KEY Phương pháp cURL:\ncurl \u0026#34;https://api.openweathermap.org/data/2.5/weather?q=London\u0026amp;appid=YOUR_API_KEY\u0026#34; Bạn sẽ thấy phản hồi JSON với dữ liệu thời tiết của London.\nBước 4: Lưu trữ API Key an toàn Sử dụng AWS Systems Manager Mở AWS Management Console Đi đến Systems Manager → Parameter Store Nhấp vào \u0026ldquo;Create parameter\u0026rdquo; Thiết lập các giá trị sau: Tên: /weather-etl/openweathermap/api-key Loại: SecureString Giá trị: API key của bạn Nhấp vào \u0026ldquo;Create parameter\u0026rdquo; Các API Endpoints chính sẽ sử dụng # Thời tiết hiện tại\rhttps://api.openweathermap.org/data/2.5/weather?q={city}\u0026amp;appid={API key}\r# Dự báo 5 ngày (khoảng thời gian 3 giờ)\rhttps://api.openweathermap.org/data/2.5/forecast?q={city}\u0026amp;appid={API key} Các bước tiếp theo Vậy là xong! Bạn đã có API key OpenWeatherMap hoạt động được lưu trữ an toàn trong Parameter Store. Trong phần tiếp theo, chúng ta sẽ tạo một Lambda function để thu thập dữ liệu thời tiết.\nĐã hoàn thành:\nTạo tài khoản OpenWeatherMap Lấy API key Lưu trữ API key trong AWS Parameter Store "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.2-lambda-weather-collector/",
	"title": "Xây dựng Lambda Weather Collector",
	"tags": [],
	"description": "",
	"content": "Xây dựng Lambda Weather Collector Trong phần này, chúng ta sẽ tạo các hàm AWS Lambda để tự động thu thập dữ liệu thời tiết từ OpenWeatherMap API và lưu trữ vào S3. Những hàm này sẽ là lõi của hệ thống thu thập dữ liệu thời tiết.\nTổng quan Kiến trúc graph LR\rA[CloudWatch Events] --\u0026gt; B[Lambda Weather Collector]\rB --\u0026gt; C[OpenWeatherMap API]\rC --\u0026gt; D[API Response]\rD --\u0026gt; B\rB --\u0026gt; E[S3 Weather Data]\rB --\u0026gt; F[CloudWatch Logs]\rG[Parameter Store] --\u0026gt; B\rstyle B fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle C fill:#e1f5fe\rstyle E fill:#f3e5f5 Bước 1: Tạo IAM Role cho Lambda 1.1 Tạo Lambda Execution Role Điều hướng đến IAM Console\nAWS Console → IAM → Roles Click \u0026ldquo;Create role\u0026rdquo; Chọn Trusted Entity\nService: Lambda Click \u0026ldquo;Next\u0026rdquo; Cấu hình Role\nRole Name: WeatherCollectorLambdaRole Description: Execution role for weather data collection Lambda functions 1.2 Tạo Custom Policy Policy Name: WeatherCollectorPolicy\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;S3WeatherDataAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:PutObjectAcl\u0026#34;, \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::weather-data-lake-*\u0026#34;, \u0026#34;arn:aws:s3:::weather-data-lake-*/*\u0026#34; ] }, { \u0026#34;Sid\u0026#34;: \u0026#34;ParameterStoreAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;ssm:GetParameter\u0026#34;, \u0026#34;ssm:GetParameters\u0026#34;], \u0026#34;Resource\u0026#34;: [\u0026#34;arn:aws:ssm:*:*:parameter/weather-etl/*\u0026#34;] }, { \u0026#34;Sid\u0026#34;: \u0026#34;CloudWatchLogsAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:logs:*:*:log-group:/aws/lambda/weather-*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;CloudWatchMetricsAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;cloudwatch:PutMetricData\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;cloudwatch:namespace\u0026#34;: \u0026#34;Weather/ETL\u0026#34; } } } ] } 1.3 Gắn AWS Managed Policies Cũng gắn AWS managed policy này:\nAWSLambdaBasicExecutionRole: arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Bước 2: Tạo S3 Bucket cho Dữ liệu Thời tiết 2.1 Tạo Weather Data Bucket Điều hướng đến S3 Console\nAWS Console → S3 → Create bucket Cấu hình Bucket\nBucket Name: weather-data-lake-{your-account-id} (thay thế bằng AWS account ID của bạn) Region: us-east-1 (hoặc region ưa thích của bạn) Block Public Access: Giữ tất cả cài đặt được bật (khuyến nghị) Cấu trúc Bucket\nweather-data-lake-123456789012/\r├── raw/\r│ ├── current-weather/\r│ │ └── year=2025/month=01/day=03/hour=10/\r│ └── forecast/\r│ └── year=2025/month=01/day=03/\r└── processed/\r├── current-weather/\r└── forecast/ Bước 3: Lambda Function cho Current Weather 3.1 Tạo Current Weather Function Điều hướng đến Lambda Console\nAWS Console → Lambda → Create function Cấu hình Function\nFunction Name: weather-current-collector Runtime: Python 3.11 Architecture: x86_64 Execution Role: Use existing role → WeatherCollectorLambdaRole 3.2 Function Code File: lambda_function.py\nimport json import boto3 import requests import os from datetime import datetime, timezone from typing import Dict, List, Optional import logging # Cấu hình logging logger = logging.getLogger() logger.setLevel(logging.INFO) # AWS clients s3_client = boto3.client(\u0026#39;s3\u0026#39;) ssm_client = boto3.client(\u0026#39;ssm\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) # Cấu hình BUCKET_NAME = os.environ.get(\u0026#39;WEATHER_BUCKET_NAME\u0026#39;) API_KEY_PARAMETER = \u0026#39;/weather-etl/openweathermap/api-key\u0026#39; # Các thành phố mục tiêu để thu thập thời tiết CITIES = [ {\u0026#39;name\u0026#39;: \u0026#39;Ho Chi Minh City\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;VN\u0026#39;, \u0026#39;lat\u0026#39;: 10.8231, \u0026#39;lon\u0026#39;: 106.6297}, {\u0026#39;name\u0026#39;: \u0026#39;Hanoi\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;VN\u0026#39;, \u0026#39;lat\u0026#39;: 21.0285, \u0026#39;lon\u0026#39;: 105.8542}, {\u0026#39;name\u0026#39;: \u0026#39;Singapore\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;SG\u0026#39;, \u0026#39;lat\u0026#39;: 1.3521, \u0026#39;lon\u0026#39;: 103.8198}, {\u0026#39;name\u0026#39;: \u0026#39;Bangkok\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;TH\u0026#39;, \u0026#39;lat\u0026#39;: 13.7563, \u0026#39;lon\u0026#39;: 100.5018}, {\u0026#39;name\u0026#39;: \u0026#39;Jakarta\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;ID\u0026#39;, \u0026#39;lat\u0026#39;: -6.2088, \u0026#39;lon\u0026#39;: 106.8456}, {\u0026#39;name\u0026#39;: \u0026#39;Kuala Lumpur\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;MY\u0026#39;, \u0026#39;lat\u0026#39;: 3.1390, \u0026#39;lon\u0026#39;: 101.6869} ] def get_api_key() -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Lấy OpenWeatherMap API key từ Parameter Store.\u0026#34;\u0026#34;\u0026#34; try: response = ssm_client.get_parameter( Name=API_KEY_PARAMETER, WithDecryption=True ) return response[\u0026#39;Parameter\u0026#39;][\u0026#39;Value\u0026#39;] except Exception as e: logger.error(f\u0026#34;Không thể lấy API key: {e}\u0026#34;) raise def fetch_current_weather(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Lấy dữ liệu thời tiết hiện tại cho một thành phố.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/weather\u0026#34; params = { \u0026#39;lat\u0026#39;: city[\u0026#39;lat\u0026#39;], \u0026#39;lon\u0026#39;: city[\u0026#39;lon\u0026#39;], \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39;, \u0026#39;lang\u0026#39;: \u0026#39;vi\u0026#39; } try: response = requests.get(base_url, params=params, timeout=30) response.raise_for_status() data = response.json() # Thêm metadata data[\u0026#39;collection_timestamp\u0026#39;] = datetime.now(timezone.utc).isoformat() data[\u0026#39;city_metadata\u0026#39;] = city return data except requests.exceptions.RequestException as e: logger.error(f\u0026#34;Lỗi API cho {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except json.JSONDecodeError as e: logger.error(f\u0026#34;Lỗi JSON decode cho {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None def save_to_s3(data: Dict, city_name: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Lưu dữ liệu thời tiết vào S3.\u0026#34;\u0026#34;\u0026#34; try: now = datetime.now(timezone.utc) # Tạo S3 key với partition theo thời gian city_safe = city_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;) key = f\u0026#34;raw/current-weather/year={now.year}/month={now.month:02d}/day={now.day:02d}/hour={now.hour:02d}/{city_safe}_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; # Upload file s3_client.put_object( Bucket=BUCKET_NAME, Key=key, Body=json.dumps(data, ensure_ascii=False, indent=2), ContentType=\u0026#39;application/json\u0026#39;, Metadata={ \u0026#39;city\u0026#39;: city_name, \u0026#39;collection_time\u0026#39;: now.isoformat(), \u0026#39;data_type\u0026#39;: \u0026#39;current_weather\u0026#39; } ) logger.info(f\u0026#34;Đã lưu dữ liệu cho {city_name} tại {key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;Lỗi lưu S3 cho {city_name}: {e}\u0026#34;) return False def send_metrics(metric_name: str, value: float, unit: str = \u0026#39;Count\u0026#39;): \u0026#34;\u0026#34;\u0026#34;Gửi metrics tùy chỉnh tới CloudWatch.\u0026#34;\u0026#34;\u0026#34; try: cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: value, \u0026#39;Unit\u0026#39;: unit, \u0026#39;Timestamp\u0026#39;: datetime.now(timezone.utc) } ] ) except Exception as e: logger.error(f\u0026#34;Lỗi gửi metric {metric_name}: {e}\u0026#34;) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Handler chính cho Lambda function.\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Bắt đầu thu thập thời tiết: {json.dumps(event)}\u0026#34;) successful_collections = 0 failed_collections = 0 results = [] try: # Lấy API key api_key = get_api_key() # Thu thập dữ liệu cho từng thành phố for city in CITIES: logger.info(f\u0026#34;Thu thập dữ liệu cho {city[\u0026#39;name\u0026#39;]}\u0026#34;) # Fetch weather data weather_data = fetch_current_weather(city, api_key) if weather_data: # Lưu vào S3 if save_to_s3(weather_data, city[\u0026#39;name\u0026#39;]): successful_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;temperature\u0026#39;: weather_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;temp\u0026#39;), \u0026#39;description\u0026#39;: weather_data.get(\u0026#39;weather\u0026#39;, [{}])[0].get(\u0026#39;description\u0026#39;) }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;S3 save failed\u0026#39; }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;API fetch failed\u0026#39; }) # Gửi metrics send_metrics(\u0026#39;SuccessfulCollections\u0026#39;, successful_collections) send_metrics(\u0026#39;FailedCollections\u0026#39;, failed_collections) send_metrics(\u0026#39;TotalCollections\u0026#39;, successful_collections + failed_collections) # Log kết quả logger.info(f\u0026#34;Thu thập hoàn tất - Thành công: {successful_collections}, Thất bại: {failed_collections}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Thu thập thời tiết hoàn tất\u0026#39;, \u0026#39;successful_collections\u0026#39;: successful_collections, \u0026#39;failed_collections\u0026#39;: failed_collections, \u0026#39;results\u0026#39;: results }, ensure_ascii=False) } except Exception as e: logger.error(f\u0026#34;Lỗi trong lambda handler: {e}\u0026#34;) send_metrics(\u0026#39;LambdaErrors\u0026#39;, 1) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Lỗi nội bộ\u0026#39;, \u0026#39;message\u0026#39;: str(e) }, ensure_ascii=False) } 3.3 Biến Môi trường Trong Lambda Console, thêm biến môi trường:\nWEATHER_BUCKET_NAME: weather-data-lake-{your-account-id} 3.4 Cấu hình Function Memory: 256 MB Timeout: 5 minutes Reserved Concurrency: 2 Bước 4: Lambda Function cho Weather Forecast 4.1 Tạo Forecast Function Tạo function mới Function Name: weather-forecast-collector Runtime: Python 3.11 Execution Role: WeatherCollectorLambdaRole 4.2 Forecast Function Code import json import boto3 import requests import os from datetime import datetime, timezone from typing import Dict, List, Optional import logging logger = logging.getLogger() logger.setLevel(logging.INFO) s3_client = boto3.client(\u0026#39;s3\u0026#39;) ssm_client = boto3.client(\u0026#39;ssm\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) BUCKET_NAME = os.environ.get(\u0026#39;WEATHER_BUCKET_NAME\u0026#39;) API_KEY_PARAMETER = \u0026#39;/weather-etl/openweathermap/api-key\u0026#39; CITIES = [ {\u0026#39;name\u0026#39;: \u0026#39;Ho Chi Minh City\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;VN\u0026#39;, \u0026#39;lat\u0026#39;: 10.8231, \u0026#39;lon\u0026#39;: 106.6297}, {\u0026#39;name\u0026#39;: \u0026#39;Hanoi\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;VN\u0026#39;, \u0026#39;lat\u0026#39;: 21.0285, \u0026#39;lon\u0026#39;: 105.8542}, {\u0026#39;name\u0026#39;: \u0026#39;Singapore\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;SG\u0026#39;, \u0026#39;lat\u0026#39;: 1.3521, \u0026#39;lon\u0026#39;: 103.8198}, {\u0026#39;name\u0026#39;: \u0026#39;Bangkok\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;TH\u0026#39;, \u0026#39;lat\u0026#39;: 13.7563, \u0026#39;lon\u0026#39;: 100.5018}, {\u0026#39;name\u0026#39;: \u0026#39;Jakarta\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;ID\u0026#39;, \u0026#39;lat\u0026#39;: -6.2088, \u0026#39;lon\u0026#39;: 106.8456}, {\u0026#39;name\u0026#39;: \u0026#39;Kuala Lumpur\u0026#39;, \u0026#39;country\u0026#39;: \u0026#39;MY\u0026#39;, \u0026#39;lat\u0026#39;: 3.1390, \u0026#39;lon\u0026#39;: 101.6869} ] def get_api_key() -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Lấy OpenWeatherMap API key từ Parameter Store.\u0026#34;\u0026#34;\u0026#34; try: response = ssm_client.get_parameter( Name=API_KEY_PARAMETER, WithDecryption=True ) return response[\u0026#39;Parameter\u0026#39;][\u0026#39;Value\u0026#39;] except Exception as e: logger.error(f\u0026#34;Không thể lấy API key: {e}\u0026#34;) raise def fetch_weather_forecast(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Lấy dữ liệu dự báo thời tiết 5 ngày cho một thành phố.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/forecast\u0026#34; params = { \u0026#39;lat\u0026#39;: city[\u0026#39;lat\u0026#39;], \u0026#39;lon\u0026#39;: city[\u0026#39;lon\u0026#39;], \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39;, \u0026#39;lang\u0026#39;: \u0026#39;vi\u0026#39;, \u0026#39;cnt\u0026#39;: 40 # 5 ngày x 8 dự báo (mỗi 3 giờ) } try: response = requests.get(base_url, params=params, timeout=30) response.raise_for_status() data = response.json() # Thêm metadata data[\u0026#39;collection_timestamp\u0026#39;] = datetime.now(timezone.utc).isoformat() data[\u0026#39;city_metadata\u0026#39;] = city return data except requests.exceptions.RequestException as e: logger.error(f\u0026#34;Lỗi API forecast cho {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None except json.JSONDecodeError as e: logger.error(f\u0026#34;Lỗi JSON decode forecast cho {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None def save_forecast_to_s3(data: Dict, city_name: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Lưu dữ liệu dự báo thời tiết vào S3.\u0026#34;\u0026#34;\u0026#34; try: now = datetime.now(timezone.utc) city_safe = city_name.lower().replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;) key = f\u0026#34;raw/forecast/year={now.year}/month={now.month:02d}/day={now.day:02d}/{city_safe}_{now.strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;)}.json\u0026#34; s3_client.put_object( Bucket=BUCKET_NAME, Key=key, Body=json.dumps(data, ensure_ascii=False, indent=2), ContentType=\u0026#39;application/json\u0026#39;, Metadata={ \u0026#39;city\u0026#39;: city_name, \u0026#39;collection_time\u0026#39;: now.isoformat(), \u0026#39;data_type\u0026#39;: \u0026#39;forecast\u0026#39;, \u0026#39;forecast_count\u0026#39;: str(len(data.get(\u0026#39;list\u0026#39;, []))) } ) logger.info(f\u0026#34;Đã lưu dự báo cho {city_name} tại {key}\u0026#34;) return True except Exception as e: logger.error(f\u0026#34;Lỗi lưu forecast S3 cho {city_name}: {e}\u0026#34;) return False def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Handler chính cho forecast Lambda function.\u0026#34;\u0026#34;\u0026#34; logger.info(f\u0026#34;Bắt đầu thu thập dự báo thời tiết: {json.dumps(event)}\u0026#34;) successful_collections = 0 failed_collections = 0 results = [] try: api_key = get_api_key() for city in CITIES: logger.info(f\u0026#34;Thu thập dự báo cho {city[\u0026#39;name\u0026#39;]}\u0026#34;) forecast_data = fetch_weather_forecast(city, api_key) if forecast_data: if save_forecast_to_s3(forecast_data, city[\u0026#39;name\u0026#39;]): successful_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;success\u0026#39;, \u0026#39;forecast_points\u0026#39;: len(forecast_data.get(\u0026#39;list\u0026#39;, [])) }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;S3 save failed\u0026#39; }) else: failed_collections += 1 results.append({ \u0026#39;city\u0026#39;: city[\u0026#39;name\u0026#39;], \u0026#39;status\u0026#39;: \u0026#39;failed\u0026#39;, \u0026#39;error\u0026#39;: \u0026#39;API fetch failed\u0026#39; }) # Gửi metrics cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;SuccessfulForecastCollections\u0026#39;, \u0026#39;Value\u0026#39;: successful_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39; }, { \u0026#39;MetricName\u0026#39;: \u0026#39;FailedForecastCollections\u0026#39;, \u0026#39;Value\u0026#39;: failed_collections, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39; } ] ) logger.info(f\u0026#34;Thu thập dự báo hoàn tất - Thành công: {successful_collections}, Thất bại: {failed_collections}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Thu thập dự báo thời tiết hoàn tất\u0026#39;, \u0026#39;successful_collections\u0026#39;: successful_collections, \u0026#39;failed_collections\u0026#39;: failed_collections, \u0026#39;results\u0026#39;: results }, ensure_ascii=False) } except Exception as e: logger.error(f\u0026#34;Lỗi trong forecast lambda handler: {e}\u0026#34;) cloudwatch.put_metric_data( Namespace=\u0026#39;Weather/ETL\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;ForecastLambdaErrors\u0026#39;, \u0026#39;Value\u0026#39;: 1, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39; } ] ) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Lỗi nội bộ forecast\u0026#39;, \u0026#39;message\u0026#39;: str(e) }, ensure_ascii=False) } Bước 5: Testing Lambda Functions 5.1 Test Manual Test current weather function\nVào Lambda Console → weather-current-collector Tạo test event với payload rỗng {} Click \u0026ldquo;Test\u0026rdquo; và kiểm tra logs Test forecast function\nVào Lambda Console → weather-forecast-collector Tạo test event với payload rỗng {} Click \u0026ldquo;Test\u0026rdquo; và kiểm tra logs 5.2 Verify S3 Data Kiểm tra dữ liệu trong S3 bucket:\naws s3 ls s3://weather-data-lake-{your-account-id}/raw/ --recursive Bạn sẽ thấy các file JSON được tạo trong cấu trúc partition theo thời gian.\nTóm tắt Trong phần này, chúng ta đã:\n✅ Tạo IAM roles và policies cho Lambda functions\n✅ Thiết lập S3 bucket với cấu trúc partition\n✅ Xây dựng Lambda function thu thập thời tiết hiện tại\n✅ Xây dựng Lambda function thu thập dự báo thời tiết\n✅ Cấu hình error handling và CloudWatch metrics\n✅ Test các functions thành công\nTiếp theo: Trong module 2.3, chúng ta sẽ thiết lập automated scheduling với CloudWatch Events để chạy các functions này theo lịch trình.\n"
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.3-automated-scheduling/",
	"title": "Lập lịch Tự động với CloudWatch Events",
	"tags": [],
	"description": "",
	"content": "Lập lịch Tự động với CloudWatch Events Trong phần này, chúng ta sẽ thiết lập lập lịch tự động cho việc thu thập dữ liệu thời tiết bằng Amazon CloudWatch Events (giờ được gọi là Amazon EventBridge). Điều này sẽ đảm bảo các Lambda functions chạy theo lịch trình đều đặn để thu thập dữ liệu thời tiết một cách nhất quán.\nTổng quan Kiến trúc graph TD\rA[CloudWatch Events Rules] --\u0026gt; B[Current Weather Schedule\u0026lt;br/\u0026gt;Mỗi Giờ]\rA --\u0026gt; C[Forecast Schedule\u0026lt;br/\u0026gt;Mỗi 6 Giờ]\rB --\u0026gt; D[Lambda: weather-current-collector]\rC --\u0026gt; E[Lambda: weather-forecast-collector]\rD --\u0026gt; F[S3: Current Weather Data]\rE --\u0026gt; G[S3: Forecast Data]\rH[CloudWatch Alarms] --\u0026gt; I[SNS Notifications]\rstyle A fill:#e8f5e8\rstyle D fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle E fill:#ff9900,stroke:#232f3e,stroke-width:3px Bước 1: Tạo CloudWatch Events Rules 1.1 Lịch trình cho Current Weather Collection Điều hướng đến CloudWatch Console\nAWS Console → CloudWatch → Events → Rules Click \u0026ldquo;Create rule\u0026rdquo; Cấu hình Event Source\nEvent Source: Schedule Schedule Expression: rate(1 hour) Description: \u0026ldquo;Trigger current weather collection every hour\u0026rdquo; Cấu hình Target\nTarget: Lambda function Function: weather-current-collector Configure input: Constant (JSON text) Input JSON:\n{ \u0026#34;source\u0026#34;: \u0026#34;cloudwatch-events\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Scheduled Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;collection_type\u0026#34;: \u0026#34;current_weather\u0026#34;, \u0026#34;scheduled_time\u0026#34;: \u0026#34;hourly\u0026#34; } } Chi tiết Rule Name: weather-current-hourly Description: \u0026ldquo;Thu thập dữ liệu thời tiết hiện tại hàng giờ cho 6 thành phố\u0026rdquo; State: Enabled 1.2 Lịch trình cho Weather Forecast Collection Tạo Rule thứ hai\nEvent Source: Schedule Schedule Expression: rate(6 hours) Description: \u0026ldquo;Trigger weather forecast collection every 6 hours\u0026rdquo; Cấu hình Target\nTarget: Lambda function Function: weather-forecast-collector Input JSON:\n{ \u0026#34;source\u0026#34;: \u0026#34;cloudwatch-events\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Scheduled Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;collection_type\u0026#34;: \u0026#34;forecast\u0026#34;, \u0026#34;scheduled_time\u0026#34;: \u0026#34;every_6_hours\u0026#34; } } Chi tiết Rule Name: weather-forecast-6hourly Description: \u0026ldquo;Thu thập dữ liệu dự báo thời tiết 6 giờ một lần\u0026rdquo; State: Enabled Bước 2: Tùy chọn Lập lịch Nâng cao 2.1 Sử dụng Cron Expressions Để lập lịch chính xác hơn, bạn có thể sử dụng cron expressions:\nCurrent Weather tại các thời điểm cụ thể:\ncron(0 0,6,12,18 * * ? *) Chạy lúc 00:00, 06:00, 12:00, và 18:00 UTC hàng ngày.\nForecast lúc 06:00 và 18:00 UTC:\ncron(0 6,18 * * ? *) Hàng giờ trong giờ làm việc (UTC+7):\ncron(0 1-14 * * ? *) Chạy hàng giờ từ 01:00 đến 14:00 UTC (08:00 đến 21:00 giờ Việt Nam).\n2.2 Lịch trình Khác nhau cho Các Thành phố Khác nhau Tạo các rules theo thành phố:\nRule cho Các Thành phố Châu Á (UTC+7/+8):\n{ \u0026#34;source\u0026#34;: \u0026#34;cloudwatch-events\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;cities\u0026#34;: [\u0026#34;Ho Chi Minh City\u0026#34;, \u0026#34;Hanoi\u0026#34;, \u0026#34;Singapore\u0026#34;, \u0026#34;Bangkok\u0026#34;], \u0026#34;timezone\u0026#34;: \u0026#34;Asia/Ho_Chi_Minh\u0026#34; } } Schedule: cron(0 1,7,13,19 * * ? *) (Giờ cao điểm ở châu Á)\nBước 3: Tạo SNS Topic cho Thông báo 3.1 Thiết lập SNS Topic Điều hướng đến SNS Console\nAWS Console → SNS → Topics Click \u0026ldquo;Create topic\u0026rdquo; Cấu hình Topic\nType: Standard Name: weather-collection-alerts Display Name: \u0026ldquo;Weather Collection Alerts\u0026rdquo; Tạo Subscription\nProtocol: Email Endpoint: Địa chỉ email của bạn Xác nhận subscription qua email 3.2 SNS Topic Policy { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AllowCloudWatchAlarmsToPublish\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;cloudwatch.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;SNS:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:sns:us-east-1:123456789012:weather-collection-alerts\u0026#34; } ] } Bước 4: Thiết lập Monitoring và Alarms 4.1 Lambda Function Alarms Error Rate Alarm:\n{ \u0026#34;AlarmName\u0026#34;: \u0026#34;WeatherCollection-HighErrorRate\u0026#34;, \u0026#34;AlarmDescription\u0026#34;: \u0026#34;Tỷ lệ lỗi cao trong các functions thu thập thời tiết\u0026#34;, \u0026#34;MetricName\u0026#34;: \u0026#34;Errors\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Statistic\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;Period\u0026#34;: 3600, \u0026#34;EvaluationPeriods\u0026#34;: 1, \u0026#34;Threshold\u0026#34;: 2, \u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GreaterThanOrEqualToThreshold\u0026#34;, \u0026#34;Dimensions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;FunctionName\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;weather-current-collector\u0026#34; } ], \u0026#34;AlarmActions\u0026#34;: [ \u0026#34;arn:aws:sns:us-east-1:123456789012:weather-collection-alerts\u0026#34; ] } Duration Alarm:\n{ \u0026#34;AlarmName\u0026#34;: \u0026#34;WeatherCollection-LongDuration\u0026#34;, \u0026#34;AlarmDescription\u0026#34;: \u0026#34;Thời gian thực thi Lambda quá lâu\u0026#34;, \u0026#34;MetricName\u0026#34;: \u0026#34;Duration\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Statistic\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;Period\u0026#34;: 300, \u0026#34;EvaluationPeriods\u0026#34;: 2, \u0026#34;Threshold\u0026#34;: 240000, \u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GreaterThanThreshold\u0026#34;, \u0026#34;Unit\u0026#34;: \u0026#34;Milliseconds\u0026#34; } 4.2 Custom Metrics Alarms Collection Success Rate:\n{ \u0026#34;AlarmName\u0026#34;: \u0026#34;WeatherCollection-LowSuccessRate\u0026#34;, \u0026#34;AlarmDescription\u0026#34;: \u0026#34;Tỷ lệ thành công thu thập thấp\u0026#34;, \u0026#34;MetricName\u0026#34;: \u0026#34;SuccessfulCollections\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;Weather/ETL\u0026#34;, \u0026#34;Statistic\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;Period\u0026#34;: 3600, \u0026#34;EvaluationPeriods\u0026#34;: 1, \u0026#34;Threshold\u0026#34;: 4, \u0026#34;ComparisonOperator\u0026#34;: \u0026#34;LessThanThreshold\u0026#34; } API Call Failures:\n{ \u0026#34;AlarmName\u0026#34;: \u0026#34;WeatherAPI-HighFailureRate\u0026#34;, \u0026#34;AlarmDescription\u0026#34;: \u0026#34;Tỷ lệ thất bại API cao\u0026#34;, \u0026#34;MetricName\u0026#34;: \u0026#34;FailedCollections\u0026#34;, \u0026#34;Namespace\u0026#34;: \u0026#34;Weather/ETL\u0026#34;, \u0026#34;Statistic\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;Period\u0026#34;: 1800, \u0026#34;EvaluationPeriods\u0026#34;: 2, \u0026#34;Threshold\u0026#34;: 3, \u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GreaterThanThreshold\u0026#34; } Bước 5: CloudWatch Dashboard 5.1 Tạo Weather ETL Dashboard Điều hướng đến CloudWatch Console\nAWS Console → CloudWatch → Dashboards Click \u0026ldquo;Create dashboard\u0026rdquo; Dashboard Configuration\nDashboard Name: Weather-ETL-Monitoring Description: \u0026ldquo;Weather data collection monitoring dashboard\u0026rdquo; 5.2 Dashboard Widgets Widget 1: Collection Success Rate\n{ \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;Weather/ETL\u0026#34;, \u0026#34;SuccessfulCollections\u0026#34;], [\u0026#34;Weather/ETL\u0026#34;, \u0026#34;FailedCollections\u0026#34;] ], \u0026#34;period\u0026#34;: 3600, \u0026#34;stat\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Tỷ lệ Thu thập Thành công\u0026#34;, \u0026#34;yAxis\u0026#34;: { \u0026#34;left\u0026#34;: { \u0026#34;min\u0026#34;: 0 } } } } Widget 2: Lambda Performance\n{ \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-current-collector\u0026#34;], [\u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-forecast-collector\u0026#34;] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Thời gian Thực thi Lambda\u0026#34;, \u0026#34;yAxis\u0026#34;: { \u0026#34;left\u0026#34;: { \u0026#34;min\u0026#34;: 0 } } } } Widget 3: Error Rate\n{ \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Errors\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-current-collector\u0026#34;], [\u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Errors\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-forecast-collector\u0026#34;] ], \u0026#34;period\u0026#34;: 3600, \u0026#34;stat\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Tỷ lệ Lỗi Lambda\u0026#34; } } Bước 6: Cost Optimization 6.1 Optimized Scheduling Strategy Giờ cao điểm vs. Giờ thấp điểm:\nGiờ cao điểm (7:00-22:00 VN): Thu thập mỗi giờ Giờ thấp điểm (22:00-7:00 VN): Thu thập mỗi 3 giờ Cron Expression cho Giờ cao điểm:\ncron(0 0-15 * * ? *) Cron Expression cho Giờ thấp điểm:\ncron(0 16,19,22 * * ? *) 6.2 Regional Data Collection Khu vực Đông Nam Á:\ncron(0 1,7,13,19 * * ? *) Global Collection (bao gồm multiple regions):\ncron(0 0,6,12,18 * * ? *) Bước 7: Testing Scheduled Execution 7.1 Verify Rule Execution Check CloudWatch Events Console\nAWS Console → CloudWatch → Events → Rules Verify rules are enabled and showing recent invocations Check Lambda Function Metrics\nAWS Console → Lambda → Functions Check Invocations và Duration metrics 7.2 Manual Rule Testing Test Current Weather Rule:\naws events put-events --entries Source=manual-test,DetailType=\u0026#34;Manual Test\u0026#34;,Detail=\u0026#39;{\u0026#34;test\u0026#34;: true}\u0026#39; Check S3 for New Data:\naws s3 ls s3://weather-data-lake-123456789012/raw/current-weather/ --recursive --human-readable Troubleshooting 7.3 Common Issues Rule không trigger:\nKiểm tra IAM permissions cho CloudWatch Events Verify Lambda function permissions Check rule state (Enabled/Disabled) Lambda timeout:\nTăng timeout setting (hiện tại: 5 minutes) Optimize code hoặc giảm số lượng cities API rate limits:\nMonitor OpenWeatherMap API usage Implement exponential backoff Consider upgrading API plan nếu cần Tóm tắt Trong phần này, chúng ta đã:\n✅ Thiết lập CloudWatch Events rules cho automated scheduling\n✅ Cấu hình lịch trình hàng giờ cho current weather\n✅ Cấu hình lịch trình 6 giờ/lần cho forecast data\n✅ Tạo SNS topic để nhận alerts\n✅ Thiết lập CloudWatch alarms và dashboard\n✅ Optimize cost với smart scheduling\n✅ Test scheduled execution thành công\nTiếp theo: Trong module 2.4, chúng ta sẽ thiết lập testing và monitoring toàn diện để đảm bảo hệ thống chạy ổn định và đáng tin cậy.\n"
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/2.4-testing-monitoring/",
	"title": "Testing và Monitoring Thu thập Thời tiết",
	"tags": [],
	"description": "",
	"content": "Testing và Monitoring Thu thập Thời tiết Bây giờ chúng ta đã có các Lambda functions và automated scheduling được cấu hình, đã đến lúc test toàn diện pipeline thu thập thời tiết và thiết lập monitoring chi tiết. Chúng ta sẽ validate data quality, performance, và đảm bảo hệ thống chạy đáng tin cậy.\nTổng quan Testing Strategy Chúng ta sẽ test hệ thống thu thập thời tiết bằng:\nManual Function Testing - Gọi Lambda trực tiếp Scheduled Execution Testing - Validate CloudWatch Events Data Quality Validation - Kiểm tra dữ liệu S3 Performance Testing - Phân tích load và timing Error Scenario Testing - Validate xử lý lỗi graph LR\rA[Manual Tests] --\u0026gt; B[Lambda Functions]\rC[Scheduled Tests] --\u0026gt; D[CloudWatch Events]\rE[Data Quality Tests] --\u0026gt; F[S3 Storage]\rG[Performance Tests] --\u0026gt; H[CloudWatch Metrics]\rI[Error Tests] --\u0026gt; J[Error Handling]\rstyle B fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle F fill:#f3e5f5\rstyle H fill:#e8f5e8 Bước 1: Manual Function Testing 1.1 Test Current Weather Function Điều hướng đến Lambda Console\nAWS Console → Lambda → Functions Click weather-current-collector Tạo Test Event\n{ \u0026#34;source\u0026#34;: \u0026#34;manual-test\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Manual Test Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;test_mode\u0026#34;: true, \u0026#34;cities_to_test\u0026#34;: [\u0026#34;Ho Chi Minh City\u0026#34;, \u0026#34;Singapore\u0026#34;] } } Chạy Test\nClick nút \u0026ldquo;Test\u0026rdquo; Đợi execution hoàn tất Review kết quả execution Kết quả Mong đợi:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: \u0026#34;{\\\u0026#34;message\\\u0026#34;: \\\u0026#34;Thu thập thời tiết hoàn tất\\\u0026#34;, \\\u0026#34;successful_collections\\\u0026#34;: 6, \\\u0026#34;failed_collections\\\u0026#34;: 0, \\\u0026#34;results\\\u0026#34;: [...]}\u0026#34; } 1.2 Test Weather Forecast Function Điều hướng đến forecast function\nClick weather-forecast-collector Tạo Test Event\n{ \u0026#34;source\u0026#34;: \u0026#34;manual-test\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;Manual Test Event\u0026#34;, \u0026#34;detail\u0026#34;: { \u0026#34;test_mode\u0026#34;: true, \u0026#34;include_extended_forecast\u0026#34;: true } } Verify Test Results\nKiểm tra execution logs trong CloudWatch Verify S3 objects được tạo Validate cấu trúc JSON Bước 2: Data Quality Validation 2.1 S3 Data Structure Verification Kiểm tra S3 Bucket Structure:\naws s3 ls s3://weather-data-lake-123456789012/ --recursive Cấu trúc Mong đợi:\nweather-data-lake-123456789012/\r├── raw/\r│ ├── current-weather/\r│ │ └── year=2025/month=01/day=03/hour=14/\r│ │ ├── ho_chi_minh_city_20250103_140532.json\r│ │ ├── hanoi_20250103_140534.json\r│ │ ├── singapore_20250103_140536.json\r│ │ ├── bangkok_20250103_140538.json\r│ │ ├── jakarta_20250103_140540.json\r│ │ └── kuala_lumpur_20250103_140542.json\r│ └── forecast/\r│ └── year=2025/month=01/day=03/\r│ ├── ho_chi_minh_city_20250103_140612.json\r│ └── ... 2.2 Data Quality Validation Script File: validate_weather_data.py\nimport boto3 import json import pandas as pd from datetime import datetime, timedelta from typing import Dict, List, Optional import logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) class WeatherDataValidator: def __init__(self, bucket_name: str): self.s3 = boto3.client(\u0026#39;s3\u0026#39;) self.bucket_name = bucket_name def get_recent_files(self, data_type: str = \u0026#39;current-weather\u0026#39;, hours_back: int = 24) -\u0026gt; List[str]: \u0026#34;\u0026#34;\u0026#34;Lấy các file dữ liệu thời tiết từ N giờ trước.\u0026#34;\u0026#34;\u0026#34; files = [] now = datetime.utcnow() for hour_offset in range(hours_back): check_time = now - timedelta(hours=hour_offset) prefix = f\u0026#34;raw/{data_type}/year={check_time.year}/month={check_time.month:02d}/day={check_time.day:02d}/\u0026#34; if data_type == \u0026#39;current-weather\u0026#39;: prefix += f\u0026#34;hour={check_time.hour:02d}/\u0026#34; try: response = self.s3.list_objects_v2( Bucket=self.bucket_name, Prefix=prefix ) for obj in response.get(\u0026#39;Contents\u0026#39;, []): files.append(obj[\u0026#39;Key\u0026#39;]) except Exception as e: logger.warning(f\u0026#34;Không thể list objects cho {prefix}: {e}\u0026#34;) return files def validate_current_weather_file(self, file_key: str) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Validate một file dữ liệu thời tiết hiện tại.\u0026#34;\u0026#34;\u0026#34; try: response = self.s3.get_object(Bucket=self.bucket_name, Key=file_key) data = json.loads(response[\u0026#39;Body\u0026#39;].read()) validation_results = { \u0026#39;file_key\u0026#39;: file_key, \u0026#39;valid\u0026#39;: True, \u0026#39;errors\u0026#39;: [], \u0026#39;warnings\u0026#39;: [] } # Required fields validation required_fields = [ \u0026#39;coord\u0026#39;, \u0026#39;weather\u0026#39;, \u0026#39;main\u0026#39;, \u0026#39;wind\u0026#39;, \u0026#39;clouds\u0026#39;, \u0026#39;dt\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;timezone\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;cod\u0026#39; ] for field in required_fields: if field not in data: validation_results[\u0026#39;errors\u0026#39;].append(f\u0026#34;Thiếu field bắt buộc: {field}\u0026#34;) validation_results[\u0026#39;valid\u0026#39;] = False # Temperature validation if \u0026#39;main\u0026#39; in data and \u0026#39;temp\u0026#39; in data[\u0026#39;main\u0026#39;]: temp = data[\u0026#39;main\u0026#39;][\u0026#39;temp\u0026#39;] if not (-50 \u0026lt;= temp \u0026lt;= 60): # Khoảng nhiệt độ hợp lý (Celsius) validation_results[\u0026#39;warnings\u0026#39;].append(f\u0026#34;Nhiệt độ có vẻ bất thường: {temp}°C\u0026#34;) # Humidity validation if \u0026#39;main\u0026#39; in data and \u0026#39;humidity\u0026#39; in data[\u0026#39;main\u0026#39;]: humidity = data[\u0026#39;main\u0026#39;][\u0026#39;humidity\u0026#39;] if not (0 \u0026lt;= humidity \u0026lt;= 100): validation_results[\u0026#39;errors\u0026#39;].append(f\u0026#34;Độ ẩm không hợp lệ: {humidity}%\u0026#34;) validation_results[\u0026#39;valid\u0026#39;] = False # Metadata validation if \u0026#39;collection_timestamp\u0026#39; not in data: validation_results[\u0026#39;warnings\u0026#39;].append(\u0026#34;Thiếu collection_timestamp\u0026#34;) if \u0026#39;city_metadata\u0026#39; not in data: validation_results[\u0026#39;warnings\u0026#39;].append(\u0026#34;Thiếu city_metadata\u0026#34;) return validation_results except Exception as e: return { \u0026#39;file_key\u0026#39;: file_key, \u0026#39;valid\u0026#39;: False, \u0026#39;errors\u0026#39;: [f\u0026#34;Lỗi đọc file: {str(e)}\u0026#34;], \u0026#39;warnings\u0026#39;: [] } def run_validation_report(self) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Chạy báo cáo validation toàn diện.\u0026#34;\u0026#34;\u0026#34; report = { \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat(), \u0026#39;current_weather\u0026#39;: { \u0026#39;total_files\u0026#39;: 0, \u0026#39;valid_files\u0026#39;: 0, \u0026#39;invalid_files\u0026#39;: 0, \u0026#39;warnings\u0026#39;: 0, \u0026#39;details\u0026#39;: [] }, \u0026#39;forecast\u0026#39;: { \u0026#39;total_files\u0026#39;: 0, \u0026#39;valid_files\u0026#39;: 0, \u0026#39;invalid_files\u0026#39;: 0, \u0026#39;warnings\u0026#39;: 0, \u0026#39;details\u0026#39;: [] } } # Validate current weather files current_files = self.get_recent_files(\u0026#39;current-weather\u0026#39;, 24) report[\u0026#39;current_weather\u0026#39;][\u0026#39;total_files\u0026#39;] = len(current_files) for file_key in current_files: validation = self.validate_current_weather_file(file_key) report[\u0026#39;current_weather\u0026#39;][\u0026#39;details\u0026#39;].append(validation) if validation[\u0026#39;valid\u0026#39;]: report[\u0026#39;current_weather\u0026#39;][\u0026#39;valid_files\u0026#39;] += 1 else: report[\u0026#39;current_weather\u0026#39;][\u0026#39;invalid_files\u0026#39;] += 1 if validation[\u0026#39;warnings\u0026#39;]: report[\u0026#39;current_weather\u0026#39;][\u0026#39;warnings\u0026#39;] += len(validation[\u0026#39;warnings\u0026#39;]) # Validate forecast files forecast_files = self.get_recent_files(\u0026#39;forecast\u0026#39;, 24) report[\u0026#39;forecast\u0026#39;][\u0026#39;total_files\u0026#39;] = len(forecast_files) logger.info(f\u0026#34;Validation hoàn tất: {report[\u0026#39;current_weather\u0026#39;][\u0026#39;valid_files\u0026#39;]}/{report[\u0026#39;current_weather\u0026#39;][\u0026#39;total_files\u0026#39;]} current weather files hợp lệ\u0026#34;) return report # Sử dụng validator if __name__ == \u0026#34;__main__\u0026#34;: validator = WeatherDataValidator(\u0026#39;weather-data-lake-123456789012\u0026#39;) report = validator.run_validation_report() print(json.dumps(report, indent=2, ensure_ascii=False)) Bước 3: Performance Testing 3.1 Load Testing Script File: load_test.py\nimport boto3 import json import time import concurrent.futures from datetime import datetime import logging logger = logging.getLogger(__name__) class LoadTester: def __init__(self): self.lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) self.cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) def invoke_lambda_function(self, function_name: str, payload: Dict) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Gọi Lambda function và đo thời gian response.\u0026#34;\u0026#34;\u0026#34; start_time = time.time() try: response = self.lambda_client.invoke( FunctionName=function_name, InvocationType=\u0026#39;RequestResponse\u0026#39;, Payload=json.dumps(payload) ) end_time = time.time() duration = (end_time - start_time) * 1000 # milliseconds return { \u0026#39;success\u0026#39;: True, \u0026#39;duration_ms\u0026#39;: duration, \u0026#39;status_code\u0026#39;: response[\u0026#39;StatusCode\u0026#39;], \u0026#39;function_name\u0026#39;: function_name } except Exception as e: end_time = time.time() duration = (end_time - start_time) * 1000 return { \u0026#39;success\u0026#39;: False, \u0026#39;duration_ms\u0026#39;: duration, \u0026#39;error\u0026#39;: str(e), \u0026#39;function_name\u0026#39;: function_name } def run_concurrent_test(self, function_name: str, concurrent_calls: int = 5) -\u0026gt; List[Dict]: \u0026#34;\u0026#34;\u0026#34;Chạy nhiều lambda calls đồng thời.\u0026#34;\u0026#34;\u0026#34; results = [] payload = { \u0026#39;source\u0026#39;: \u0026#39;load-test\u0026#39;, \u0026#39;detail-type\u0026#39;: \u0026#39;Load Test Event\u0026#39;, \u0026#39;detail\u0026#39;: {\u0026#39;test_id\u0026#39;: f\u0026#39;load-test-{int(time.time())}\u0026#39;} } with concurrent.futures.ThreadPoolExecutor(max_workers=concurrent_calls) as executor: futures = [ executor.submit(self.invoke_lambda_function, function_name, payload) for _ in range(concurrent_calls) ] for future in concurrent.futures.as_completed(futures): results.append(future.result()) return results def analyze_results(self, results: List[Dict]) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Phân tích kết quả load test.\u0026#34;\u0026#34;\u0026#34; successful_calls = [r for r in results if r[\u0026#39;success\u0026#39;]] failed_calls = [r for r in results if not r[\u0026#39;success\u0026#39;]] durations = [r[\u0026#39;duration_ms\u0026#39;] for r in successful_calls] analysis = { \u0026#39;total_calls\u0026#39;: len(results), \u0026#39;successful_calls\u0026#39;: len(successful_calls), \u0026#39;failed_calls\u0026#39;: len(failed_calls), \u0026#39;success_rate\u0026#39;: len(successful_calls) / len(results) * 100, \u0026#39;avg_duration_ms\u0026#39;: sum(durations) / len(durations) if durations else 0, \u0026#39;min_duration_ms\u0026#39;: min(durations) if durations else 0, \u0026#39;max_duration_ms\u0026#39;: max(durations) if durations else 0, \u0026#39;errors\u0026#39;: [r[\u0026#39;error\u0026#39;] for r in failed_calls] } return analysis # Chạy load test if __name__ == \u0026#34;__main__\u0026#34;: tester = LoadTester() print(\u0026#34;🚀 Bắt đầu load test cho weather-current-collector...\u0026#34;) results = tester.run_concurrent_test(\u0026#39;weather-current-collector\u0026#39;, 3) analysis = tester.analyze_results(results) print(f\u0026#34;📊 Kết quả load test:\u0026#34;) print(f\u0026#34; Tổng calls: {analysis[\u0026#39;total_calls\u0026#39;]}\u0026#34;) print(f\u0026#34; Thành công: {analysis[\u0026#39;successful_calls\u0026#39;]}\u0026#34;) print(f\u0026#34; Thất bại: {analysis[\u0026#39;failed_calls\u0026#39;]}\u0026#34;) print(f\u0026#34; Success rate: {analysis[\u0026#39;success_rate\u0026#39;]:.1f}%\u0026#34;) print(f\u0026#34; Avg duration: {analysis[\u0026#39;avg_duration_ms\u0026#39;]:.0f}ms\u0026#34;) print(f\u0026#34; Min duration: {analysis[\u0026#39;min_duration_ms\u0026#39;]:.0f}ms\u0026#34;) print(f\u0026#34; Max duration: {analysis[\u0026#39;max_duration_ms\u0026#39;]:.0f}ms\u0026#34;) Bước 4: Error Scenario Testing 4.1 API Key Error Test Test với API key không hợp lệ:\n# Test script để kiểm tra error handling khi API key sai import boto3 ssm = boto3.client(\u0026#39;ssm\u0026#39;) # Backup API key hiện tại original_key = ssm.get_parameter( Name=\u0026#39;/weather-etl/openweathermap/api-key\u0026#39;, WithDecryption=True )[\u0026#39;Parameter\u0026#39;][\u0026#39;Value\u0026#39;] # Set API key không hợp lệ ssm.put_parameter( Name=\u0026#39;/weather-etl/openweathermap/api-key\u0026#39;, Value=\u0026#39;invalid-key-12345\u0026#39;, Type=\u0026#39;SecureString\u0026#39;, Overwrite=True ) # Test Lambda function lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) response = lambda_client.invoke( FunctionName=\u0026#39;weather-current-collector\u0026#39;, InvocationType=\u0026#39;RequestResponse\u0026#39;, Payload=\u0026#39;{\u0026#34;source\u0026#34;: \u0026#34;error-test\u0026#34;}\u0026#39; ) print(\u0026#34;Response với API key không hợp lệ:\u0026#34;, json.loads(response[\u0026#39;Payload\u0026#39;].read())) # Restore original API key ssm.put_parameter( Name=\u0026#39;/weather-etl/openweathermap/api-key\u0026#39;, Value=original_key, Type=\u0026#39;SecureString\u0026#39;, Overwrite=True ) 4.2 Network Timeout Test Test network timeout scenario:\n# Modify Lambda function để simulate network timeout # Thêm vào Lambda function code: def fetch_current_weather_with_timeout(city: Dict, api_key: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Test function với timeout ngắn.\u0026#34;\u0026#34;\u0026#34; base_url = \u0026#34;https://api.openweathermap.org/data/2.5/weather\u0026#34; params = { \u0026#39;lat\u0026#39;: city[\u0026#39;lat\u0026#39;], \u0026#39;lon\u0026#39;: city[\u0026#39;lon\u0026#39;], \u0026#39;appid\u0026#39;: api_key, \u0026#39;units\u0026#39;: \u0026#39;metric\u0026#39; } try: # Timeout rất ngắn để force error response = requests.get(base_url, params=params, timeout=0.1) response.raise_for_status() return response.json() except requests.exceptions.Timeout: logger.error(f\u0026#34;Timeout cho {city[\u0026#39;name\u0026#39;]}\u0026#34;) return None except Exception as e: logger.error(f\u0026#34;Lỗi khác cho {city[\u0026#39;name\u0026#39;]}: {e}\u0026#34;) return None Bước 5: Monitoring Dashboard Setup 5.1 CloudWatch Dashboard JSON Complete dashboard configuration:\n{ \u0026#34;widgets\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;Weather/ETL\u0026#34;, \u0026#34;SuccessfulCollections\u0026#34;], [\u0026#34;Weather/ETL\u0026#34;, \u0026#34;FailedCollections\u0026#34;] ], \u0026#34;period\u0026#34;: 3600, \u0026#34;stat\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Thu thập Thành công vs Thất bại\u0026#34;, \u0026#34;yAxis\u0026#34;: { \u0026#34;left\u0026#34;: { \u0026#34;min\u0026#34;: 0 } } } }, { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [ \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-current-collector\u0026#34; ], [ \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;weather-forecast-collector\u0026#34; ] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Lambda Duration\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;log\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;SOURCE \u0026#39;/aws/lambda/weather-current-collector\u0026#39;\\n| fields @timestamp, @message\\n| filter @message like /ERROR/\\n| sort @timestamp desc\\n| limit 20\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Recent Errors\u0026#34;, \u0026#34;view\u0026#34;: \u0026#34;table\u0026#34; } } ] } Bước 6: Automated Testing Pipeline 6.1 Daily Health Check Lambda File: health_check_lambda.py\nimport json import boto3 from datetime import datetime, timedelta import logging logger = logging.getLogger() logger.setLevel(logging.INFO) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Daily health check cho weather collection system.\u0026#34;\u0026#34;\u0026#34; # Khởi tạo clients s3 = boto3.client(\u0026#39;s3\u0026#39;) sns = boto3.client(\u0026#39;sns\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) bucket_name = \u0026#39;weather-data-lake-123456789012\u0026#39; sns_topic = \u0026#39;arn:aws:sns:us-east-1:123456789012:weather-collection-alerts\u0026#39; health_status = { \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat(), \u0026#39;checks\u0026#39;: [], \u0026#39;overall_status\u0026#39;: \u0026#39;HEALTHY\u0026#39;, \u0026#39;issues\u0026#39;: [] } # Check 1: S3 data freshness try: now = datetime.utcnow() yesterday = now - timedelta(days=1) prefix = f\u0026#34;raw/current-weather/year={yesterday.year}/month={yesterday.month:02d}/day={yesterday.day:02d}/\u0026#34; response = s3.list_objects_v2( Bucket=bucket_name, Prefix=prefix ) file_count = len(response.get(\u0026#39;Contents\u0026#39;, [])) expected_files = 6 * 24 # 6 cities * 24 hours if file_count \u0026lt; expected_files * 0.8: # Allow 20% tolerance health_status[\u0026#39;overall_status\u0026#39;] = \u0026#39;UNHEALTHY\u0026#39; health_status[\u0026#39;issues\u0026#39;].append(f\u0026#34;Thiếu dữ liệu: {file_count}/{expected_files} files\u0026#34;) health_status[\u0026#39;checks\u0026#39;].append({ \u0026#39;name\u0026#39;: \u0026#39;S3 Data Freshness\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39; if file_count \u0026gt;= expected_files * 0.8 else \u0026#39;FAIL\u0026#39;, \u0026#39;details\u0026#39;: f\u0026#34;{file_count} files cho ngày {yesterday.date()}\u0026#34; }) except Exception as e: health_status[\u0026#39;overall_status\u0026#39;] = \u0026#39;UNHEALTHY\u0026#39; health_status[\u0026#39;issues\u0026#39;].append(f\u0026#34;S3 check failed: {str(e)}\u0026#34;) # Check 2: Lambda errors in last 24h try: end_time = datetime.utcnow() start_time = end_time - timedelta(hours=24) response = cloudwatch.get_metric_statistics( Namespace=\u0026#39;AWS/Lambda\u0026#39;, MetricName=\u0026#39;Errors\u0026#39;, Dimensions=[ {\u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: \u0026#39;weather-current-collector\u0026#39;} ], StartTime=start_time, EndTime=end_time, Period=3600, Statistics=[\u0026#39;Sum\u0026#39;] ) total_errors = sum([point[\u0026#39;Sum\u0026#39;] for point in response[\u0026#39;Datapoints\u0026#39;]]) if total_errors \u0026gt; 5: # Threshold health_status[\u0026#39;overall_status\u0026#39;] = \u0026#39;UNHEALTHY\u0026#39; health_status[\u0026#39;issues\u0026#39;].append(f\u0026#34;Quá nhiều Lambda errors: {total_errors}\u0026#34;) health_status[\u0026#39;checks\u0026#39;].append({ \u0026#39;name\u0026#39;: \u0026#39;Lambda Error Rate\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39; if total_errors \u0026lt;= 5 else \u0026#39;FAIL\u0026#39;, \u0026#39;details\u0026#39;: f\u0026#34;{total_errors} errors trong 24h\u0026#34; }) except Exception as e: health_status[\u0026#39;overall_status\u0026#39;] = \u0026#39;UNHEALTHY\u0026#39; health_status[\u0026#39;issues\u0026#39;].append(f\u0026#34;CloudWatch check failed: {str(e)}\u0026#34;) # Gửi alert nếu có vấn đề if health_status[\u0026#39;overall_status\u0026#39;] == \u0026#39;UNHEALTHY\u0026#39;: message = f\u0026#34;Weather ETL Health Check FAILED\\n\\nIssues:\\n\u0026#34; + \u0026#34;\\n\u0026#34;.join(health_status[\u0026#39;issues\u0026#39;]) sns.publish( TopicArn=sns_topic, Message=message, Subject=\u0026#34;⚠️ Weather ETL Health Check Alert\u0026#34; ) logger.info(f\u0026#34;Health check completed: {health_status[\u0026#39;overall_status\u0026#39;]}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(health_status, ensure_ascii=False) } 6.2 Schedule Health Check CloudWatch Events Rule cho daily health check:\n{ \u0026#34;Name\u0026#34;: \u0026#34;weather-etl-daily-health-check\u0026#34;, \u0026#34;ScheduleExpression\u0026#34;: \u0026#34;cron(0 8 * * ? *)\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;ENABLED\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Daily health check lúc 8:00 UTC (15:00 VN)\u0026#34;, \u0026#34;Targets\u0026#34;: [ { \u0026#34;Id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:lambda:us-east-1:123456789012:function:weather-health-check\u0026#34;, \u0026#34;Input\u0026#34;: \u0026#34;{\\\u0026#34;source\\\u0026#34;: \\\u0026#34;daily-health-check\\\u0026#34;}\u0026#34; } ] } Tóm tắt Trong phần này, chúng ta đã:\n✅ Thiết lập comprehensive testing strategy\n✅ Tạo manual và automated tests cho Lambda functions\n✅ Implement data quality validation\n✅ Chạy performance và load testing\n✅ Test error scenarios và error handling\n✅ Thiết lập CloudWatch monitoring dashboard\n✅ Tạo automated daily health checks\n✅ Cấu hình alerts cho issues\nKết quả: Hệ thống weather collection giờ đã có monitoring và testing toàn diện, đảm bảo chạy ổn định và đáng tin cậy.\nTiếp theo: Trong Module 3, chúng ta sẽ xây dựng data processing và transformation pipeline để xử lý dữ liệu thời tiết thô này thành format phù hợp cho analysis.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduction/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Xây dựng ETL Data Pipeline cho phân tích thời tiết trên AWS Mục tiêu Xây dựng hệ thống thu thập dữ liệu serverless sử dụng AWS Lambda Triển khai quy trình chuyển đổi và xử lý dữ liệu Lưu trữ và truy vấn dữ liệu sử dụng Amazon S3 và Athena Tạo trực quan hóa với Amazon QuickSight Áp dụng các best practices của AWS cho tối ưu chi phí và dọn dẹp tài nguyên Tổng quan Kiến trúc Pipeline ETL thời tiết của chúng ta tuân theo kiến trúc serverless đơn giản này: Các thành phần chính:\nNguồn dữ liệu: OpenWeatherMap API cho dữ liệu thời tiết thời gian thực Thu thập: AWS Lambda function để lấy dữ liệu thời tiết Lưu trữ: Amazon S3 cho cả dữ liệu thô và đã xử lý Xử lý: AWS Lambda cho chuyển đổi dữ liệu Phân tích: Amazon Athena cho truy vấn SQL Trực quan hóa: Amazon QuickSight cho dashboard Yêu cầu Tiên quyết Trước khi bắt đầu workshop này, hãy đảm bảo bạn có:\nTài khoản AWS với quyền truy cập quản trị Hiểu biết cơ bản về AWS console Hiểu biết về các khái niệm lập trình cơ bản Tài khoản OpenWeatherMap (tier miễn phí là đủ, ở bài workshop này em sử dụng Developer plan) "
},
{
	"uri": "//localhost:1313/vi/2-data-collection-openweathermap/",
	"title": "Thu thập Dữ liệu Thời tiết với OpenWeatherMap",
	"tags": [],
	"description": "",
	"content": "Trong module này, bạn sẽ học cách thiết lập thu thập dữ liệu thời tiết tự động bằng OpenWeatherMap API và AWS Lambda. Đây là nền tảng của pipeline ETL phân tích thời tiết, nơi chúng ta sẽ xây dựng hệ thống thu thập dữ liệu serverless đáng tin cậy.\nNhững gì bạn sẽ xây dựng Khi hoàn thành module này, bạn sẽ có:\n✅ Tài khoản OpenWeatherMap API với API key được bảo mật ✅ Lambda functions thu thập dữ liệu thời tiết hiện tại và dự báo ✅ Lập lịch tự động bằng CloudWatch Events ✅ Monitoring và testing toàn diện ✅ Error handling và alerting system Các Phần trong Module này Module này được chia thành 4 phần chính:\n2.1 OpenWeatherMap Setup Thiết lập API và Credentials\nThiết lập tài khoản OpenWeatherMap, lấy API key, và cấu hình Systems Manager Parameter Store để lưu trữ credentials một cách bảo mật. Bạn sẽ học cách quản lý API keys và test connectivity.\n📖 Bạn sẽ học: Đăng ký API, bảo mật credentials, test API endpoints\n⏱️ Thời gian: 15-20 phút\n2.2 Lambda Weather Collector Xây dựng Functions Thu thập Dữ liệu\nTạo các Lambda functions để thu thập dữ liệu thời tiết hiện tại và dự báo từ OpenWeatherMap API. Bao gồm IAM roles, S3 bucket setup, và function code với error handling.\n📖 Bạn sẽ học: Lambda development, S3 integration, error handling\n⏱️ Thời gian: 45-60 phút\n2.3 Automated Scheduling Lập lịch Tự động với CloudWatch Events\nThiết lập CloudWatch Events để chạy các Lambda functions theo lịch trình tự động. Cấu hình monitoring, alarms, và notifications để đảm bảo hệ thống chạy ổn định.\n📖 Bạn sẽ học: CloudWatch Events, scheduling patterns, monitoring setup\n⏱️ Thời gian: 30-40 phút\n2.4 Testing và Monitoring Testing và Monitoring Toàn diện\nThiết lập testing strategy bao gồm manual testing, data quality validation, performance testing, và automated health checks. Tạo dashboard để monitor hệ thống.\n📖 Bạn sẽ học: Testing strategies, data validation, performance monitoring\n⏱️ Thời gian: 30-40 phút\nKiến trúc Tổng quan graph LR A[OpenWeatherMap API] --\u0026gt; B[Lambda Weather Collector] C[CloudWatch Events] --\u0026gt; B B --\u0026gt; D[S3 Raw Data Storage] B --\u0026gt; E[CloudWatch Logs] F[Systems Manager] --\u0026gt; B G[SNS Alerts] --\u0026gt; H[Email Notifications] I[CloudWatch Alarms] --\u0026gt; G style A fill:#e1f5fe style B fill:#ff9900,stroke:#232f3e,stroke-width:3px style C fill:#e8f5e8 style D fill:#f3e5f5 style E fill:#fff3e0 style F fill:#e0f2f1 Loại Dữ liệu Thu thập Thu thập dữ liệu thời tiết sẽ tập trung vào:\nThời tiết Hiện tại: Điều kiện thời gian thực cho 6 thành phố SEA Dự báo 5 Ngày: Dự đoán thời tiết mỗi 3 giờ Metadata: Timestamp, location, collection info Thành phố Mục tiêu Chúng ta sẽ thu thập dữ liệu thời tiết cho các thành phố lớn ở Đông Nam Á:\nThành phố Hồ Chí Minh, Việt Nam (Chính) Hà Nội, Việt Nam Singapore Bangkok, Thái Lan Jakarta, Indonesia Kuala Lumpur, Malaysia Lịch trình Thu thập Thời tiết Hiện tại: Mỗi giờ (24 lần/ngày)\nDự báo Thời tiết: Mỗi 6 giờ (4 lần/ngày)\nƯớc tính Chi phí Chi phí hàng tháng cho module này:\nDịch vụ Sử dụng Chi phí OpenWeatherMap API 1,000 calls/ngày Free Lambda Executions 4,000 invocations Free Tier S3 Storage 1 GB dữ liệu thời tiết Free Tier CloudWatch Logs 5 GB logs $2.50 Tổng ~$2.50/tháng OpenWeatherMap cung cấp 1,000 lời gọi API miễn phí mỗi ngày, đủ cho workshop này.\nƯớc tính thời gian hoàn thành: 2-2.5 giờ cho toàn bộ module\nKết quả Mong đợi Sau khi hoàn thành module này, bạn sẽ có:\nHệ thống thu thập dữ liệu thời tiết serverless hoạt động 24/7 Dữ liệu thời tiết được lưu trữ có cấu trúc trong S3 Monitoring và alerting system đầy đủ Kiến thức về AWS Lambda, CloudWatch Events, và S3 integration Bắt đầu Sẵn sàng xây dựng hệ thống thu thập dữ liệu thời tiết? Bắt đầu với 2.1 OpenWeatherMap Setup để thiết lập API và credentials.\n"
},
{
	"uri": "//localhost:1313/vi/3-serverless-processing-lambda/",
	"title": "Xử lý và Chuyển đổi Dữ liệu",
	"tags": [],
	"description": "",
	"content": "Xử lý và Biến đổi Dữ liệu Trong module này, bạn sẽ xây dựng một hàm Lambda để xử lý và biến đổi dữ liệu thời tiết thô được thu thập từ OpenWeatherMap API thành định dạng thân thiện hơn với phân tích. Bước biến đổi này là cần thiết trong bất kỳ pipeline ETL nào để chuẩn bị dữ liệu cho việc phân tích hiệu quả.\nTổng quan Module Dữ liệu thời tiết thô từ API thường chứa cấu trúc lồng nhau phức tạp, định dạng không nhất quán và thông tin không cần thiết. Trong module này, chúng ta sẽ biến đổi dữ liệu thô này thành định dạng có cấu trúc, sạch sẽ được tối ưu hóa cho phân tích.\nThời gian: 45-60 phút\nChi phí: ~$0.50\nNhững gì bạn sẽ xây dựng graph LR A[S3 Raw Data] --\u0026gt; B[Lambda Processor] B --\u0026gt; C[S3 Processed Data] D[CloudWatch Events] --\u0026gt; B style B fill:#ff9900,stroke:#232f3e,stroke-width:3px style A fill:#f3e5f5 style C fill:#f3e5f5 Điều kiện tiên quyết Đã hoàn thành Module 2: Thu thập Dữ liệu Thời tiết Dữ liệu thời tiết thô đã được thu thập trong S3 AWS CLI đã được cấu hình Bước 1: Tạo Hàm Lambda Xử lý Dữ liệu 1.1 Tạo Thư mục Hàm Lambda Tạo thư mục mới cho hàm Lambda của bạn:\nmkdir weather-processor cd weather-processor 1.2 Tạo Hàm Lambda Hoàn chỉnh Tạo file lambda_function.py với mã sau:\nimport json import boto3 import datetime import logging from decimal import Decimal import os # Cấu hình logging logger = logging.getLogger() logger.setLevel(logging.INFO) # Khởi tạo AWS clients s3_client = boto3.client(\u0026#39;s3\u0026#39;) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; Lambda handler chính cho xử lý dữ liệu thời tiết \u0026#34;\u0026#34;\u0026#34; try: processed_bucket = os.environ[\u0026#39;PROCESSED_BUCKET\u0026#39;] processed_count = 0 # Xử lý từng S3 event record for record in event[\u0026#39;Records\u0026#39;]: try: # Trích xuất bucket và key từ event source_bucket = record[\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;] source_key = record[\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;] logger.info(f\u0026#34;Đang xử lý file: {source_key} từ bucket: {source_bucket}\u0026#34;) # Lấy dữ liệu thời tiết thô từ S3 response = s3_client.get_object(Bucket=source_bucket, Key=source_key) raw_data = json.loads(response[\u0026#39;Body\u0026#39;].read().decode(\u0026#39;utf-8\u0026#39;)) # Biến đổi dữ liệu thời tiết processed_data = transform_weather_data(raw_data) # Tạo key cho file đã xử lý processed_key = source_key.replace(\u0026#39;raw/\u0026#39;, \u0026#39;processed/\u0026#39;).replace(\u0026#39;.json\u0026#39;, \u0026#39;_processed.json\u0026#39;) # Lưu dữ liệu đã xử lý vào S3 s3_client.put_object( Bucket=processed_bucket, Key=processed_key, Body=json.dumps(processed_data, indent=2, default=decimal_default), ContentType=\u0026#39;application/json\u0026#39; ) processed_count += 1 logger.info(f\u0026#34;Đã xử lý và lưu thành công: {processed_key}\u0026#34;) except Exception as e: logger.error(f\u0026#34;Lỗi xử lý record {source_key}: {str(e)}\u0026#34;) continue return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: f\u0026#39;Đã xử lý thành công {processed_count} files\u0026#39;, \u0026#39;processedCount\u0026#39;: processed_count }) } except Exception as e: logger.error(f\u0026#34;Lỗi thực thi Lambda: {str(e)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: str(e) }) } def transform_weather_data(raw_data): \u0026#34;\u0026#34;\u0026#34; Biến đổi dữ liệu OpenWeatherMap thô thành định dạng thân thiện với phân tích \u0026#34;\u0026#34;\u0026#34; try: # Trích xuất timestamp timestamp = datetime.datetime.fromtimestamp(raw_data[\u0026#39;dt\u0026#39;]).isoformat() + \u0026#39;Z\u0026#39; collection_date = datetime.datetime.fromtimestamp(raw_data[\u0026#39;dt\u0026#39;]).strftime(\u0026#39;%Y-%m-%d\u0026#39;) # Trích xuất thông tin vị trí và thời tiết cơ bản processed_data = { \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;city_name\u0026#39;: raw_data.get(\u0026#39;name\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;country\u0026#39;: raw_data.get(\u0026#39;sys\u0026#39;, {}).get(\u0026#39;country\u0026#39;, \u0026#39;Unknown\u0026#39;), \u0026#39;latitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lat\u0026#39;), \u0026#39;longitude\u0026#39;: raw_data.get(\u0026#39;coord\u0026#39;, {}).get(\u0026#39;lon\u0026#39;), \u0026#39;data_collection_date\u0026#39;: collection_date } # Chuyển đổi nhiệt độ temp_kelvin = raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;temp\u0026#39;) if temp_kelvin: processed_data[\u0026#39;temperature_kelvin\u0026#39;] = temp_kelvin processed_data[\u0026#39;temperature_celsius\u0026#39;] = round(temp_kelvin - 273.15, 2) processed_data[\u0026#39;temperature_fahrenheit\u0026#39;] = round((temp_kelvin - 273.15) * 9/5 + 32, 2) # Nhiệt độ cảm nhận feels_like_kelvin = raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;feels_like\u0026#39;) if feels_like_kelvin: processed_data[\u0026#39;feels_like_celsius\u0026#39;] = round(feels_like_kelvin - 273.15, 2) processed_data[\u0026#39;feels_like_fahrenheit\u0026#39;] = round((feels_like_kelvin - 273.15) * 9/5 + 32, 2) # Các thông số thời tiết khác processed_data.update({ \u0026#39;humidity_percent\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;humidity\u0026#39;), \u0026#39;pressure_hpa\u0026#39;: raw_data.get(\u0026#39;main\u0026#39;, {}).get(\u0026#39;pressure\u0026#39;), \u0026#39;visibility_meters\u0026#39;: raw_data.get(\u0026#39;visibility\u0026#39;), \u0026#39;uv_index\u0026#39;: raw_data.get(\u0026#39;uvi\u0026#39;) # Nếu có }) # Mô tả thời tiết weather_list = raw_data.get(\u0026#39;weather\u0026#39;, []) if weather_list: weather = weather_list[0] processed_data.update({ \u0026#39;weather_id\u0026#39;: weather.get(\u0026#39;id\u0026#39;), \u0026#39;weather_main\u0026#39;: weather.get(\u0026#39;main\u0026#39;), \u0026#39;weather_description\u0026#39;: weather.get(\u0026#39;description\u0026#39;), \u0026#39;weather_icon\u0026#39;: weather.get(\u0026#39;icon\u0026#39;) }) # Thông tin gió wind_data = raw_data.get(\u0026#39;wind\u0026#39;, {}) processed_data.update({ \u0026#39;wind_speed_ms\u0026#39;: wind_data.get(\u0026#39;speed\u0026#39;), \u0026#39;wind_direction_deg\u0026#39;: wind_data.get(\u0026#39;deg\u0026#39;), \u0026#39;wind_gust_ms\u0026#39;: wind_data.get(\u0026#39;gust\u0026#39;) }) # Chuyển đổi tốc độ gió sang km/h và mph if wind_data.get(\u0026#39;speed\u0026#39;): processed_data[\u0026#39;wind_speed_kmh\u0026#39;] = round(wind_data[\u0026#39;speed\u0026#39;] * 3.6, 2) processed_data[\u0026#39;wind_speed_mph\u0026#39;] = round(wind_data[\u0026#39;speed\u0026#39;] * 2.237, 2) # Độ che phủ mây processed_data[\u0026#39;cloud_coverage_percent\u0026#39;] = raw_data.get(\u0026#39;clouds\u0026#39;, {}).get(\u0026#39;all\u0026#39;) # Lượng mưa (nếu có) rain_data = raw_data.get(\u0026#39;rain\u0026#39;, {}) if rain_data: processed_data[\u0026#39;rain_1h_mm\u0026#39;] = rain_data.get(\u0026#39;1h\u0026#39;) processed_data[\u0026#39;rain_3h_mm\u0026#39;] = rain_data.get(\u0026#39;3h\u0026#39;) snow_data = raw_data.get(\u0026#39;snow\u0026#39;, {}) if snow_data: processed_data[\u0026#39;snow_1h_mm\u0026#39;] = snow_data.get(\u0026#39;1h\u0026#39;) processed_data[\u0026#39;snow_3h_mm\u0026#39;] = snow_data.get(\u0026#39;3h\u0026#39;) # Thêm các trường dẫn xuất processed_data.update(calculate_derived_fields(processed_data)) return processed_data except Exception as e: logger.error(f\u0026#34;Lỗi biến đổi dữ liệu thời tiết: {str(e)}\u0026#34;) raise def calculate_derived_fields(data): \u0026#34;\u0026#34;\u0026#34; Tính toán các chỉ số thời tiết dẫn xuất \u0026#34;\u0026#34;\u0026#34; derived = {} try: # Tính chỉ số nhiệt (đơn giản hóa) temp_f = data.get(\u0026#39;temperature_fahrenheit\u0026#39;) humidity = data.get(\u0026#39;humidity_percent\u0026#39;) if temp_f and humidity: if temp_f \u0026gt;= 80: # Chỉ số nhiệt chỉ có ý nghĩa trên 80°F # Công thức chỉ số nhiệt đơn giản heat_index_f = ( -42.379 + 2.04901523 * temp_f + 10.14333127 * humidity - 0.22475541 * temp_f * humidity - 6.83783e-3 * temp_f**2 - 5.481717e-2 * humidity**2 + 1.22874e-3 * temp_f**2 * humidity + 8.5282e-4 * temp_f * humidity**2 - 1.99e-6 * temp_f**2 * humidity**2 ) derived[\u0026#39;heat_index_fahrenheit\u0026#39;] = round(heat_index_f, 2) derived[\u0026#39;heat_index_celsius\u0026#39;] = round((heat_index_f - 32) * 5/9, 2) # Mức độ thoải mái dựa trên nhiệt độ và độ ẩm temp_c = data.get(\u0026#39;temperature_celsius\u0026#39;) if temp_c and humidity: if temp_c \u0026lt; 10: comfort = \u0026#39;lạnh\u0026#39; elif temp_c \u0026lt; 18: comfort = \u0026#39;mát\u0026#39; elif temp_c \u0026lt;= 24 and humidity \u0026lt;= 60: comfort = \u0026#39;thoải_mái\u0026#39; elif temp_c \u0026lt;= 30 and humidity \u0026lt;= 70: comfort = \u0026#39;ấm\u0026#39; else: comfort = \u0026#39;nóng\u0026#39; derived[\u0026#39;comfort_level\u0026#39;] = comfort # Tình trạng gió wind_speed_kmh = data.get(\u0026#39;wind_speed_kmh\u0026#39;) if wind_speed_kmh: if wind_speed_kmh \u0026lt; 5: wind_condition = \u0026#39;tĩnh_lặng\u0026#39; elif wind_speed_kmh \u0026lt; 20: wind_condition = \u0026#39;nhẹ\u0026#39; elif wind_speed_kmh \u0026lt; 40: wind_condition = \u0026#39;vừa\u0026#39; elif wind_speed_kmh \u0026lt; 60: wind_condition = \u0026#39;mạnh\u0026#39; else: wind_condition = \u0026#39;rất_mạnh\u0026#39; derived[\u0026#39;wind_condition\u0026#39;] = wind_condition # Mức độ nghiêm trọng thời tiết weather_main = data.get(\u0026#39;weather_main\u0026#39;, \u0026#39;\u0026#39;).lower() if weather_main: if weather_main in [\u0026#39;thunderstorm\u0026#39;, \u0026#39;tornado\u0026#39;]: severity = \u0026#39;nghiêm_trọng\u0026#39; elif weather_main in [\u0026#39;rain\u0026#39;, \u0026#39;snow\u0026#39;, \u0026#39;drizzle\u0026#39;]: severity = \u0026#39;vừa\u0026#39; elif weather_main in [\u0026#39;mist\u0026#39;, \u0026#39;fog\u0026#39;, \u0026#39;haze\u0026#39;]: severity = \u0026#39;nhẹ\u0026#39; else: severity = \u0026#39;bình_thường\u0026#39; derived[\u0026#39;weather_severity\u0026#39;] = severity return derived except Exception as e: logger.error(f\u0026#34;Lỗi tính toán các trường dẫn xuất: {str(e)}\u0026#34;) return {} def decimal_default(obj): \u0026#34;\u0026#34;\u0026#34; JSON serializer cho các đối tượng không thể serialize mặc định \u0026#34;\u0026#34;\u0026#34; if isinstance(obj, Decimal): return float(obj) raise TypeError 1.3 Tạo File Requirements Tạo file requirements.txt:\nboto3==1.34.0 Bước 2: Tạo S3 Bucket cho Dữ liệu Đã Xử lý # Tạo bucket cho dữ liệu đã xử lý aws s3 mb s3://your-weather-processed-bucket-name # Bật versioning aws s3api put-bucket-versioning \\ --bucket your-weather-processed-bucket-name \\ --versioning-configuration Status=Enabled Bước 3: Đóng gói và Triển khai Hàm Lambda 3.1 Tạo Gói Triển khai # Cài đặt dependencies pip install -r requirements.txt -t . # Tạo gói triển khai zip -r weather-processor.zip . 3.2 Tạo IAM Role cho Lambda Tạo file trust-policy.json:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;lambda.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Tạo file lambda-policy.json:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:logs:*:*:*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::your-weather-raw-bucket/*\u0026#34;, \u0026#34;arn:aws:s3:::your-weather-processed-bucket/*\u0026#34; ] } ] } Tạo IAM role:\n# Tạo role aws iam create-role \\ --role-name WeatherProcessorRole \\ --assume-role-policy-document file://trust-policy.json # Gắn policy aws iam put-role-policy \\ --role-name WeatherProcessorRole \\ --policy-name WeatherProcessorPolicy \\ --policy-document file://lambda-policy.json 3.3 Triển khai Hàm Lambda # Tạo hàm Lambda aws lambda create-function \\ --function-name weather-data-processor \\ --runtime python3.9 \\ --role arn:aws:iam::YOUR-ACCOUNT-ID:role/WeatherProcessorRole \\ --handler lambda_function.lambda_handler \\ --zip-file fileb://weather-processor.zip \\ --timeout 60 \\ --memory-size 256 \\ --environment Variables=\u0026#39;{ \u0026#34;PROCESSED_BUCKET\u0026#34;:\u0026#34;your-weather-processed-bucket-name\u0026#34; }\u0026#39; Bước 4: Thiết lập S3 Event Trigger Cấu hình S3 để kích hoạt hàm Lambda khi có file mới được upload:\n4.1 Thêm Quyền Lambda cho S3 aws lambda add-permission \\ --function-name weather-data-processor \\ --principal s3.amazonaws.com \\ --statement-id s3-trigger \\ --action lambda:InvokeFunction \\ --source-arn arn:aws:s3:::your-weather-raw-bucket 4.2 Tạo S3 Event Notification Tạo file notification-config.json:\n{ \u0026#34;LambdaConfigurations\u0026#34;: [ { \u0026#34;Id\u0026#34;: \u0026#34;weather-processor-trigger\u0026#34;, \u0026#34;LambdaFunctionArn\u0026#34;: \u0026#34;arn:aws:lambda:REGION:ACCOUNT-ID:function:weather-data-processor\u0026#34;, \u0026#34;Events\u0026#34;: [\u0026#34;s3:ObjectCreated:*\u0026#34;], \u0026#34;Filter\u0026#34;: { \u0026#34;Key\u0026#34;: { \u0026#34;FilterRules\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;prefix\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;raw/\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;suffix\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;.json\u0026#34; } ] } } } ] } Áp dụng cấu hình:\naws s3api put-bucket-notification-configuration \\ --bucket your-weather-raw-bucket \\ --notification-configuration file://notification-config.json Bước 5: Kiểm tra Xử lý Dữ liệu 5.1 Kiểm tra Thủ công Kiểm tra với file dữ liệu thời tiết mẫu:\n# Upload file test để kích hoạt xử lý aws s3 cp test-weather-data.json s3://your-weather-raw-bucket/raw/test-weather-data.json 5.2 Kiểm tra CloudWatch Logs # Xem logs của Lambda aws logs describe-log-groups --log-group-name-prefix /aws/lambda/weather-data-processor 5.3 Xác minh Dữ liệu Đã Xử lý # Liệt kê các file đã xử lý aws s3 ls s3://your-weather-processed-bucket/processed/ # Tải và kiểm tra dữ liệu đã xử lý aws s3 cp s3://your-weather-processed-bucket/processed/test-weather-data_processed.json . cat test-weather-data_processed.json | jq . Ví dụ biến đổi dữ liệu Dữ liệu OpenWeatherMap thô { \u0026#34;coord\u0026#34;: { \u0026#34;lon\u0026#34;: 106.6297, \u0026#34;lat\u0026#34;: 10.8231 }, \u0026#34;weather\u0026#34;: [ { \u0026#34;id\u0026#34;: 803, \u0026#34;main\u0026#34;: \u0026#34;Clouds\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;broken clouds\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;04d\u0026#34; } ], \u0026#34;main\u0026#34;: { \u0026#34;temp\u0026#34;: 305.15, \u0026#34;feels_like\u0026#34;: 309.65, \u0026#34;temp_min\u0026#34;: 305.15, \u0026#34;temp_max\u0026#34;: 305.15, \u0026#34;pressure\u0026#34;: 1013, \u0026#34;humidity\u0026#34;: 74 }, \u0026#34;wind\u0026#34;: { \u0026#34;speed\u0026#34;: 3.2, \u0026#34;deg\u0026#34;: 220 }, \u0026#34;clouds\u0026#34;: { \u0026#34;all\u0026#34;: 75 }, \u0026#34;dt\u0026#34;: 1642248000, \u0026#34;sys\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;sunrise\u0026#34;: 1642203600, \u0026#34;sunset\u0026#34;: 1642245600 }, \u0026#34;timezone\u0026#34;: 25200, \u0026#34;id\u0026#34;: 1566083, \u0026#34;name\u0026#34;: \u0026#34;Ho Chi Minh City\u0026#34; } Dữ liệu đã biến đổi { \u0026#34;timestamp\u0026#34;: \u0026#34;2025-01-15T09:00:00Z\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;Ho Chi Minh City\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;VN\u0026#34;, \u0026#34;latitude\u0026#34;: 10.8231, \u0026#34;longitude\u0026#34;: 106.6297, \u0026#34;temperature_celsius\u0026#34;: 32.0, \u0026#34;temperature_fahrenheit\u0026#34;: 89.6, \u0026#34;feels_like_celsius\u0026#34;: 36.5, \u0026#34;feels_like_fahrenheit\u0026#34;: 97.7, \u0026#34;humidity_percent\u0026#34;: 74, \u0026#34;pressure_hpa\u0026#34;: 1013, \u0026#34;weather_main\u0026#34;: \u0026#34;Clouds\u0026#34;, \u0026#34;weather_description\u0026#34;: \u0026#34;broken clouds\u0026#34;, \u0026#34;wind_speed_ms\u0026#34;: 3.2, \u0026#34;wind_speed_kmh\u0026#34;: 11.52, \u0026#34;wind_speed_mph\u0026#34;: 7.16, \u0026#34;wind_direction_deg\u0026#34;: 220, \u0026#34;cloud_coverage_percent\u0026#34;: 75, \u0026#34;heat_index_celsius\u0026#34;: 38.2, \u0026#34;heat_index_fahrenheit\u0026#34;: 100.8, \u0026#34;comfort_level\u0026#34;: \u0026#34;nóng\u0026#34;, \u0026#34;wind_condition\u0026#34;: \u0026#34;nhẹ\u0026#34;, \u0026#34;weather_severity\u0026#34;: \u0026#34;bình_thường\u0026#34;, \u0026#34;data_collection_date\u0026#34;: \u0026#34;2025-01-15\u0026#34; } Giám sát và Khắc phục Sự cố CloudWatch Metrics Giám sát các chỉ số quan trọng:\nSố lần gọi Lambda Lỗi và thời gian thực thi Metrics của S3 bucket Các Vấn đề Thường gặp Lỗi Quyền: Đảm bảo Lambda có quyền S3 thích hợp Vấn đề Bộ nhớ: Tăng bộ nhớ Lambda nếu xử lý file lớn Timeout: Điều chỉnh timeout Lambda cho các biến đổi phức tạp Lợi ích của biến đổi dữ liệu Cải thiện hiệu suất truy vấn: Cấu trúc phẳng dễ truy vấn hơn Giảm chi phí lưu trữ: Định dạng dữ liệu tối ưu sử dụng ít dung lượng hơn Nâng cao phân tích: Các trường dẫn xuất cho phép hiểu sâu hơn Chất lượng dữ liệu tốt hơn: Xác thực đảm bảo dữ liệu đáng tin cậy Các bước tiếp theo Sau khi hoàn thành module này, bạn sẽ có một pipeline biến đổi dữ liệu hoạt động đầy đủ để chuẩn bị dữ liệu thời tiết của bạn cho phân tích. Trong module tiếp theo, chúng ta sẽ sử dụng Amazon Athena để truy vấn và phân tích dữ liệu đã xử lý này.\nBiến đổi dữ liệu là nơi bạn có thể thêm kiến thức chuyên ngành của mình. Hãy xem xét các chỉ số thời tiết bổ sung nào có thể hữu ích cho nhu cầu phân tích cụ thể của bạn.\nNhớ thay thế các giá trị placeholder (YOUR-ACCOUNT-ID, REGION, tên bucket) bằng thông tin AWS account thực tế của bạn.\n"
},
{
	"uri": "//localhost:1313/vi/4-data-storage-solutions/",
	"title": "Phân tích Dữ liệu với Athena",
	"tags": [],
	"description": "",
	"content": "Phân tích Dữ liệu với Athena Trong module này, bạn sẽ học cách sử dụng Amazon Athena để chạy các truy vấn SQL trực tiếp trên dữ liệu thời tiết đã xử lý được lưu trữ trong S3. Athena là dịch vụ truy vấn serverless giúp dễ dàng phân tích dữ liệu bằng SQL tiêu chuẩn mà không cần thiết lập cơ sở hạ tầng kho dữ liệu phức tạp.\nTổng quan Module Amazon Athena cho phép bạn phân tích dữ liệu trong S3 bằng các truy vấn SQL tiêu chuẩn mà không cần phải di chuyển dữ liệu hoặc thiết lập máy chủ. Điều này làm cho nó trở thành công cụ lý tưởng để phân tích dữ liệu thời tiết của bạn. Trong module này, chúng ta sẽ thiết lập Athena để truy vấn dữ liệu thời tiết đã xử lý và trích xuất những hiểu biết có ý nghĩa.\nThời gian: 40-50 phút\nChi phí: ~$0.50\nNhững gì bạn sẽ xây dựng graph LR\rA[S3 Processed Data] --\u0026gt; B[Athena Query Service]\rB --\u0026gt; C[SQL Analysis]\rC --\u0026gt; D[Weather Insights]\rstyle B fill:#4fc3f7,stroke:#232f3e,stroke-width:3px\rstyle A fill:#f3e5f5\rstyle D fill:#66bb6a Điều kiện tiên quyết Đã hoàn thành Module 3: Xử lý và Chuyển đổi Dữ liệu Dữ liệu thời tiết đã xử lý có sẵn trong S3 Truy cập AWS Console Bước 1: Thiết lập Vị trí Kết quả Truy vấn Athena Trước khi sử dụng Athena, bạn cần cấu hình vị trí để lưu trữ kết quả truy vấn.\n1.1 Tạo S3 Bucket cho Kết quả Truy vấn # Tạo bucket cho kết quả truy vấn Athena aws s3 mb s3://your-athena-query-results-bucket # Tùy chọn: Thiết lập lifecycle policy để xóa kết quả cũ sau 30 ngày cat \u0026gt; lifecycle-policy.json \u0026lt;\u0026lt; EOF { \u0026#34;Rules\u0026#34;: [ { \u0026#34;ID\u0026#34;: \u0026#34;DeleteOldQueryResults\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Enabled\u0026#34;, \u0026#34;Filter\u0026#34;: {\u0026#34;Prefix\u0026#34;: \u0026#34;\u0026#34;}, \u0026#34;Expiration\u0026#34;: {\u0026#34;Days\u0026#34;: 30} } ] } EOF aws s3api put-bucket-lifecycle-configuration \\ --bucket your-athena-query-results-bucket \\ --lifecycle-configuration file://lifecycle-policy.json 1.2 Cấu hình Vị trí Kết quả Truy vấn Athena Mở Amazon Athena console Nhấp Settings ở góc phải trên Nhấp Manage Nhập đường dẫn S3 bucket: s3://your-athena-query-results-bucket/ Nhấp Save Bước 2: Tạo Database và Table 2.1 Tạo Weather Analytics Database Trong Athena Query Editor, chạy:\nCREATE DATABASE IF NOT EXISTS weather_analytics COMMENT \u0026#39;Database for weather data analysis\u0026#39; LOCATION \u0026#39;s3://your-athena-query-results-bucket/databases/weather_analytics/\u0026#39;; 2.2 Tạo External Table cho Dữ liệu Thời tiết Đã Xử lý CREATE EXTERNAL TABLE IF NOT EXISTS weather_analytics.current_weather ( timestamp STRING, city_name STRING, country STRING, latitude DOUBLE, longitude DOUBLE, data_collection_date STRING, temperature_kelvin DOUBLE, temperature_celsius DOUBLE, temperature_fahrenheit DOUBLE, feels_like_celsius DOUBLE, feels_like_fahrenheit DOUBLE, humidity_percent INT, pressure_hpa INT, visibility_meters BIGINT, uv_index DOUBLE, weather_id INT, weather_main STRING, weather_description STRING, weather_icon STRING, wind_speed_ms DOUBLE, wind_speed_kmh DOUBLE, wind_speed_mph DOUBLE, wind_direction_deg INT, wind_gust_ms DOUBLE, cloud_coverage_percent INT, rain_1h_mm DOUBLE, rain_3h_mm DOUBLE, snow_1h_mm DOUBLE, snow_3h_mm DOUBLE, heat_index_fahrenheit DOUBLE, heat_index_celsius DOUBLE, comfort_level STRING, wind_condition STRING, weather_severity STRING ) ROW FORMAT SERDE \u0026#39;org.openx.data.jsonserde.JsonSerDe\u0026#39; WITH SERDEPROPERTIES ( \u0026#39;serialization.format\u0026#39; = \u0026#39;1\u0026#39; ) LOCATION \u0026#39;s3://your-weather-processed-bucket/processed/\u0026#39; TBLPROPERTIES ( \u0026#39;has_encrypted_data\u0026#39;=\u0026#39;false\u0026#39;, \u0026#39;projection.enabled\u0026#39;=\u0026#39;true\u0026#39;, \u0026#39;projection.data_collection_date.type\u0026#39;=\u0026#39;date\u0026#39;, \u0026#39;projection.data_collection_date.range\u0026#39;=\u0026#39;2025-01-01,NOW\u0026#39;, \u0026#39;projection.data_collection_date.format\u0026#39;=\u0026#39;yyyy-MM-dd\u0026#39;, \u0026#39;storage.location.template\u0026#39;=\u0026#39;s3://your-weather-processed-bucket/processed/year=${data_collection_date}\u0026#39; ); 2.3 Xác minh Tạo Table -- Kiểm tra xem table đã được tạo thành công chưa SHOW TABLES IN weather_analytics; -- Lấy schema của table DESCRIBE weather_analytics.current_weather; -- Đếm tổng số bản ghi SELECT COUNT(*) as total_records FROM weather_analytics.current_weather; Bước 3: Phân tích Dữ liệu Thời tiết Cơ bản 3.1 Truy vấn Khám phá Dữ liệu Xem Dữ liệu Mẫu -- Lấy mẫu dữ liệu của bạn SELECT * FROM weather_analytics.current_weather LIMIT 10; Kiểm tra Chất lượng Dữ liệu -- Kiểm tra giá trị thiếu trong các trường chính SELECT COUNT(*) as total_records, COUNT(temperature_celsius) as temp_records, COUNT(humidity_percent) as humidity_records, COUNT(pressure_hpa) as pressure_records, COUNT(wind_speed_ms) as wind_records FROM weather_analytics.current_weather; Phân tích Phạm vi Ngày -- Kiểm tra phạm vi ngày của dữ liệu SELECT MIN(data_collection_date) as earliest_date, MAX(data_collection_date) as latest_date, COUNT(DISTINCT data_collection_date) as unique_dates FROM weather_analytics.current_weather; 3.2 Phân tích Nhiệt độ Nhiệt độ Trung bình theo Thành phố SELECT city_name, country, COUNT(*) as measurement_count, ROUND(AVG(temperature_celsius), 2) as avg_temp_celsius, ROUND(MIN(temperature_celsius), 2) as min_temp_celsius, ROUND(MAX(temperature_celsius), 2) as max_temp_celsius FROM weather_analytics.current_weather GROUP BY city_name, country ORDER BY avg_temp_celsius DESC; Xu hướng Nhiệt độ Theo Thời gian SELECT data_collection_date, city_name, ROUND(AVG(temperature_celsius), 2) as avg_temp, ROUND(AVG(feels_like_celsius), 2) as avg_feels_like FROM weather_analytics.current_weather WHERE data_collection_date \u0026gt;= DATE(\u0026#39;2025-01-01\u0026#39;) GROUP BY data_collection_date, city_name ORDER BY data_collection_date, city_name; Phân tích Chỉ số Nhiệt SELECT city_name, ROUND(AVG(heat_index_celsius), 2) as avg_heat_index, comfort_level, COUNT(*) as occurrence_count FROM weather_analytics.current_weather WHERE heat_index_celsius IS NOT NULL GROUP BY city_name, comfort_level ORDER BY avg_heat_index DESC; 3.3 Phân tích Mẫu Thời tiết Phân bố Điều kiện Thời tiết SELECT weather_main, weather_description, COUNT(*) as occurrence_count, ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage FROM weather_analytics.current_weather GROUP BY weather_main, weather_description ORDER BY occurrence_count DESC; Phân tích Gió SELECT city_name, wind_condition, COUNT(*) as occurrence_count, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed_kmh, ROUND(MAX(wind_speed_kmh), 2) as max_wind_speed_kmh FROM weather_analytics.current_weather GROUP BY city_name, wind_condition ORDER BY city_name, avg_wind_speed_kmh DESC; Tương quan Độ ẩm và Nhiệt độ SELECT city_name, CASE WHEN temperature_celsius \u0026lt; 15 THEN \u0026#39;Lạnh\u0026#39; WHEN temperature_celsius \u0026lt; 25 THEN \u0026#39;Vừa\u0026#39; ELSE \u0026#39;Nóng\u0026#39; END as temp_category, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(temperature_celsius), 2) as avg_temperature, COUNT(*) as sample_count FROM weather_analytics.current_weather GROUP BY city_name, CASE WHEN temperature_celsius \u0026lt; 15 THEN \u0026#39;Lạnh\u0026#39; WHEN temperature_celsius \u0026lt; 25 THEN \u0026#39;Vừa\u0026#39; ELSE \u0026#39;Nóng\u0026#39; END ORDER BY city_name, temp_category; Bước 4: Truy vấn Phân tích Nâng cao 4.1 Phân tích Chuỗi Thời gian Tóm tắt Thời tiết Hàng ngày SELECT data_collection_date, COUNT(DISTINCT city_name) as cities_measured, ROUND(AVG(temperature_celsius), 2) as global_avg_temp, ROUND(AVG(humidity_percent), 2) as global_avg_humidity, ROUND(AVG(pressure_hpa), 2) as global_avg_pressure FROM weather_analytics.current_weather GROUP BY data_collection_date ORDER BY data_collection_date; Cực trị Thời tiết -- Tìm cực trị nhiệt độ WITH temp_extremes AS ( SELECT data_collection_date, city_name, temperature_celsius, ROW_NUMBER() OVER (PARTITION BY data_collection_date ORDER BY temperature_celsius DESC) as hot_rank, ROW_NUMBER() OVER (PARTITION BY data_collection_date ORDER BY temperature_celsius ASC) as cold_rank FROM weather_analytics.current_weather ) SELECT data_collection_date, MAX(CASE WHEN hot_rank = 1 THEN city_name END) as hottest_city, MAX(CASE WHEN hot_rank = 1 THEN temperature_celsius END) as highest_temp, MAX(CASE WHEN cold_rank = 1 THEN city_name END) as coldest_city, MAX(CASE WHEN cold_rank = 1 THEN temperature_celsius END) as lowest_temp FROM temp_extremes WHERE hot_rank = 1 OR cold_rank = 1 GROUP BY data_collection_date ORDER BY data_collection_date; 4.2 Phân tích Địa lý Thời tiết theo Vùng Địa lý SELECT CASE WHEN latitude \u0026gt; 23.5 THEN \u0026#39;Ôn đới Bắc\u0026#39; WHEN latitude \u0026gt; 0 THEN \u0026#39;Nhiệt đới Bắc\u0026#39; WHEN latitude \u0026gt; -23.5 THEN \u0026#39;Nhiệt đới Nam\u0026#39; ELSE \u0026#39;Ôn đới Nam\u0026#39; END as climate_zone, COUNT(*) as measurement_count, ROUND(AVG(temperature_celsius), 2) as avg_temperature, ROUND(AVG(humidity_percent), 2) as avg_humidity, ROUND(AVG(wind_speed_kmh), 2) as avg_wind_speed FROM weather_analytics.current_weather GROUP BY CASE WHEN latitude \u0026gt; 23.5 THEN \u0026#39;Ôn đới Bắc\u0026#39; WHEN latitude \u0026gt; 0 THEN \u0026#39;Nhiệt đới Bắc\u0026#39; WHEN latitude \u0026gt; -23.5 THEN \u0026#39;Nhiệt đới Nam\u0026#39; ELSE \u0026#39;Ôn đới Nam\u0026#39; END ORDER BY avg_temperature DESC; Bước 5: Xuất và Trực quan hóa Kết quả 5.1 Lưu Kết quả Truy vấn Chạy bất kỳ truy vấn nào trong Athena Nhấp Download để lưu kết quả dưới dạng CSV Kết quả cũng được tự động lưu vào S3 query results bucket của bạn 5.2 Tạo Trực quan hóa Đơn giản Bạn có thể sử dụng các file CSV đã xuất để tạo biểu đồ trong:\nExcel hoặc Google Sheets cho biểu đồ cơ bản Python/Jupyter cho phân tích nâng cao QuickSight (được đề cập trong module tiếp theo) 5.3 Ví dụ Quy trình Phân tích -- Tạo báo cáo thời tiết toàn diện SELECT city_name, country, COUNT(*) as total_measurements, ROUND(AVG(temperature_celsius), 1) as avg_temp_c, ROUND(MIN(temperature_celsius), 1) as min_temp_c, ROUND(MAX(temperature_celsius), 1) as max_temp_c, ROUND(AVG(humidity_percent), 1) as avg_humidity, ROUND(AVG(pressure_hpa), 1) as avg_pressure, ROUND(AVG(wind_speed_kmh), 1) as avg_wind_kmh, MODE() WITHIN GROUP (ORDER BY weather_main) as most_common_weather, MODE() WITHIN GROUP (ORDER BY comfort_level) as most_common_comfort FROM weather_analytics.current_weather GROUP BY city_name, country HAVING COUNT(*) \u0026gt;= 5 -- Chỉ các thành phố có ít nhất 5 phép đo ORDER BY avg_temp_c DESC; Bước 6: Tối ưu hóa Hiệu suất 6.1 Mẹo Hiệu suất Truy vấn Sử dụng LIMIT cho truy vấn khám phá: SELECT * FROM weather_analytics.current_weather WHERE data_collection_date = \u0026#39;2025-01-15\u0026#39; LIMIT 100; Lọc trên cột partition: -- Tốt - lọc trên cột đã partition SELECT * FROM weather_analytics.current_weather WHERE data_collection_date BETWEEN \u0026#39;2025-01-01\u0026#39; AND \u0026#39;2025-01-07\u0026#39;; Chỉ select cột cần thiết: -- Hiệu suất tốt hơn SELECT city_name, temperature_celsius, humidity_percent FROM weather_analytics.current_weather; 6.2 Tối ưu hóa Chi phí Giám sát việc sử dụng Athena của bạn:\nKiểm tra CloudWatch metrics cho dữ liệu được quét Sử dụng Athena Query History để phân tích chi phí Xem xét chuyển đổi sang định dạng Parquet cho dataset lớn Khắc phục Các Vấn đề Thường gặp Vấn đề 1: Lỗi \u0026ldquo;Table not found\u0026rdquo; Xác minh quyền S3 bucket của bạn Kiểm tra dữ liệu tồn tại trong vị trí S3 đã chỉ định Đảm bảo schema table phù hợp với dữ liệu của bạn Vấn đề 2: \u0026ldquo;Zero records returned\u0026rdquo; Xác minh định dạng dữ liệu phù hợp với schema table Kiểm tra đường dẫn S3 trong định nghĩa table Đảm bảo files ở định dạng JSON như mong đợi Vấn đề 3: Lỗi \u0026ldquo;Access denied\u0026rdquo; Kiểm tra quyền IAM cho Athena và S3 Xác minh quyền query results bucket Phân tích Chi phí Chi phí điển hình cho module này:\nTruy vấn Athena: ~$5 per TB dữ liệu được quét Lưu trữ S3: ~$0.023 per GB/tháng Yêu cầu S3: ~$0.0004 per 1,000 yêu cầu Đối với dataset thời tiết điển hình (1-10 MB), mong đợi tổng chi phí dưới $0.50.\nCác bước tiếp theo Sau khi hoàn thành module này, bạn sẽ có thể phân tích dữ liệu thời tiết của mình bằng các truy vấn SQL trong Athena. Trong module tiếp theo, chúng ta sẽ xây dựng trên nền tảng này để tạo bảng điều khiển tương tác bằng Amazon QuickSight.\nKhi viết truy vấn Athena, luôn cố gắng giới hạn lượng dữ liệu được quét bằng cách sử dụng mệnh đề WHERE thích hợp trên các trường ngày tháng và các cột được lọc thường xuyên khác.\nLưu các truy vấn hữu ích của bạn dưới dạng Saved Queries trong Athena để tái sử dụng. Bạn cũng có thể tạo Views cho các truy vấn phức tạp thường được sử dụng.\nNhớ thay thế tên bucket placeholder bằng tên S3 bucket thực tế của bạn trong tất cả truy vấn SQL.\n"
},
{
	"uri": "//localhost:1313/vi/5-analytics-visualization/",
	"title": "Trực quan hóa Dữ liệu với QuickSight",
	"tags": [],
	"description": "",
	"content": "Trực quan hóa Dữ liệu với Amazon QuickSight Bây giờ khi bạn đã có dữ liệu thời tiết được lưu trữ và có thể truy vấn thông qua Athena, đã đến lúc tạo các trực quan hóa hấp dẫn! Trong module này, bạn sẽ sử dụng Amazon QuickSight để xây dựng dashboard tương tác giúp dữ liệu thời tiết của bạn trở nên sinh động.\nTổng quan Module Amazon QuickSight là dịch vụ business intelligence (BI) của AWS giúp dễ dàng tạo và xuất bản các dashboard tương tác. Bạn sẽ kết nối QuickSight với nguồn dữ liệu Athena và tạo các trực quan hóa tiết lộ các mẫu và thông tin chi tiết từ dữ liệu thời tiết.\nThời gian: 45-60 phút\nChi phí: ~$3-4 (sử dụng dùng thử miễn phí)\nNhững gì bạn sẽ Xây dựng graph LR\rA[Athena Data] --\u0026gt; B[QuickSight Dataset]\rB --\u0026gt; C[Visualizations]\rC --\u0026gt; D[Interactive Dashboard]\rD --\u0026gt; E[Published Reports]\rstyle B fill:#ff9900,stroke:#232f3e,stroke-width:3px\rstyle D fill:#66bb6a Điều kiện tiên quyết Đã hoàn thành Module 4: Phân tích Dữ liệu với Athena Dữ liệu thời tiết có sẵn trong bảng Athena Tài khoản AWS với quyền QuickSight Bước 1: Thiết lập Amazon QuickSight 1.1 Đăng ký QuickSight Điều hướng đến Amazon QuickSight console Nhấp Sign up for QuickSight Chọn Standard Edition (bao gồm dùng thử miễn phí 30 ngày) Nhập thông tin tài khoản: Account name: weather-analytics-[ten-ban] Notification email: Địa chỉ email của bạn Nhấp Finish 1.2 Cấu hình Quyền QuickSight Trong QuickSight, nhấp biểu tượng profile (góc phải trên) Chọn Manage QuickSight Chọn Security \u0026amp; permissions Nhấp Add or remove Kích hoạt các dịch vụ sau: ✅ Amazon Athena ✅ Amazon S3 Cho S3, nhấp Select S3 buckets Chọn bucket dữ liệu thời tiết: your-weather-processed-bucket your-athena-query-results-bucket Nhấp Update Bước 2: Tạo Data Source và Dataset 2.1 Kết nối với Athena Trong trang chủ QuickSight, nhấp Datasets Nhấp New dataset Chọn Athena làm data source Cấu hình kết nối: Data source name: Weather-Data-Athena Athena workgroup: primary (mặc định) Nhấp Create data source 2.2 Tạo Dataset từ Weather Table Chọn database: weather_analytics Chọn table: current_weather Chọn Directly query your data Nhấp Visualize Nếu dataset của bạn nhỏ (\u0026lt; 1GB), bạn có thể chọn \u0026ldquo;Import to SPICE\u0026rdquo; để có hiệu suất tốt hơn. SPICE là engine tính toán trong bộ nhớ của QuickSight.\nBước 3: Tạo Trực quan hóa Thời tiết 3.1 Biểu đồ Đường Xu hướng Nhiệt độ Tạo phân tích mới:\nNhấp + Add → Add visual Chọn Line chart Cấu hình biểu đồ:\nX-axis: Kéo data_collection_date vào X-axis Value: Kéo temperature_celsius vào Value Color: Kéo city_name vào Color Tùy chỉnh biểu đồ:\nNhấp visual → Format visual Title: \u0026ldquo;Xu hướng Nhiệt độ theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ (°C)\u0026rdquo; Legend: Đặt ở dưới cùng 3.2 Biểu đồ Tròn Điều kiện Thời tiết Thêm visual mới:\nNhấp + Add → Add visual Chọn Pie chart Cấu hình biểu đồ:\nGroup/Color: Kéo weather_main vào Group/Color Value: Kéo city_name vào Value Aggregate: Đổi thành Count Tùy chỉnh:\nTitle: \u0026ldquo;Phân bố Điều kiện Thời tiết\u0026rdquo; Legend: Hiển thị phần trăm 3.3 Biểu đồ Cột So sánh Nhiệt độ Thành phố Thêm visual mới:\nChọn Vertical bar chart Cấu hình:\nX-axis: Kéo city_name vào X-axis Value: Kéo temperature_celsius vào Value Aggregate: Đổi thành Average Tùy chỉnh:\nTitle: \u0026ldquo;Nhiệt độ Trung bình theo Thành phố\u0026rdquo; Y-axis label: \u0026ldquo;Nhiệt độ Trung bình (°C)\u0026rdquo; Sắp xếp theo giá trị (giảm dần) 3.4 Biểu đồ Phân tán Độ ẩm vs Nhiệt độ Thêm visual mới:\nChọn Scatter plot Cấu hình:\nX-axis: Kéo temperature_celsius vào X-axis Y-axis: Kéo humidity_percent vào Y-axis Color: Kéo comfort_level vào Color Size: Kéo pressure_hpa vào Size Tùy chỉnh:\nTitle: \u0026ldquo;Tương quan Độ ẩm và Nhiệt độ\u0026rdquo; X-axis label: \u0026ldquo;Nhiệt độ (°C)\u0026rdquo; Y-axis label: \u0026ldquo;Độ ẩm (%)\u0026rdquo; 3.5 Chỉ số Hiệu suất Chính (KPIs) Tạo các ô KPI cho dữ liệu thời tiết mới nhất:\nKPI Nhiệt độ Hiện tại Thêm visual mới → KPI Cấu hình: Value: temperature_celsius Aggregate: Average Filter: Thêm filter cho ngày mới nhất Title: \u0026ldquo;Nhiệt độ Trung bình Hiện tại\u0026rdquo; KPI Tốc độ Gió Thêm KPI visual Cấu hình: Value: wind_speed_kmh Aggregate: Average Title: \u0026ldquo;Tốc độ Gió Trung bình Hiện tại\u0026rdquo; KPI Độ ẩm Thêm KPI visual Cấu hình: Value: humidity_percent Aggregate: Average Title: \u0026ldquo;Độ ẩm Trung bình Hiện tại\u0026rdquo; Bước 4: Xây dựng Dashboard Toàn diện 4.1 Tổ chức Bố cục Dashboard Thay đổi kích thước và sắp xếp visuals:\nĐặt KPIs ở trên cùng theo hàng ngang Biểu đồ xu hướng nhiệt độ ở khu vực chính Biểu đồ tròn và biểu đồ cột cạnh nhau bên dưới Biểu đồ phân tán ở dưới cùng Thêm tiêu đề dashboard:\nNhấp + Add → Add title Text: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Style: Lớn, căn giữa 4.2 Thêm Bộ lọc Tương tác Thêm bộ lọc ngày:\nNhấp Filter pane (bên trái) Nhấp Create one → Chọn data_collection_date Filter type: Date range Default: 7 ngày gần nhất Thêm bộ lọc thành phố:\nTạo filter cho city_name Filter type: Multi-select dropdown Hiển thị tất cả thành phố theo mặc định Thêm bộ lọc điều kiện thời tiết:\nTạo filter cho weather_main Filter type: Multi-select dropdown 4.3 Áp dụng Styling Dashboard Chọn color theme:\nNhấp Themes (menu trên) Chọn Midnight hoặc Classic Tùy chỉnh màu sắc:\nCho biểu đồ nhiệt độ: Sử dụng gradient xanh-đỏ Cho điều kiện thời tiết: Sử dụng màu riêng biệt cho mỗi điều kiện Thêm text mô tả:\nNhấp + Add → Add text box Thêm insights hoặc hướng dẫn cho người dùng dashboard Bước 5: Trực quan hóa Nâng cao 5.1 Tạo Heat Map cho Nhiệt độ theo Thời gian Thêm visual mới → Heat map Cấu hình: Rows: city_name Columns: data_collection_date Values: temperature_celsius (Average) Tùy chỉnh: Title: \u0026ldquo;Heat Map Nhiệt độ theo Thành phố và Ngày\u0026rdquo; Color scale: Xanh (lạnh) đến Đỏ (nóng) 5.2 Biểu đồ Hướng Gió (Sử dụng Calculated Fields) Tạo calculated field:\nNhấp + Add → Add calculated field Name: wind_direction_category Formula: ifelse(\rwind_direction_deg \u0026gt;= 337.5 OR wind_direction_deg \u0026lt; 22.5, \u0026#34;N\u0026#34;,\rwind_direction_deg \u0026gt;= 22.5 AND wind_direction_deg \u0026lt; 67.5, \u0026#34;NE\u0026#34;,\rwind_direction_deg \u0026gt;= 67.5 AND wind_direction_deg \u0026lt; 112.5, \u0026#34;E\u0026#34;,\rwind_direction_deg \u0026gt;= 112.5 AND wind_direction_deg \u0026lt; 157.5, \u0026#34;SE\u0026#34;,\rwind_direction_deg \u0026gt;= 157.5 AND wind_direction_deg \u0026lt; 202.5, \u0026#34;S\u0026#34;,\rwind_direction_deg \u0026gt;= 202.5 AND wind_direction_deg \u0026lt; 247.5, \u0026#34;SW\u0026#34;,\rwind_direction_deg \u0026gt;= 247.5 AND wind_direction_deg \u0026lt; 292.5, \u0026#34;W\u0026#34;,\r\u0026#34;NW\u0026#34;\r) Tạo biểu đồ hướng gió:\nVisual type: Donut chart Group: wind_direction_category Value: Count of records Title: \u0026ldquo;Phân bố Hướng Gió\u0026rdquo; 5.3 Gauge Mức độ Nghiêm trọng Thời tiết Tạo calculated field:\nName: severity_score Formula: ifelse(\rweather_severity = \u0026#34;nghiêm_trọng\u0026#34;, 4,\rweather_severity = \u0026#34;vừa\u0026#34;, 3,\rweather_severity = \u0026#34;nhẹ\u0026#34;, 2,\r1\r) Thêm gauge visual:\nValue: severity_score (Average) Title: \u0026ldquo;Chỉ số Mức độ Nghiêm trọng Thời tiết\u0026rdquo; Range: 1-4 Bước 6: Xuất bản và Chia sẻ Dashboard 6.1 Xuất bản Dashboard Nhấp Share (góc phải trên) Nhấp Publish dashboard Dashboard name: \u0026ldquo;Dashboard Phân tích Thời tiết\u0026rdquo; Description: \u0026ldquo;Trực quan hóa dữ liệu thời tiết tương tác hiển thị xu hướng nhiệt độ, mẫu thời tiết và so sánh thành phố\u0026rdquo; Nhấp Publish dashboard 6.2 Thiết lập Quyền Chia sẻ Trong dashboard đã xuất bản, nhấp Share Add users or groups: Nhập địa chỉ email của người dùng để chia sẻ Đặt quyền: Viewer hoặc Co-owner Nhấp Share 6.3 Tạo Dashboard Công khai (Tùy chọn) Nhấp Share → Manage dashboard access Kích hoạt Make dashboard public Sao chép URL công khai để chia sẻ bên ngoài Chỉ công khai dashboard nếu dữ liệu thời tiết của bạn không chứa thông tin nhạy cảm.\nBước 7: Thiết lập Làm mới Dữ liệu Tự động 7.1 Cấu hình Làm mới Dataset Đi đến Datasets Chọn weather dataset của bạn Nhấp Refresh → Schedule refresh Cấu hình lịch: Frequency: Daily Time: Sáng sớm (ví dụ: 6 AM) Time zone: Múi giờ địa phương của bạn Lưu lịch 7.2 Giám sát Trạng thái Làm mới Kiểm tra lịch sử làm mới trong Dataset settings Thiết lập thông báo cho làm mới thất bại Giám sát chỉ báo độ tươi của dữ liệu trong dashboard Bước 8: Tối ưu hóa Dashboard và Best Practices 8.1 Tối ưu hóa Hiệu suất Sử dụng SPICE cho hiệu suất tốt hơn:\nImport dữ liệu vào SPICE nếu dataset \u0026lt; 10GB Lập lịch làm mới SPICE thường xuyên Tối ưu hóa truy vấn:\nSử dụng filter để giảm việc quét dữ liệu Tạo bảng tóm tắt trong Athena cho dataset lớn Giới hạn độ phức tạp visual:\nTối đa 15-20 điểm dữ liệu mỗi biểu đồ Sử dụng drill-down cho view chi tiết 8.2 Best Practices Trải nghiệm Người dùng Thứ bậc visual rõ ràng:\nCác metric quan trọng nhất ở trên Các visual liên quan được nhóm lại Màu sắc nhất quán Các yếu tố tương tác:\nCung cấp hướng dẫn filter rõ ràng Sử dụng phạm vi ngày nhất quán Kích hoạt cross-filtering giữa các visual Tính responsive di động:\nKiểm tra dashboard trên thiết bị di động Điều chỉnh layout cho màn hình nhỏ hơn Ưu tiên metric chính cho view di động Khắc phục Các Vấn đề Thường gặp Vấn đề 1: Lỗi \u0026ldquo;Insufficient permissions\u0026rdquo; Giải pháp: Kiểm tra quyền IAM của QuickSight cho truy cập Athena và S3 Xác minh quyền bucket trong cài đặt bảo mật QuickSight Vấn đề 2: Dữ liệu Không Làm mới Giải pháp: Kiểm tra quyền truy vấn Athena Xác minh trạng thái kết nối data source Xem lại error logs của làm mới Vấn đề 3: Hiệu suất Dashboard Chậm Giải pháp: Import dữ liệu vào SPICE Tối ưu hóa truy vấn Athena với filtering phù hợp Giảm số lượng visual mỗi dashboard Phân tích Chi phí Chi phí QuickSight cho module này:\nStandard Edition: $9/tháng mỗi author (dùng thử miễn phí 30 ngày) SPICE storage: $0.25/GB/tháng Enterprise Edition: $18/tháng mỗi author (tính năng nâng cao) Tổng chi phí ước tính: $0-4 trong thời gian dùng thử miễn phí\nBest Practices Bảo mật Kiểm soát Truy cập:\nSử dụng IAM roles cho quyền dịch vụ Triển khai row-level security nếu cần Audit thường xuyên quyền truy cập người dùng Bảo vệ Dữ liệu:\nKích hoạt mã hóa trong transit và at rest Sử dụng VPC endpoints cho kết nối riêng tư Giám sát patterns truy cập dữ liệu Các bước tiếp theo Sau khi hoàn thành module này, bạn sẽ có:\n✅ Dashboard thời tiết tương tác với nhiều trực quan hóa ✅ Làm mới dữ liệu tự động từ ETL pipeline ✅ Insights có thể chia sẻ cho phân tích thời tiết ✅ Hiểu biết về best practices của QuickSight Sắp tới trong Module 6: Học cách dọn dẹp đúng cách các tài nguyên AWS và khám phá các cải tiến nâng cao cho nền tảng phân tích thời tiết của bạn.\nLưu dashboard của bạn dưới dạng template để nhanh chóng tạo dashboard tương tự cho các dataset hoặc thời gian khác nhau.\nQuickSight cung cấp insights được hỗ trợ ML. Hãy thử tính năng ML Insights để tự động khám phá anomalies và trends trong dữ liệu thời tiết của bạn.\nNhớ hủy đăng ký QuickSight sau workshop nếu bạn không có kế hoạch tiếp tục sử dụng để tránh các khoản phí liên tục.\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]